{"version":3,"sources":["vendor/ember-cli/test-support-prefix.js","bower_components/ember/ember-testing.js","vendor/qunit/qunit.js","vendor/qunit-notifications/index.js","vendor/ember-cli-qunit/qunit-configuration.js","vendor/ember-cli-qunit/test-loader.js","vendor/sinon/pkg/sinon.js","vendor/ember-sinon/shim.js","addon-test-support/ember-cli-test-loader/test-support/index.js","addon-test-support/ember-qunit.js","addon-test-support/ember-qunit/adapter.js","addon-test-support/ember-qunit/module-for-component.js","addon-test-support/ember-qunit/module-for-model.js","addon-test-support/ember-qunit/module-for.js","addon-test-support/ember-qunit/qunit-module.js","addon-test-support/ember-test-helpers.js","addon-test-support/ember-test-helpers/-legacy-overrides.js","addon-test-support/ember-test-helpers/abstract-test-module.js","addon-test-support/ember-test-helpers/build-registry.js","addon-test-support/ember-test-helpers/has-ember-version.js","addon-test-support/ember-test-helpers/test-context.js","addon-test-support/ember-test-helpers/test-module-for-acceptance.js","addon-test-support/ember-test-helpers/test-module-for-component.js","addon-test-support/ember-test-helpers/test-module-for-integration.js","addon-test-support/ember-test-helpers/test-module-for-model.js","addon-test-support/ember-test-helpers/test-module.js","addon-test-support/ember-test-helpers/test-resolver.js","addon-test-support/ember-test-helpers/wait.js","addon-test-support/klassy.js","addon-test-support/qunit.js","vendor/ember-cli/test-support-suffix.js"],"sourcesContent":["/* jshint ignore:start */\n\n\n\n/* jshint ignore:end */\n","/*!\n * @overview  Ember - JavaScript Application Framework\n * @copyright Copyright 2011-2015 Tilde Inc. and contributors\n *            Portions Copyright 2006-2011 Strobe Inc.\n *            Portions Copyright 2008-2011 Apple Inc. All rights reserved.\n * @license   Licensed under MIT license\n *            See https://raw.github.com/emberjs/ember.js/master/LICENSE\n * @version   1.13.13\n */\n\n(function() {\nvar enifed, requireModule, eriuqer, requirejs, Ember;\nvar mainContext = this;\n\n(function() {\n  var isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n  if (!isNode) {\n    Ember = this.Ember = this.Ember || {};\n  }\n\n  if (typeof Ember === 'undefined') { Ember = {}; };\n\n  if (typeof Ember.__loader === 'undefined') {\n    var registry = {};\n    var seen = {};\n\n    enifed = function(name, deps, callback) {\n      var value = { };\n\n      if (!callback) {\n        value.deps = [];\n        value.callback = deps;\n      } else {\n        value.deps = deps;\n        value.callback = callback;\n      }\n\n        registry[name] = value;\n    };\n\n    requirejs = eriuqer = requireModule = function(name) {\n      return internalRequire(name, null);\n    }\n\n    function internalRequire(name, referrerName) {\n      var exports = seen[name];\n\n      if (exports !== undefined) {\n        return exports;\n      }\n\n      exports = seen[name] = {};\n\n      if (!registry[name]) {\n        if (referrerName) {\n          throw new Error('Could not find module ' + name + ' required by: ' + referrerName);\n        } else {\n          throw new Error('Could not find module ' + name);\n        }\n      }\n\n      var mod = registry[name];\n      var deps = mod.deps;\n      var callback = mod.callback;\n      var reified = [];\n      var length = deps.length;\n\n      for (var i=0; i<length; i++) {\n        if (deps[i] === 'exports') {\n          reified.push(exports);\n        } else {\n          reified.push(internalRequire(resolve(deps[i], name), name));\n        }\n      }\n\n      callback.apply(this, reified);\n\n      return exports;\n    };\n\n    function resolve(child, name) {\n      if (child.charAt(0) !== '.') {\n        return child;\n      }\n      var parts = child.split('/');\n      var parentBase = name.split('/').slice(0, -1);\n\n      for (var i=0, l=parts.length; i<l; i++) {\n        var part = parts[i];\n\n        if (part === '..') {\n          parentBase.pop();\n        } else if (part === '.') {\n          continue;\n        } else {\n          parentBase.push(part);\n        }\n      }\n\n      return parentBase.join('/');\n    }\n\n    requirejs._eak_seen = registry;\n\n    Ember.__loader = {\n      define: enifed,\n      require: eriuqer,\n      registry: registry\n    };\n  } else {\n    enifed = Ember.__loader.define;\n    requirejs = eriuqer = requireModule = Ember.__loader.require;\n  }\n})();\n\nenifed(\"ember-debug\", [\"exports\", \"ember-metal/core\", \"ember-metal/error\", \"ember-metal/logger\", \"ember-debug/deprecation-manager\", \"ember-metal/environment\"], function (exports, _emberMetalCore, _emberMetalError, _emberMetalLogger, _emberDebugDeprecationManager, _emberMetalEnvironment) {\n  /*global __fail__*/\n\n  \"use strict\";\n\n  exports._warnIfUsingStrippedFeatureFlags = _warnIfUsingStrippedFeatureFlags;\n\n  /**\n  @module ember\n  @submodule ember-debug\n  */\n\n  /**\n  @class Ember\n  @public\n  */\n\n  function isPlainFunction(test) {\n    return typeof test === 'function' && test.PrototypeMixin === undefined;\n  }\n\n  /**\n    Define an assertion that will throw an exception if the condition is not\n    met. Ember build tools will remove any calls to `Ember.assert()` when\n    doing a production build. Example:\n  \n    ```javascript\n    // Test for truthiness\n    Ember.assert('Must pass a valid object', obj);\n  \n    // Fail unconditionally\n    Ember.assert('This code path should never be run');\n    ```\n  \n    @method assert\n    @param {String} desc A description of the assertion. This will become\n      the text of the Error thrown if the assertion fails.\n    @param {Boolean|Function} test Must be truthy for the assertion to pass. If\n      falsy, an exception will be thrown. If this is a function, it will be executed and\n      its return value will be used as condition.\n    @public\n  */\n  _emberMetalCore[\"default\"].assert = function (desc, test) {\n    var throwAssertion;\n\n    if (isPlainFunction(test)) {\n      throwAssertion = !test();\n    } else {\n      throwAssertion = !test;\n    }\n\n    if (throwAssertion) {\n      throw new _emberMetalError[\"default\"](\"Assertion Failed: \" + desc);\n    }\n  };\n\n  /**\n    Display a warning with the provided message. Ember build tools will\n    remove any calls to `Ember.warn()` when doing a production build.\n  \n    @method warn\n    @param {String} message A warning to display.\n    @param {Boolean} test An optional boolean. If falsy, the warning\n      will be displayed.\n    @public\n  */\n  _emberMetalCore[\"default\"].warn = function (message, test) {\n    if (!test) {\n      _emberMetalLogger[\"default\"].warn(\"WARNING: \" + message);\n      if ('trace' in _emberMetalLogger[\"default\"]) {\n        _emberMetalLogger[\"default\"].trace();\n      }\n    }\n  };\n\n  /**\n    Display a debug notice. Ember build tools will remove any calls to\n    `Ember.debug()` when doing a production build.\n  \n    ```javascript\n    Ember.debug('I\\'m a debug notice!');\n    ```\n  \n    @method debug\n    @param {String} message A debug message to display.\n    @public\n  */\n  _emberMetalCore[\"default\"].debug = function (message) {\n    _emberMetalLogger[\"default\"].debug(\"DEBUG: \" + message);\n  };\n\n  /**\n    Display a deprecation warning with the provided message and a stack trace\n    (Chrome and Firefox only). Ember build tools will remove any calls to\n    `Ember.deprecate()` when doing a production build.\n  \n    @method deprecate\n    @param {String} message A description of the deprecation.\n    @param {Boolean|Function} test An optional boolean. If falsy, the deprecation\n      will be displayed. If this is a function, it will be executed and its return\n      value will be used as condition.\n    @param {Object} options An optional object that can be used to pass\n      in a `url` to the transition guide on the emberjs.com website, and a unique\n      `id` for this deprecation. The `id` can be used by Ember debugging tools\n      to change the behavior (raise, log or silence) for that specific deprecation.\n      The `id` should be namespaced by dots, e.g. \"view.helper.select\".\n    @public\n  */\n  _emberMetalCore[\"default\"].deprecate = function (message, test, options) {\n    if (_emberMetalCore[\"default\"].ENV.RAISE_ON_DEPRECATION) {\n      _emberDebugDeprecationManager[\"default\"].setDefaultLevel(_emberDebugDeprecationManager.deprecationLevels.RAISE);\n    }\n    if (_emberDebugDeprecationManager[\"default\"].getLevel(options && options.id) === _emberDebugDeprecationManager.deprecationLevels.SILENCE) {\n      return;\n    }\n\n    var noDeprecation;\n\n    if (isPlainFunction(test)) {\n      noDeprecation = test();\n    } else {\n      noDeprecation = test;\n    }\n\n    if (noDeprecation) {\n      return;\n    }\n\n    if (options && options.id) {\n      message = message + (\" [deprecation id: \" + options.id + \"]\");\n    }\n\n    if (_emberDebugDeprecationManager[\"default\"].getLevel(options && options.id) === _emberDebugDeprecationManager.deprecationLevels.RAISE) {\n      throw new _emberMetalError[\"default\"](message);\n    }\n\n    var error;\n\n    // When using new Error, we can't do the arguments check for Chrome. Alternatives are welcome\n    try {\n      __fail__.fail();\n    } catch (e) {\n      error = e;\n    }\n\n    if (arguments.length === 3) {\n      _emberMetalCore[\"default\"].assert('options argument to Ember.deprecate should be an object', options && typeof options === 'object');\n      if (options.url) {\n        message += ' See ' + options.url + ' for more details.';\n      }\n    }\n\n    if (_emberMetalCore[\"default\"].LOG_STACKTRACE_ON_DEPRECATION && error.stack) {\n      var stack;\n      var stackStr = '';\n\n      if (error['arguments']) {\n        // Chrome\n        stack = error.stack.replace(/^\\s+at\\s+/gm, '').replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}($1)$2').replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}($1)').split('\\n');\n        stack.shift();\n      } else {\n        // Firefox\n        stack = error.stack.replace(/(?:\\n@:0)?\\s+$/m, '').replace(/^\\(/gm, '{anonymous}(').split('\\n');\n      }\n\n      stackStr = \"\\n    \" + stack.slice(2).join(\"\\n    \");\n      message = message + stackStr;\n    }\n\n    _emberMetalLogger[\"default\"].warn(\"DEPRECATION: \" + message);\n  };\n\n  /**\n    Alias an old, deprecated method with its new counterpart.\n  \n    Display a deprecation warning with the provided message and a stack trace\n    (Chrome and Firefox only) when the assigned method is called.\n  \n    Ember build tools will not remove calls to `Ember.deprecateFunc()`, though\n    no warnings will be shown in production.\n  \n    ```javascript\n    Ember.oldMethod = Ember.deprecateFunc('Please use the new, updated method', Ember.newMethod);\n    ```\n  \n    @method deprecateFunc\n    @param {String} message A description of the deprecation.\n    @param {Object} [options] The options object for Ember.deprecate.\n    @param {Function} func The new function called to replace its deprecated counterpart.\n    @return {Function} a new function that wrapped the original function with a deprecation warning\n    @private\n  */\n  _emberMetalCore[\"default\"].deprecateFunc = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 3) {\n      var _ret = (function () {\n        var message = args[0];\n        var options = args[1];\n        var func = args[2];\n\n        return {\n          v: function () {\n            _emberMetalCore[\"default\"].deprecate(message, false, options);\n            return func.apply(this, arguments);\n          }\n        };\n      })();\n\n      if (typeof _ret === \"object\") return _ret.v;\n    } else {\n      var _ret2 = (function () {\n        var message = args[0];\n        var func = args[1];\n\n        return {\n          v: function () {\n            _emberMetalCore[\"default\"].deprecate(message);\n            return func.apply(this, arguments);\n          }\n        };\n      })();\n\n      if (typeof _ret2 === \"object\") return _ret2.v;\n    }\n  };\n\n  /**\n    Run a function meant for debugging. Ember build tools will remove any calls to\n    `Ember.runInDebug()` when doing a production build.\n  \n    ```javascript\n    Ember.runInDebug(() => {\n      Ember.Component.reopen({\n        didInsertElement() {\n          console.log(\"I'm happy\");\n        }\n      });\n    });\n    ```\n  \n    @method runInDebug\n    @param {Function} func The function to be executed.\n    @since 1.5.0\n    @public\n  */\n  _emberMetalCore[\"default\"].runInDebug = function (func) {\n    func();\n  };\n\n  /**\n    Will call `Ember.warn()` if ENABLE_ALL_FEATURES, ENABLE_OPTIONAL_FEATURES, or\n    any specific FEATURES flag is truthy.\n  \n    This method is called automatically in debug canary builds.\n  \n    @private\n    @method _warnIfUsingStrippedFeatureFlags\n    @return {void}\n  */\n\n  function _warnIfUsingStrippedFeatureFlags(FEATURES, featuresWereStripped) {\n    if (featuresWereStripped) {\n      _emberMetalCore[\"default\"].warn('Ember.ENV.ENABLE_ALL_FEATURES is only available in canary builds.', !_emberMetalCore[\"default\"].ENV.ENABLE_ALL_FEATURES);\n      _emberMetalCore[\"default\"].warn('Ember.ENV.ENABLE_OPTIONAL_FEATURES is only available in canary builds.', !_emberMetalCore[\"default\"].ENV.ENABLE_OPTIONAL_FEATURES);\n\n      for (var key in FEATURES) {\n        if (FEATURES.hasOwnProperty(key) && key !== 'isEnabled') {\n          _emberMetalCore[\"default\"].warn('FEATURE[\"' + key + '\"] is set as enabled, but FEATURE flags are only available in canary builds.', !FEATURES[key]);\n        }\n      }\n    }\n  }\n\n  if (!_emberMetalCore[\"default\"].testing) {\n    // Complain if they're using FEATURE flags in builds other than canary\n    _emberMetalCore[\"default\"].FEATURES['features-stripped-test'] = true;\n    var featuresWereStripped = true;\n\n    \n    delete _emberMetalCore[\"default\"].FEATURES['features-stripped-test'];\n    _warnIfUsingStrippedFeatureFlags(_emberMetalCore[\"default\"].ENV.FEATURES, featuresWereStripped);\n\n    // Inform the developer about the Ember Inspector if not installed.\n    var isFirefox = _emberMetalEnvironment[\"default\"].isFirefox;\n    var isChrome = _emberMetalEnvironment[\"default\"].isChrome;\n\n    if (typeof window !== 'undefined' && (isFirefox || isChrome) && window.addEventListener) {\n      window.addEventListener(\"load\", function () {\n        if (document.documentElement && document.documentElement.dataset && !document.documentElement.dataset.emberExtension) {\n          var downloadURL;\n\n          if (isChrome) {\n            downloadURL = 'https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi';\n          } else if (isFirefox) {\n            downloadURL = 'https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/';\n          }\n\n          _emberMetalCore[\"default\"].debug('For more advanced debugging, install the Ember Inspector from ' + downloadURL);\n        }\n      }, false);\n    }\n  }\n\n  _emberMetalCore[\"default\"].Debug = {\n    _addDeprecationLevel: function (id, level) {\n      _emberDebugDeprecationManager[\"default\"].setLevel(id, level);\n    },\n    _deprecationLevels: _emberDebugDeprecationManager.deprecationLevels\n  };\n\n  /*\n    We are transitioning away from `ember.js` to `ember.debug.js` to make\n    it much clearer that it is only for local development purposes.\n  \n    This flag value is changed by the tooling (by a simple string replacement)\n    so that if `ember.js` (which must be output for backwards compat reasons) is\n    used a nice helpful warning message will be printed out.\n  */\n  var runningNonEmberDebugJS = false;\n  exports.runningNonEmberDebugJS = runningNonEmberDebugJS;\n  if (runningNonEmberDebugJS) {\n    _emberMetalCore[\"default\"].warn('Please use `ember.debug.js` instead of `ember.js` for development and debugging.');\n  }\n});\nenifed('ember-debug/deprecation-manager', ['exports', 'ember-metal/dictionary', 'ember-metal/utils'], function (exports, _emberMetalDictionary, _emberMetalUtils) {\n  'use strict';\n\n  var deprecationLevels = {\n    RAISE: _emberMetalUtils.symbol('RAISE'),\n    LOG: _emberMetalUtils.symbol('LOG'),\n    SILENCE: _emberMetalUtils.symbol('SILENCE')\n  };\n\n  exports.deprecationLevels = deprecationLevels;\n  exports[\"default\"] = {\n    defaultLevel: deprecationLevels.LOG,\n    individualLevels: _emberMetalDictionary[\"default\"](null),\n    setDefaultLevel: function (level) {\n      this.defaultLevel = level;\n    },\n    setLevel: function (id, level) {\n      this.individualLevels[id] = level;\n    },\n    getLevel: function (id) {\n      var level = this.individualLevels[id];\n      if (!level) {\n        level = this.defaultLevel;\n      }\n      return level;\n    }\n  };\n});\nenifed(\"ember-testing\", [\"exports\", \"ember-metal/core\", \"ember-testing/initializers\", \"ember-testing/support\", \"ember-testing/setup_for_testing\", \"ember-testing/test\", \"ember-testing/adapters/adapter\", \"ember-testing/adapters/qunit\", \"ember-testing/helpers\"], function (exports, _emberMetalCore, _emberTestingInitializers, _emberTestingSupport, _emberTestingSetup_for_testing, _emberTestingTest, _emberTestingAdaptersAdapter, _emberTestingAdaptersQunit, _emberTestingHelpers) {\n  \"use strict\";\n\n  // adds helpers to helpers object in Test\n\n  /**\n    @module ember\n    @submodule ember-testing\n  */\n\n  _emberMetalCore[\"default\"].Test = _emberTestingTest[\"default\"];\n  _emberMetalCore[\"default\"].Test.Adapter = _emberTestingAdaptersAdapter[\"default\"];\n  _emberMetalCore[\"default\"].Test.QUnitAdapter = _emberTestingAdaptersQunit[\"default\"];\n  _emberMetalCore[\"default\"].setupForTesting = _emberTestingSetup_for_testing[\"default\"];\n});\n// to setup initializer\n// to handle various edge cases\nenifed(\"ember-testing/adapters/adapter\", [\"exports\", \"ember-runtime/system/object\"], function (exports, _emberRuntimeSystemObject) {\n  \"use strict\";\n\n  function K() {\n    return this;\n  }\n\n  /**\n   @module ember\n   @submodule ember-testing\n  */\n\n  /**\n    The primary purpose of this class is to create hooks that can be implemented\n    by an adapter for various test frameworks.\n  \n    @class Adapter\n    @namespace Ember.Test\n    @public\n  */\n  var Adapter = _emberRuntimeSystemObject[\"default\"].extend({\n    /**\n      This callback will be called whenever an async operation is about to start.\n       Override this to call your framework's methods that handle async\n      operations.\n       @public\n      @method asyncStart\n    */\n    asyncStart: K,\n\n    /**\n      This callback will be called whenever an async operation has completed.\n       @public\n      @method asyncEnd\n    */\n    asyncEnd: K,\n\n    /**\n      Override this method with your testing framework's false assertion.\n      This function is called whenever an exception occurs causing the testing\n      promise to fail.\n       QUnit example:\n       ```javascript\n        exception: function(error) {\n          ok(false, error);\n        };\n      ```\n       @public\n      @method exception\n      @param {String} error The exception to be raised.\n    */\n    exception: function (error) {\n      throw error;\n    }\n  });\n\n  exports[\"default\"] = Adapter;\n});\nenifed(\"ember-testing/adapters/qunit\", [\"exports\", \"ember-testing/adapters/adapter\", \"ember-metal/utils\"], function (exports, _emberTestingAdaptersAdapter, _emberMetalUtils) {\n  \"use strict\";\n\n  /**\n    This class implements the methods defined by Ember.Test.Adapter for the\n    QUnit testing framework.\n  \n    @class QUnitAdapter\n    @namespace Ember.Test\n    @extends Ember.Test.Adapter\n    @public\n  */\n  exports[\"default\"] = _emberTestingAdaptersAdapter[\"default\"].extend({\n    asyncStart: function () {\n      QUnit.stop();\n    },\n    asyncEnd: function () {\n      QUnit.start();\n    },\n    exception: function (error) {\n      ok(false, _emberMetalUtils.inspect(error));\n    }\n  });\n});\nenifed(\"ember-testing/helpers\", [\"exports\", \"ember-metal/core\", \"ember-metal/property_get\", \"ember-metal/error\", \"ember-metal/run_loop\", \"ember-views/system/jquery\", \"ember-testing/test\", \"ember-runtime/ext/rsvp\"], function (exports, _emberMetalCore, _emberMetalProperty_get, _emberMetalError, _emberMetalRun_loop, _emberViewsSystemJquery, _emberTestingTest, _emberRuntimeExtRsvp) {\n  \"use strict\";\n\n  /**\n  @module ember\n  @submodule ember-testing\n  */\n\n  var helper = _emberTestingTest[\"default\"].registerHelper;\n  var asyncHelper = _emberTestingTest[\"default\"].registerAsyncHelper;\n\n  function currentRouteName(app) {\n    var appController = app.__container__.lookup('controller:application');\n\n    return _emberMetalProperty_get.get(appController, 'currentRouteName');\n  }\n\n  function currentPath(app) {\n    var appController = app.__container__.lookup('controller:application');\n\n    return _emberMetalProperty_get.get(appController, 'currentPath');\n  }\n\n  function currentURL(app) {\n    var router = app.__container__.lookup('router:main');\n\n    return _emberMetalProperty_get.get(router, 'location').getURL();\n  }\n\n  function pauseTest() {\n    _emberTestingTest[\"default\"].adapter.asyncStart();\n    return new _emberMetalCore[\"default\"].RSVP.Promise(function () {}, 'TestAdapter paused promise');\n  }\n\n  function focus(el) {\n    if (el && el.is(':input, [contenteditable=true]')) {\n      var type = el.prop('type');\n      if (type !== 'checkbox' && type !== 'radio' && type !== 'hidden') {\n        _emberMetalRun_loop[\"default\"](el, function () {\n          // Firefox does not trigger the `focusin` event if the window\n          // does not have focus. If the document doesn't have focus just\n          // use trigger('focusin') instead.\n          if (!document.hasFocus || document.hasFocus()) {\n            this.focus();\n          } else {\n            this.trigger('focusin');\n          }\n        });\n      }\n    }\n  }\n\n  function visit(app, url) {\n    var router = app.__container__.lookup('router:main');\n    var shouldHandleURL = false;\n\n    app.boot().then(function () {\n      router.location.setURL(url);\n\n      if (shouldHandleURL) {\n        _emberMetalRun_loop[\"default\"](app.__deprecatedInstance__, 'handleURL', url);\n      }\n    });\n\n    if (app._readinessDeferrals > 0) {\n      router['initialURL'] = url;\n      _emberMetalRun_loop[\"default\"](app, 'advanceReadiness');\n      delete router['initialURL'];\n    } else {\n      shouldHandleURL = true;\n    }\n\n    return app.testHelpers.wait();\n  }\n\n  function click(app, selector, context) {\n    var $el = app.testHelpers.findWithAssert(selector, context);\n    _emberMetalRun_loop[\"default\"]($el, 'mousedown');\n\n    focus($el);\n\n    _emberMetalRun_loop[\"default\"]($el, 'mouseup');\n    _emberMetalRun_loop[\"default\"]($el, 'click');\n\n    return app.testHelpers.wait();\n  }\n\n  function check(app, selector, context) {\n    var $el = app.testHelpers.findWithAssert(selector, context);\n    var type = $el.prop('type');\n\n    _emberMetalCore[\"default\"].assert('To check \\'' + selector + '\\', the input must be a checkbox', type === 'checkbox');\n\n    if (!$el.prop('checked')) {\n      app.testHelpers.click(selector, context);\n    }\n\n    return app.testHelpers.wait();\n  }\n\n  function uncheck(app, selector, context) {\n    var $el = app.testHelpers.findWithAssert(selector, context);\n    var type = $el.prop('type');\n\n    _emberMetalCore[\"default\"].assert('To uncheck \\'' + selector + '\\', the input must be a checkbox', type === 'checkbox');\n\n    if ($el.prop('checked')) {\n      app.testHelpers.click(selector, context);\n    }\n\n    return app.testHelpers.wait();\n  }\n\n  function triggerEvent(app, selector, contextOrType, typeOrOptions, possibleOptions) {\n    var arity = arguments.length;\n    var context, type, options;\n\n    if (arity === 3) {\n      // context and options are optional, so this is\n      // app, selector, type\n      context = null;\n      type = contextOrType;\n      options = {};\n    } else if (arity === 4) {\n      // context and options are optional, so this is\n      if (typeof typeOrOptions === \"object\") {\n        // either\n        // app, selector, type, options\n        context = null;\n        type = contextOrType;\n        options = typeOrOptions;\n      } else {\n        // or\n        // app, selector, context, type\n        context = contextOrType;\n        type = typeOrOptions;\n        options = {};\n      }\n    } else {\n      context = contextOrType;\n      type = typeOrOptions;\n      options = possibleOptions;\n    }\n\n    var $el = app.testHelpers.findWithAssert(selector, context);\n\n    var event = _emberViewsSystemJquery[\"default\"].Event(type, options);\n\n    _emberMetalRun_loop[\"default\"]($el, 'trigger', event);\n\n    return app.testHelpers.wait();\n  }\n\n  function keyEvent(app, selector, contextOrType, typeOrKeyCode, keyCode) {\n    var context, type;\n\n    if (typeof keyCode === 'undefined') {\n      context = null;\n      keyCode = typeOrKeyCode;\n      type = contextOrType;\n    } else {\n      context = contextOrType;\n      type = typeOrKeyCode;\n    }\n\n    return app.testHelpers.triggerEvent(selector, context, type, { keyCode: keyCode, which: keyCode });\n  }\n\n  function fillIn(app, selector, contextOrText, text) {\n    var $el, context;\n    if (typeof text === 'undefined') {\n      text = contextOrText;\n    } else {\n      context = contextOrText;\n    }\n    $el = app.testHelpers.findWithAssert(selector, context);\n    focus($el);\n    _emberMetalRun_loop[\"default\"](function () {\n      $el.val(text).change();\n    });\n    return app.testHelpers.wait();\n  }\n\n  function findWithAssert(app, selector, context) {\n    var $el = app.testHelpers.find(selector, context);\n    if ($el.length === 0) {\n      throw new _emberMetalError[\"default\"](\"Element \" + selector + \" not found.\");\n    }\n    return $el;\n  }\n\n  function find(app, selector, context) {\n    var $el;\n    context = context || _emberMetalProperty_get.get(app, 'rootElement');\n    $el = app.$(selector, context);\n\n    return $el;\n  }\n\n  function andThen(app, callback) {\n    return app.testHelpers.wait(callback(app));\n  }\n\n  function wait(app, value) {\n    return new _emberRuntimeExtRsvp[\"default\"].Promise(function (resolve) {\n      // Every 10ms, poll for the async thing to have finished\n      var watcher = setInterval(function () {\n        var router = app.__container__.lookup('router:main');\n\n        // 1. If the router is loading, keep polling\n        var routerIsLoading = router.router && !!router.router.activeTransition;\n        if (routerIsLoading) {\n          return;\n        }\n\n        // 2. If there are pending Ajax requests, keep polling\n        if (_emberTestingTest[\"default\"].pendingAjaxRequests) {\n          return;\n        }\n\n        // 3. If there are scheduled timers or we are inside of a run loop, keep polling\n        if (_emberMetalRun_loop[\"default\"].hasScheduledTimers() || _emberMetalRun_loop[\"default\"].currentRunLoop) {\n          return;\n        }\n        if (_emberTestingTest[\"default\"].waiters && _emberTestingTest[\"default\"].waiters.any(function (waiter) {\n          var context = waiter[0];\n          var callback = waiter[1];\n          return !callback.call(context);\n        })) {\n          return;\n        }\n        // Stop polling\n        clearInterval(watcher);\n\n        // Synchronously resolve the promise\n        _emberMetalRun_loop[\"default\"](null, resolve, value);\n      }, 10);\n    });\n  }\n\n  /**\n    Loads a route, sets up any controllers, and renders any templates associated\n    with the route as though a real user had triggered the route change while\n    using your app.\n  \n    Example:\n  \n    ```javascript\n    visit('posts/index').then(function() {\n      // assert something\n    });\n    ```\n  \n    @method visit\n    @param {String} url the name of the route\n    @return {RSVP.Promise}\n    @public\n  */\n  asyncHelper('visit', visit);\n\n  /**\n    Clicks an element and triggers any actions triggered by the element's `click`\n    event.\n  \n    Example:\n  \n    ```javascript\n    click('.some-jQuery-selector').then(function() {\n      // assert something\n    });\n    ```\n  \n    @method click\n    @param {String} selector jQuery selector for finding element on the DOM\n    @return {RSVP.Promise}\n    @public\n  */\n  asyncHelper('click', click);\n\n    /**\n    Simulates a key event, e.g. `keypress`, `keydown`, `keyup` with the desired keyCode\n  \n    Example:\n  \n    ```javascript\n    keyEvent('.some-jQuery-selector', 'keypress', 13).then(function() {\n     // assert something\n    });\n    ```\n  \n    @method keyEvent\n    @param {String} selector jQuery selector for finding element on the DOM\n    @param {String} type the type of key event, e.g. `keypress`, `keydown`, `keyup`\n    @param {Number} keyCode the keyCode of the simulated key event\n    @return {RSVP.Promise}\n    @since 1.5.0\n    @public\n  */\n  asyncHelper('keyEvent', keyEvent);\n\n  /**\n    Fills in an input element with some text.\n  \n    Example:\n  \n    ```javascript\n    fillIn('#email', 'you@example.com').then(function() {\n      // assert something\n    });\n    ```\n  \n    @method fillIn\n    @param {String} selector jQuery selector finding an input element on the DOM\n    to fill text with\n    @param {String} text text to place inside the input element\n    @return {RSVP.Promise}\n    @public\n  */\n  asyncHelper('fillIn', fillIn);\n\n  /**\n    Finds an element in the context of the app's container element. A simple alias\n    for `app.$(selector)`.\n  \n    Example:\n  \n    ```javascript\n    var $el = find('.my-selector');\n    ```\n  \n    @method find\n    @param {String} selector jQuery string selector for element lookup\n    @return {Object} jQuery object representing the results of the query\n    @public\n  */\n  helper('find', find);\n\n  /**\n    Like `find`, but throws an error if the element selector returns no results.\n  \n    Example:\n  \n    ```javascript\n    var $el = findWithAssert('.doesnt-exist'); // throws error\n    ```\n  \n    @method findWithAssert\n    @param {String} selector jQuery selector string for finding an element within\n    the DOM\n    @return {Object} jQuery object representing the results of the query\n    @throws {Error} throws error if jQuery object returned has a length of 0\n    @public\n  */\n  helper('findWithAssert', findWithAssert);\n\n  /**\n    Causes the run loop to process any pending events. This is used to ensure that\n    any async operations from other helpers (or your assertions) have been processed.\n  \n    This is most often used as the return value for the helper functions (see 'click',\n    'fillIn','visit',etc).\n  \n    Example:\n  \n    ```javascript\n    Ember.Test.registerAsyncHelper('loginUser', function(app, username, password) {\n      visit('secured/path/here')\n      .fillIn('#username', username)\n      .fillIn('#password', password)\n      .click('.submit')\n  \n      return app.testHelpers.wait();\n    });\n  \n    @method wait\n    @param {Object} value The value to be returned.\n    @return {RSVP.Promise}\n    @public\n  */\n  asyncHelper('wait', wait);\n  asyncHelper('andThen', andThen);\n\n  /**\n    Returns the currently active route name.\n  \n  Example:\n  \n  ```javascript\n  function validateRouteName() {\n    equal(currentRouteName(), 'some.path', \"correct route was transitioned into.\");\n  }\n  \n  visit('/some/path').then(validateRouteName)\n  ```\n  \n  @method currentRouteName\n  @return {Object} The name of the currently active route.\n  @since 1.5.0\n  @public\n  */\n  helper('currentRouteName', currentRouteName);\n\n  /**\n    Returns the current path.\n  \n  Example:\n  \n  ```javascript\n  function validateURL() {\n    equal(currentPath(), 'some.path.index', \"correct path was transitioned into.\");\n  }\n  \n  click('#some-link-id').then(validateURL);\n  ```\n  \n  @method currentPath\n  @return {Object} The currently active path.\n  @since 1.5.0\n  @public\n  */\n  helper('currentPath', currentPath);\n\n  /**\n    Returns the current URL.\n  \n  Example:\n  \n  ```javascript\n  function validateURL() {\n    equal(currentURL(), '/some/path', \"correct URL was transitioned into.\");\n  }\n  \n  click('#some-link-id').then(validateURL);\n  ```\n  \n  @method currentURL\n  @return {Object} The currently active URL.\n  @since 1.5.0\n  @public\n  */\n  helper('currentURL', currentURL);\n\n  /**\n   Pauses the current test - this is useful for debugging while testing or for test-driving.\n   It allows you to inspect the state of your application at any point.\n  \n   Example (The test will pause before clicking the button):\n  \n   ```javascript\n   visit('/')\n   return pauseTest();\n  \n   click('.btn');\n   ```\n  \n   @since 1.9.0\n   @method pauseTest\n   @return {Object} A promise that will never resolve\n   @public\n  */\n  helper('pauseTest', pauseTest);\n\n  /**\n    Triggers the given DOM event on the element identified by the provided selector.\n  \n    Example:\n  \n    ```javascript\n    triggerEvent('#some-elem-id', 'blur');\n    ```\n  \n    This is actually used internally by the `keyEvent` helper like so:\n  \n    ```javascript\n    triggerEvent('#some-elem-id', 'keypress', { keyCode: 13 });\n    ```\n  \n   @method triggerEvent\n   @param {String} selector jQuery selector for finding element on the DOM\n   @param {String} [context] jQuery selector that will limit the selector\n                             argument to find only within the context's children\n   @param {String} type The event type to be triggered.\n   @param {Object} [options] The options to be passed to jQuery.Event.\n   @return {RSVP.Promise}\n   @since 1.5.0\n   @public\n  */\n  asyncHelper('triggerEvent', triggerEvent);\n});\nenifed('ember-testing/initializers', ['exports', 'ember-runtime/system/lazy_load'], function (exports, _emberRuntimeSystemLazy_load) {\n  'use strict';\n\n  var name = 'deferReadiness in `testing` mode';\n\n  _emberRuntimeSystemLazy_load.onLoad('Ember.Application', function (Application) {\n    if (!Application.initializers[name]) {\n      Application.initializer({\n        name: name,\n\n        initialize: function (registry, application) {\n          if (application.testing) {\n            application.deferReadiness();\n          }\n        }\n      });\n    }\n  });\n});\nenifed(\"ember-testing/setup_for_testing\", [\"exports\", \"ember-metal/core\", \"ember-testing/adapters/qunit\", \"ember-views/system/jquery\"], function (exports, _emberMetalCore, _emberTestingAdaptersQunit, _emberViewsSystemJquery) {\n  \"use strict\";\n\n  exports[\"default\"] = setupForTesting;\n\n  var Test, requests;\n\n  function incrementAjaxPendingRequests(_, xhr) {\n    requests.push(xhr);\n    Test.pendingAjaxRequests = requests.length;\n  }\n\n  function decrementAjaxPendingRequests(_, xhr) {\n    for (var i = 0; i < requests.length; i++) {\n      if (xhr === requests[i]) {\n        requests.splice(i, 1);\n      }\n    }\n    Test.pendingAjaxRequests = requests.length;\n  }\n\n  /**\n    Sets Ember up for testing. This is useful to perform\n    basic setup steps in order to unit test.\n  \n    Use `App.setupForTesting` to perform integration tests (full\n    application testing).\n  \n    @method setupForTesting\n    @namespace Ember\n    @since 1.5.0\n    @private\n  */\n\n  function setupForTesting() {\n    if (!Test) {\n      Test = requireModule('ember-testing/test')['default'];\n    }\n\n    _emberMetalCore[\"default\"].testing = true;\n\n    // if adapter is not manually set default to QUnit\n    if (!Test.adapter) {\n      Test.adapter = _emberTestingAdaptersQunit[\"default\"].create();\n    }\n\n    requests = [];\n    Test.pendingAjaxRequests = requests.length;\n\n    _emberViewsSystemJquery[\"default\"](document).off('ajaxSend', incrementAjaxPendingRequests);\n    _emberViewsSystemJquery[\"default\"](document).off('ajaxComplete', decrementAjaxPendingRequests);\n    _emberViewsSystemJquery[\"default\"](document).on('ajaxSend', incrementAjaxPendingRequests);\n    _emberViewsSystemJquery[\"default\"](document).on('ajaxComplete', decrementAjaxPendingRequests);\n  }\n});\n\n// import Test from \"ember-testing/test\";  // ES6TODO: fix when cycles are supported\nenifed(\"ember-testing/support\", [\"exports\", \"ember-metal/core\", \"ember-views/system/jquery\", \"ember-metal/environment\"], function (exports, _emberMetalCore, _emberViewsSystemJquery, _emberMetalEnvironment) {\n  \"use strict\";\n\n  /**\n    @module ember\n    @submodule ember-testing\n  */\n\n  var $ = _emberViewsSystemJquery[\"default\"];\n\n  /**\n    This method creates a checkbox and triggers the click event to fire the\n    passed in handler. It is used to correct for a bug in older versions\n    of jQuery (e.g 1.8.3).\n  \n    @private\n    @method testCheckboxClick\n  */\n  function testCheckboxClick(handler) {\n    $('<input type=\"checkbox\">').css({ position: 'absolute', left: '-1000px', top: '-1000px' }).appendTo('body').on('click', handler).trigger('click').remove();\n  }\n\n  if (_emberMetalEnvironment[\"default\"].hasDOM) {\n    $(function () {\n      /*\n        Determine whether a checkbox checked using jQuery's \"click\" method will have\n        the correct value for its checked property.\n         If we determine that the current jQuery version exhibits this behavior,\n        patch it to work correctly as in the commit for the actual fix:\n        https://github.com/jquery/jquery/commit/1fb2f92.\n      */\n      testCheckboxClick(function () {\n        if (!this.checked && !$.event.special.click) {\n          $.event.special.click = {\n            // For checkbox, fire native event so checked state will be right\n            trigger: function () {\n              if ($.nodeName(this, \"input\") && this.type === \"checkbox\" && this.click) {\n                this.click();\n                return false;\n              }\n            }\n          };\n        }\n      });\n\n      // Try again to verify that the patch took effect or blow up.\n      testCheckboxClick(function () {\n        _emberMetalCore[\"default\"].warn(\"clicked checkboxes should be checked! the jQuery patch didn't work\", this.checked);\n      });\n    });\n  }\n});\nenifed(\"ember-testing/test\", [\"exports\", \"ember-metal/core\", \"ember-metal/run_loop\", \"ember-metal/platform/create\", \"ember-runtime/ext/rsvp\", \"ember-testing/setup_for_testing\", \"ember-application/system/application\"], function (exports, _emberMetalCore, _emberMetalRun_loop, _emberMetalPlatformCreate, _emberRuntimeExtRsvp, _emberTestingSetup_for_testing, _emberApplicationSystemApplication) {\n  \"use strict\";\n\n  /**\n    @module ember\n    @submodule ember-testing\n  */\n  var helpers = {};\n  var injectHelpersCallbacks = [];\n\n  /**\n    This is a container for an assortment of testing related functionality:\n  \n    * Choose your default test adapter (for your framework of choice).\n    * Register/Unregister additional test helpers.\n    * Setup callbacks to be fired when the test helpers are injected into\n      your application.\n  \n    @class Test\n    @namespace Ember\n    @public\n  */\n  var Test = {\n    /**\n      Hash containing all known test helpers.\n       @property _helpers\n      @private\n      @since 1.7.0\n    */\n    _helpers: helpers,\n\n    /**\n      `registerHelper` is used to register a test helper that will be injected\n      when `App.injectTestHelpers` is called.\n       The helper method will always be called with the current Application as\n      the first parameter.\n       For example:\n       ```javascript\n      Ember.Test.registerHelper('boot', function(app) {\n        Ember.run(app, app.advanceReadiness);\n      });\n      ```\n       This helper can later be called without arguments because it will be\n      called with `app` as the first parameter.\n       ```javascript\n      App = Ember.Application.create();\n      App.injectTestHelpers();\n      boot();\n      ```\n       @public\n      @method registerHelper\n      @param {String} name The name of the helper method to add.\n      @param {Function} helperMethod\n      @param options {Object}\n    */\n    registerHelper: function (name, helperMethod) {\n      helpers[name] = {\n        method: helperMethod,\n        meta: { wait: false }\n      };\n    },\n\n    /**\n      `registerAsyncHelper` is used to register an async test helper that will be injected\n      when `App.injectTestHelpers` is called.\n       The helper method will always be called with the current Application as\n      the first parameter.\n       For example:\n       ```javascript\n      Ember.Test.registerAsyncHelper('boot', function(app) {\n        Ember.run(app, app.advanceReadiness);\n      });\n      ```\n       The advantage of an async helper is that it will not run\n      until the last async helper has completed.  All async helpers\n      after it will wait for it complete before running.\n        For example:\n       ```javascript\n      Ember.Test.registerAsyncHelper('deletePost', function(app, postId) {\n        click('.delete-' + postId);\n      });\n       // ... in your test\n      visit('/post/2');\n      deletePost(2);\n      visit('/post/3');\n      deletePost(3);\n      ```\n       @public\n      @method registerAsyncHelper\n      @param {String} name The name of the helper method to add.\n      @param {Function} helperMethod\n      @since 1.2.0\n    */\n    registerAsyncHelper: function (name, helperMethod) {\n      helpers[name] = {\n        method: helperMethod,\n        meta: { wait: true }\n      };\n    },\n\n    /**\n      Remove a previously added helper method.\n       Example:\n       ```javascript\n      Ember.Test.unregisterHelper('wait');\n      ```\n       @public\n      @method unregisterHelper\n      @param {String} name The helper to remove.\n    */\n    unregisterHelper: function (name) {\n      delete helpers[name];\n      delete Test.Promise.prototype[name];\n    },\n\n    /**\n      Used to register callbacks to be fired whenever `App.injectTestHelpers`\n      is called.\n       The callback will receive the current application as an argument.\n       Example:\n       ```javascript\n      Ember.Test.onInjectHelpers(function() {\n        Ember.$(document).ajaxSend(function() {\n          Test.pendingAjaxRequests++;\n        });\n         Ember.$(document).ajaxComplete(function() {\n          Test.pendingAjaxRequests--;\n        });\n      });\n      ```\n       @public\n      @method onInjectHelpers\n      @param {Function} callback The function to be called.\n    */\n    onInjectHelpers: function (callback) {\n      injectHelpersCallbacks.push(callback);\n    },\n\n    /**\n      This returns a thenable tailored for testing.  It catches failed\n      `onSuccess` callbacks and invokes the `Ember.Test.adapter.exception`\n      callback in the last chained then.\n       This method should be returned by async helpers such as `wait`.\n       @public\n      @method promise\n      @param {Function} resolver The function used to resolve the promise.\n      @param {String} label An optional string for identifying the promise.\n    */\n    promise: function (resolver, label) {\n      var fullLabel = \"Ember.Test.promise: \" + (label || \"<Unknown Promise>\");\n      return new Test.Promise(resolver, fullLabel);\n    },\n\n    /**\n     Used to allow ember-testing to communicate with a specific testing\n     framework.\n      You can manually set it before calling `App.setupForTesting()`.\n      Example:\n      ```javascript\n     Ember.Test.adapter = MyCustomAdapter.create()\n     ```\n      If you do not set it, ember-testing will default to `Ember.Test.QUnitAdapter`.\n      @public\n     @property adapter\n     @type {Class} The adapter to be used.\n     @default Ember.Test.QUnitAdapter\n    */\n    adapter: null,\n\n    /**\n      Replacement for `Ember.RSVP.resolve`\n      The only difference is this uses\n      an instance of `Ember.Test.Promise`\n       @public\n      @method resolve\n      @param {Mixed} The value to resolve\n      @since 1.2.0\n    */\n    resolve: function (val) {\n      return Test.promise(function (resolve) {\n        return resolve(val);\n      });\n    },\n\n    /**\n       This allows ember-testing to play nicely with other asynchronous\n       events, such as an application that is waiting for a CSS3\n       transition or an IndexDB transaction.\n        For example:\n        ```javascript\n       Ember.Test.registerWaiter(function() {\n         return myPendingTransactions() == 0;\n       });\n       ```\n       The `context` argument allows you to optionally specify the `this`\n       with which your callback will be invoked.\n        For example:\n        ```javascript\n       Ember.Test.registerWaiter(MyDB, MyDB.hasPendingTransactions);\n       ```\n        @public\n       @method registerWaiter\n       @param {Object} context (optional)\n       @param {Function} callback\n       @since 1.2.0\n    */\n    registerWaiter: function (context, callback) {\n      if (arguments.length === 1) {\n        callback = context;\n        context = null;\n      }\n      if (!this.waiters) {\n        this.waiters = _emberMetalCore[\"default\"].A();\n      }\n      this.waiters.push([context, callback]);\n    },\n    /**\n       `unregisterWaiter` is used to unregister a callback that was\n       registered with `registerWaiter`.\n        @public\n       @method unregisterWaiter\n       @param {Object} context (optional)\n       @param {Function} callback\n       @since 1.2.0\n    */\n    unregisterWaiter: function (context, callback) {\n      if (!this.waiters) {\n        return;\n      }\n      if (arguments.length === 1) {\n        callback = context;\n        context = null;\n      }\n      this.waiters = _emberMetalCore[\"default\"].A(this.waiters.filter(function (elt) {\n        return !(elt[0] === context && elt[1] === callback);\n      }));\n    }\n  };\n\n  function helper(app, name) {\n    var fn = helpers[name].method;\n    var meta = helpers[name].meta;\n\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var lastPromise;\n\n      args.unshift(app);\n\n      // some helpers are not async and\n      // need to return a value immediately.\n      // example: `find`\n      if (!meta.wait) {\n        return fn.apply(app, args);\n      }\n\n      lastPromise = run(function () {\n        return Test.resolve(Test.lastPromise);\n      });\n\n      // wait for last helper's promise to resolve and then\n      // execute. To be safe, we need to tell the adapter we're going\n      // asynchronous here, because fn may not be invoked before we\n      // return.\n      Test.adapter.asyncStart();\n      return lastPromise.then(function () {\n        return fn.apply(app, args);\n      })[\"finally\"](function () {\n        Test.adapter.asyncEnd();\n      });\n    };\n  }\n\n  function run(fn) {\n    if (!_emberMetalRun_loop[\"default\"].currentRunLoop) {\n      return _emberMetalRun_loop[\"default\"](fn);\n    } else {\n      return fn();\n    }\n  }\n\n  _emberApplicationSystemApplication[\"default\"].reopen({\n    /**\n     This property contains the testing helpers for the current application. These\n     are created once you call `injectTestHelpers` on your `Ember.Application`\n     instance. The included helpers are also available on the `window` object by\n     default, but can be used from this object on the individual application also.\n       @property testHelpers\n      @type {Object}\n      @default {}\n      @public\n    */\n    testHelpers: {},\n\n    /**\n     This property will contain the original methods that were registered\n     on the `helperContainer` before `injectTestHelpers` is called.\n      When `removeTestHelpers` is called, these methods are restored to the\n     `helperContainer`.\n       @property originalMethods\n      @type {Object}\n      @default {}\n      @private\n      @since 1.3.0\n    */\n    originalMethods: {},\n\n    /**\n    This property indicates whether or not this application is currently in\n    testing mode. This is set when `setupForTesting` is called on the current\n    application.\n     @property testing\n    @type {Boolean}\n    @default false\n    @since 1.3.0\n    @public\n    */\n    testing: false,\n\n    /**\n      This hook defers the readiness of the application, so that you can start\n      the app when your tests are ready to run. It also sets the router's\n      location to 'none', so that the window's location will not be modified\n      (preventing both accidental leaking of state between tests and interference\n      with your testing framework).\n       Example:\n       ```\n      App.setupForTesting();\n      ```\n       @method setupForTesting\n      @public\n    */\n    setupForTesting: function () {\n      _emberTestingSetup_for_testing[\"default\"]();\n\n      this.testing = true;\n\n      this.Router.reopen({\n        location: 'none'\n      });\n    },\n\n    /**\n      This will be used as the container to inject the test helpers into. By\n      default the helpers are injected into `window`.\n       @property helperContainer\n      @type {Object} The object to be used for test helpers.\n      @default window\n      @since 1.2.0\n      @private\n    */\n    helperContainer: null,\n\n    /**\n      This injects the test helpers into the `helperContainer` object. If an object is provided\n      it will be used as the helperContainer. If `helperContainer` is not set it will default\n      to `window`. If a function of the same name has already been defined it will be cached\n      (so that it can be reset if the helper is removed with `unregisterHelper` or\n      `removeTestHelpers`).\n       Any callbacks registered with `onInjectHelpers` will be called once the\n      helpers have been injected.\n       Example:\n      ```\n      App.injectTestHelpers();\n      ```\n       @method injectTestHelpers\n      @public\n    */\n    injectTestHelpers: function (helperContainer) {\n      if (helperContainer) {\n        this.helperContainer = helperContainer;\n      } else {\n        this.helperContainer = window;\n      }\n\n      this.reopen({\n        willDestroy: function () {\n          this._super.apply(this, arguments);\n          this.removeTestHelpers();\n        }\n      });\n\n      this.testHelpers = {};\n      for (var name in helpers) {\n        this.originalMethods[name] = this.helperContainer[name];\n        this.testHelpers[name] = this.helperContainer[name] = helper(this, name);\n        protoWrap(Test.Promise.prototype, name, helper(this, name), helpers[name].meta.wait);\n      }\n\n      for (var i = 0, l = injectHelpersCallbacks.length; i < l; i++) {\n        injectHelpersCallbacks[i](this);\n      }\n    },\n\n    /**\n      This removes all helpers that have been registered, and resets and functions\n      that were overridden by the helpers.\n       Example:\n       ```javascript\n      App.removeTestHelpers();\n      ```\n       @public\n      @method removeTestHelpers\n    */\n    removeTestHelpers: function () {\n      if (!this.helperContainer) {\n        return;\n      }\n\n      for (var name in helpers) {\n        this.helperContainer[name] = this.originalMethods[name];\n        delete Test.Promise.prototype[name];\n        delete this.testHelpers[name];\n        delete this.originalMethods[name];\n      }\n    }\n  });\n\n  // This method is no longer needed\n  // But still here for backwards compatibility\n  // of helper chaining\n  function protoWrap(proto, name, callback, isAsync) {\n    proto[name] = function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      if (isAsync) {\n        return callback.apply(this, args);\n      } else {\n        return this.then(function () {\n          return callback.apply(this, args);\n        });\n      }\n    };\n  }\n\n  Test.Promise = function () {\n    _emberRuntimeExtRsvp[\"default\"].Promise.apply(this, arguments);\n    Test.lastPromise = this;\n  };\n\n  Test.Promise.prototype = _emberMetalPlatformCreate[\"default\"](_emberRuntimeExtRsvp[\"default\"].Promise.prototype);\n  Test.Promise.prototype.constructor = Test.Promise;\n  Test.Promise.resolve = Test.resolve;\n\n  // Patch `then` to isolate async methods\n  // specifically `Ember.Test.lastPromise`\n  var originalThen = _emberRuntimeExtRsvp[\"default\"].Promise.prototype.then;\n  Test.Promise.prototype.then = function (onSuccess, onFailure) {\n    return originalThen.call(this, function (val) {\n      return isolate(onSuccess, val);\n    }, onFailure);\n  };\n\n  // This method isolates nested async methods\n  // so that they don't conflict with other last promises.\n  //\n  // 1. Set `Ember.Test.lastPromise` to null\n  // 2. Invoke method\n  // 3. Return the last promise created during method\n  function isolate(fn, val) {\n    var value, lastPromise;\n\n    // Reset lastPromise for nested helpers\n    Test.lastPromise = null;\n\n    value = fn(val);\n\n    lastPromise = Test.lastPromise;\n    Test.lastPromise = null;\n\n    // If the method returned a promise\n    // return that promise. If not,\n    // return the last async helper's promise\n    if (value && value instanceof Test.Promise || !lastPromise) {\n      return value;\n    } else {\n      return run(function () {\n        return Test.resolve(lastPromise).then(function () {\n          return value;\n        });\n      });\n    }\n  }\n\n  exports[\"default\"] = Test;\n});\nrequireModule(\"ember-testing\");\n\n})();","/*!\n * QUnit 2.0.1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-07-23T19:39Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = \"qunit-test-string\";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar autorun = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\tdelete a[ prop ];\n\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === \"undefined\" ) {\n\t\treturn \"undefined\";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn \"null\";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase \"Number\":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn \"nan\";\n\t\t\t}\n\t\t\treturn \"number\";\n\t\tcase \"String\":\n\t\tcase \"Boolean\":\n\t\tcase \"Array\":\n\t\tcase \"Set\":\n\t\tcase \"Map\":\n\t\tcase \"Date\":\n\t\tcase \"RegExp\":\n\t\tcase \"Function\":\n\t\tcase \"Symbol\":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === \"object\" ) {\n\t\treturn \"object\";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn't support IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: \"\",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\"moduleStart\", \"moduleDone\" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\n// Expose the current QUnit version\nQUnit.version = \"2.0.1\";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === \"function\" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tif ( testEnvironment && ( testEnvironment.setup || testEnvironment.teardown ) ) {\n\t\t\tconsole.warn(\n\t\t\t\t\"Module's `setup` and `teardown` are not hooks anymore on QUnit 2.0, use \" +\n\t\t\t\t\"`beforeEach` and `afterEach` instead\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t}\n\n\t\tmoduleFns = {\n\t\t\tbefore: setHook( module, \"before\" ),\n\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\tafterEach: setHook( module, \"afterEach\" ),\n\t\t\tafter: setHook( module, \"after\" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === \"function\" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName ),\n\t\t\t\ttestsRun: 0\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\tparentModule.childModule = module;\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( \"Called start() while test already started running\" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"QUnit.start cannot be called inside a test context. This feature is removed in \" +\n\t\t\t\t\"QUnit 2.0. For async tests, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t);\n\t\t}\n\n\t\tscheduleBegin();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true );\n\n\t\tif ( !runStarted ) {\n\t\t\tconfig.blocking = false;\n\n\t\t\tif ( config.autostart ) {\n\t\t\t\tscheduleBegin();\n\t\t\t}\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction scheduleBegin() {\n\n\trunStarted = true;\n\n\t// Add a slight delay to allow definition of more modules and tests.\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( \"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tautorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar unitSampler,\n\tfocused = false,\n\tpriorityCount = 0;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\tthis.expected = null;\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.before;\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t\tdelete this.module.testEnvironment.after;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tinternalRecover( this );\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName, hookOwner ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tif ( hookName === \"before\" ) {\n\t\t\t\tif ( hookOwner.testsRun !== 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttest.preserveEnvironment = true;\n\t\t\t}\n\n\t\t\tif ( hookName === \"after\" && hookOwner.testsRun !== numberOfTests( hookOwner ) - 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler, module ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\"not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tskipped = !!this.skip,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\tnotifyTestsRan( this.module );\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: skipped,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: skipped ? 0 : this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack\n\t\t} );\n\n\t\tconfig.current = undefined;\n\t},\n\n\tpreserveTestEnvironment: function() {\n\t\tif ( this.preserveEnvironment ) {\n\t\t\tthis.module.testEnvironment = this.testEnvironment;\n\t\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\t\t}\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"before\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.preserveTestEnvironment();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"beforeEach\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\t\t\t\ttest.hooks( \"after\" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, resume, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\tresume = internalStop( test );\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { resume(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tresume();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + \": \" + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + \"\\x1C\" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, callback ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, callback ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Put a hold on processing and return a function that will release it.\nfunction internalStop( test ) {\n\tvar released = false;\n\n\ttest.semaphore += 1;\n\tconfig.blocking = true;\n\n\t// Set a recovery timeout, if so configured.\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\tinternalRecover( test );\n\t\t}, config.testTimeout );\n\t}\n\n\treturn function resume() {\n\t\tif ( released ) {\n\t\t\treturn;\n\t\t}\n\n\t\treleased = true;\n\t\ttest.semaphore -= 1;\n\t\tinternalStart( test );\n\t};\n}\n\n// Forcefully release all processing holds.\nfunction internalRecover( test ) {\n\ttest.semaphore = 0;\n\tinternalStart( test );\n}\n\n// Release a processing hold, scheduling a resumption attempt if no holds remain.\nfunction internalStart( test ) {\n\n\t// If semaphore is non-numeric, throw error\n\tif ( isNaN( test.semaphore ) ) {\n\t\ttest.semaphore = 0;\n\n\t\tQUnit.pushFailure(\n\t\t\t\"Invalid value on test.semaphore\",\n\t\t\tsourceFromStacktrace( 2 )\n\t\t);\n\t\treturn;\n\t}\n\n\t// Don't start until equal number of stop-calls\n\tif ( test.semaphore > 0 ) {\n\t\treturn;\n\t}\n\n\t// Throw an Error if start is called more often than stop\n\tif ( test.semaphore < 0 ) {\n\t\ttest.semaphore = 0;\n\n\t\tQUnit.pushFailure(\n\t\t\t\"Tried to restart test while already started (test's semaphore was 0 already)\",\n\t\t\tsourceFromStacktrace( 2 )\n\t\t);\n\t\treturn;\n\t}\n\n\t// Add a slight delay to allow more assertions etc.\n\tif ( defined.setTimeout ) {\n\t\tif ( config.timeout ) {\n\t\t\tclearTimeout( config.timeout );\n\t\t}\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tif ( test.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction numberOfTests( module ) {\n\tvar count = module.tests.length;\n\twhile ( module = module.childModule ) {\n\t\tcount += module.tests.length;\n\t}\n\treturn count;\n}\n\nfunction notifyTestsRan( module ) {\n\tmodule.testsRun++;\n\twhile ( module = module.parentModule ) {\n\t\tmodule.testsRun++;\n\t}\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Put a hold on processing and return a function that will release it a maximum of once.\n\tasync: function( count ) {\n\t\tvar resume,\n\t\t\ttest = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.usedAsync = true;\n\t\tresume = internalStop( test );\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpopped = true;\n\t\t\tresume();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\tif ( message == null ) {\n\t\t\t\tmessage = expected;\n\t\t\t\texpected = null;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"throws/raises does not accept a string value for the expected argument.\\n\" +\n\t\t\t\t\t\"Use a non-string object value (e.g. regExp) instead if it's necessary.\" +\n\t\t\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ \"throws\" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === \"object\" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === \"object\" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn \"flags\" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t\"string\": useStrictEquality,\n\t\t\"boolean\": useStrictEquality,\n\t\t\"number\": useStrictEquality,\n\t\t\"null\": useStrictEquality,\n\t\t\"undefined\": useStrictEquality,\n\t\t\"symbol\": useStrictEquality,\n\t\t\"date\": useStrictEquality,\n\n\t\t\"nan\": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t\"regexp\": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t\"function\": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t},\n\n\t\t\"array\": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t\"set\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"map\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"object\": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b's properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We're done when there's nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn \"[object Array]\";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tfunction isArray( obj ) {\n\t\treturn (\n\n\t\t\t//Native Arrays\n\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\n\t\t\t// NodeList objects\n\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined ) &&\n\t\t\t( obj.length ?\n\t\t\t\tobj.item( 0 ) === obj[ 0 ] :\n\t\t\t\t( obj.item( 0 ) === null && obj[ 0 ] === undefined )\n\t\t\t)\n\t\t);\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if ( isArray( obj ) ) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"(\";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\n\t\t\t\t// Node calls it internally, it's a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal,\n\t\t\t\tsymbol: function( sym ) {\n\t\t\t\t\treturn sym.toString();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: \"  \",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\nfunction applyDeprecated( name ) {\n\treturn function() {\n\t\tthrow new Error(\n\t\t\tname + \" is removed in QUnit 2.0.\\n\" +\n\t\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t\t);\n\t};\n}\n\nObject.keys( Assert.prototype ).forEach( function( key ) {\n\tQUnit[ key ] = applyDeprecated( \"`QUnit.\" + key + \"`\" );\n} );\n\nQUnit.asyncTest = function() {\n\tthrow new Error(\n\t\t\"asyncTest is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nQUnit.stop = function() {\n\tthrow new Error(\n\t\t\"QUnit.stop is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nfunction resetThrower() {\n\tthrow new Error(\n\t\t\"QUnit.reset is removed in QUnit 2.0 without replacement.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n}\n\nObject.defineProperty( QUnit, \"reset\", {\n\tget: function() {\n\t\treturn resetThrower;\n\t},\n\tset: resetThrower\n} );\n\nif ( defined.document ) {\n\tif ( window.QUnit ) {\n\t\tthrow new Error( \"QUnit has already been defined.\" );\n\t}\n\n\t[\n\t\t\"test\",\n\t\t\"module\",\n\t\t\"expect\",\n\t\t\"start\",\n\t\t\"ok\",\n\t\t\"notOk\",\n\t\t\"equal\",\n\t\t\"notEqual\",\n\t\t\"propEqual\",\n\t\t\"notPropEqual\",\n\t\t\"deepEqual\",\n\t\t\"notDeepEqual\",\n\t\t\"strictEqual\",\n\t\t\"notStrictEqual\",\n\t\t\"throws\",\n\t\t\"raises\"\n\t].forEach( function( key ) {\n\t\twindow[ key ] = applyDeprecated( \"The global `\" + key + \"`\" );\n\t} );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== \"undefined\" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== \"undefined\" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\nvar config = QUnit.config,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Stores fixture HTML for resetting later\nfunction storeFixture() {\n\n\t// Avoid overwriting user-defined values\n\tif ( hasOwn.call( config, \"fixture\" ) ) {\n\t\treturn;\n\t}\n\n\tvar fixture = document.getElementById( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nQUnit.begin( storeFixture );\n\n// Resets the fixture DOM element if available.\nfunction resetFixture() {\n\tif ( config.fixture == null ) {\n\t\treturn;\n\t}\n\n\tvar fixture = document.getElementById( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n}\n\nQUnit.testStart( resetFixture );\n\n}() );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== \"undefined\" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against \"moduleName: testName\"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: \"hidepassed\",\n\t\tlabel: \"Hide passed tests\",\n\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"noglobals\",\n\t\tlabel: \"Check for Globals\",\n\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"notrycatch\",\n\t\tlabel: \"No try-catch\",\n\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== \"string\" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( \"&\" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( \"=\" );\n\t\t\tname = decodeQueryParam( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeQueryParam( param.slice( 1 ).join( \"=\" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\nfunction decodeQueryParam( param ) {\n\treturn decodeURIComponent( param.replace( /\\+/g, \"%20\" ) );\n}\n\n// Don't load the HTML Reporter on non-browser environments\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\nQUnit.init = function() {\n\tthrow new Error(\n\t\t\"QUnit.init is removed in QUnit 2.0, use QUnit.test() with assert.async() instead.\\n\" +\n\t\t\"Details in our upgrade guide at https://qunitjs.com/upgrade-guide-2.x/\"\n\t);\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n// Escape text for attribute or text content.\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase \"'\":\n\t\t\treturn \"&#039;\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"&quot;\";\n\t\tcase \"<\":\n\t\t\treturn \"&lt;\";\n\t\tcase \">\":\n\t\t\treturn \"&gt;\";\n\t\tcase \"&\":\n\t\t\treturn \"&amp;\";\n\t\t}\n\t} );\n}\n\nfunction addEvent( elem, type, fn ) {\n\telem.addEventListener( type, fn, false );\n}\n\nfunction removeEvent( elem, type, fn ) {\n\telem.removeEventListener( type, fn, false );\n}\n\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === \"undefined\" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction interceptNavigation( ev ) {\n\tapplyUrlParams();\n\n\tif ( ev && ev.preventDefault ) {\n\t\tev.preventDefault();\n\t}\n\n\treturn false;\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = \"\";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'><input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapedTooltip + \"' />\" + escapeText( val.label ) + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( \"selectedIndex\" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( \"qunit-tests\" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, \"hidepass\", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = \"?\",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += \"=\" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += \"&\";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + \"//\" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar i,\n\t\tselectedModules = [],\n\t\tmodulesList = id( \"qunit-modulefilter-dropdown-list\" ).getElementsByTagName( \"input\" ),\n\t\tfilter = id( \"qunit-filter-input\" ).value;\n\n\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\tif ( modulesList[ i ].checked ) {\n\t\t\tselectedModules.push( modulesList[ i ].value );\n\t\t}\n\t}\n\n\twindow.location = setUrl( {\n\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\t\tmoduleId: ( selectedModules.length === 0 ) ? undefined : selectedModules,\n\n\t\t// Remove module and testId filter\n\t\tmodule: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( \"span\" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\n\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"change\", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tinput = document.createElement( \"input\" ),\n\t\tbutton = document.createElement( \"button\" );\n\n\taddClass( filter, \"qunit-filter\" );\n\n\tlabel.innerHTML = \"Filter: \";\n\n\tinput.type = \"text\";\n\tinput.value = config.filter || \"\";\n\tinput.name = \"filter\";\n\tinput.id = \"qunit-filter-input\";\n\n\tbutton.innerHTML = \"Go\";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( document.createTextNode( \" \" ) );\n\tfilter.appendChild( button );\n\taddEvent( filter, \"submit\", interceptNavigation );\n\n\treturn filter;\n}\n\nfunction moduleListHtml () {\n\tvar i, checked,\n\t\thtml = \"\";\n\n\tfor ( i = 0; i < config.modules.length; i++ ) {\n\t\tif ( config.modules[ i ].name !== \"\" ) {\n\t\t\tchecked = config.moduleId.indexOf( config.modules[ i ].moduleId ) > -1;\n\t\t\thtml += \"<li><label class='clickable\" + ( checked ? \" checked\" : \"\" ) +\n\t\t\t\t\"'><input type='checkbox' \" + \"value='\" + config.modules[ i ].moduleId + \"'\" +\n\t\t\t\t( checked ? \" checked='checked'\" : \"\" ) + \" />\" +\n\t\t\t\tescapeText( config.modules[ i ].name ) + \"</label></li>\";\n\t\t}\n\t}\n\n\treturn html;\n}\n\nfunction toolbarModuleFilter () {\n\tvar allCheckbox, commit, reset,\n\t\tmoduleFilter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tmoduleSearch = document.createElement( \"input\" ),\n\t\tdropDown = document.createElement( \"div\" ),\n\t\tactions = document.createElement( \"span\" ),\n\t\tdropDownList = document.createElement( \"ul\" ),\n\t\tdirty = false;\n\n\tmoduleSearch.id = \"qunit-modulefilter-search\";\n\taddEvent( moduleSearch, \"input\", searchInput );\n\taddEvent( moduleSearch, \"input\", searchFocus );\n\taddEvent( moduleSearch, \"focus\", searchFocus );\n\taddEvent( moduleSearch, \"click\", searchFocus );\n\n\tlabel.id = \"qunit-modulefilter-search-container\";\n\tlabel.innerHTML = \"Module: \";\n\tlabel.appendChild( moduleSearch );\n\n\tactions.id = \"qunit-modulefilter-actions\";\n\tactions.innerHTML =\n\t\t\"<button style='display:none'>Apply</button>\" +\n\t\t\"<button type='reset' style='display:none'>Reset</button>\" +\n\t\t\"<label class='clickable\" +\n\t\t( config.moduleId.length ? \"\" : \" checked\" ) +\n\t\t\"'><input type='checkbox'\" + ( config.moduleId.length ? \"\" : \" checked='checked'\" ) +\n\t\t\">All modules</label>\";\n\tallCheckbox = actions.lastChild.firstChild;\n\tcommit = actions.firstChild;\n\treset = commit.nextSibling;\n\taddEvent( commit, \"click\", applyUrlParams );\n\n\tdropDownList.id = \"qunit-modulefilter-dropdown-list\";\n\tdropDownList.innerHTML = moduleListHtml();\n\n\tdropDown.id = \"qunit-modulefilter-dropdown\";\n\tdropDown.style.display = \"none\";\n\tdropDown.appendChild( actions );\n\tdropDown.appendChild( dropDownList );\n\taddEvent( dropDown, \"change\", selectionChange );\n\tselectionChange();\n\n\tmoduleFilter.id = \"qunit-modulefilter\";\n\tmoduleFilter.appendChild( label );\n\tmoduleFilter.appendChild( dropDown ) ;\n\taddEvent( moduleFilter, \"submit\", interceptNavigation );\n\taddEvent( moduleFilter, \"reset\", function() {\n\n\t\t// Let the reset happen, then update styles\n\t\twindow.setTimeout( selectionChange );\n\t} );\n\n\t// Enables show/hide for the dropdown\n\tfunction searchFocus() {\n\t\tif ( dropDown.style.display !== \"none\" ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdropDown.style.display = \"block\";\n\t\taddEvent( document, \"click\", hideHandler );\n\t\taddEvent( document, \"keydown\", hideHandler );\n\n\t\t// Hide on Escape keydown or outside-container click\n\t\tfunction hideHandler( e )  {\n\t\t\tvar inContainer = moduleFilter.contains( e.target );\n\n\t\t\tif ( e.keyCode === 27 || !inContainer ) {\n\t\t\t\tif ( e.keyCode === 27 && inContainer ) {\n\t\t\t\t\tmoduleSearch.focus();\n\t\t\t\t}\n\t\t\t\tdropDown.style.display = \"none\";\n\t\t\t\tremoveEvent( document, \"click\", hideHandler );\n\t\t\t\tremoveEvent( document, \"keydown\", hideHandler );\n\t\t\t\tmoduleSearch.value = \"\";\n\t\t\t\tsearchInput();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Processes module search box input\n\tfunction searchInput() {\n\t\tvar i, item,\n\t\t\tsearchText = moduleSearch.value.toLowerCase(),\n\t\t\tlistItems = dropDownList.children;\n\n\t\tfor ( i = 0; i < listItems.length; i++ ) {\n\t\t\titem = listItems[ i ];\n\t\t\tif ( !searchText || item.textContent.toLowerCase().indexOf( searchText ) > -1 ) {\n\t\t\t\titem.style.display = \"\";\n\t\t\t} else {\n\t\t\t\titem.style.display = \"none\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Processes selection changes\n\tfunction selectionChange( evt ) {\n\t\tvar i, item,\n\t\t\tcheckbox = evt && evt.target || allCheckbox,\n\t\t\tmodulesList = dropDownList.getElementsByTagName( \"input\" ),\n\t\t\tselectedNames = [];\n\n\t\ttoggleClass( checkbox.parentNode, \"checked\", checkbox.checked );\n\n\t\tdirty = false;\n\t\tif ( checkbox.checked && checkbox !== allCheckbox ) {\n\t\t   allCheckbox.checked = false;\n\t\t   removeClass( allCheckbox.parentNode, \"checked\" );\n\t\t}\n\t\tfor ( i = 0; i < modulesList.length; i++ )  {\n\t\t\titem = modulesList[ i ];\n\t\t\tif ( !evt ) {\n\t\t\t\ttoggleClass( item.parentNode, \"checked\", item.checked );\n\t\t\t} else if ( checkbox === allCheckbox && checkbox.checked ) {\n\t\t\t\titem.checked = false;\n\t\t\t\tremoveClass( item.parentNode, \"checked\" );\n\t\t\t}\n\t\t\tdirty = dirty || ( item.checked !== item.defaultChecked );\n\t\t\tif ( item.checked ) {\n\t\t\t\tselectedNames.push( item.parentNode.textContent );\n\t\t\t}\n\t\t}\n\n\t\tcommit.style.display = reset.style.display = dirty ? \"\" : \"none\";\n\t\tmoduleSearch.placeholder = selectedNames.join( \", \" ) || allCheckbox.parentNode.textContent;\n\t\tmoduleSearch.title = \"Type to filter list. Current selection:\\n\" +\n\t\t\t( selectedNames.join( \"\\n\" ) || allCheckbox.parentNode.textContent );\n\t}\n\n\treturn moduleFilter;\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarModuleFilter() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbar.appendChild( document.createElement( \"div\" ) ).className = \"clearfix\";\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( \"qunit-header\" );\n\n\tif ( header ) {\n\t\theader.innerHTML = \"<a href='\" + escapeText( unfilteredUrl ) + \"'>\" + header.innerHTML +\n\t\t\t\"</a> \";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( \"qunit-banner\" );\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( \"qunit-tests\" ),\n\t\tresult = id( \"qunit-testresult\" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn \"\";\n\t}\n\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" +\n\t\tescapeText( testId.join( \", \" ) ) +\n\t\t\" <a id='qunit-clearFilter' href='\" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t\"'>Run all tests</a></div>\";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( \"qunit-userAgent\" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = \"\";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( \"qunit\" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\tappendFilteredTest() +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( \"strong\" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( \"a\" );\n\trerunTrigger.innerHTML = \"Rerun\";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( \"li\" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = \"qunit-test-output-\" + testId;\n\n\tassertList = document.createElement( \"ol\" );\n\tassertList.className = \"qunit-assert-list\";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( \"qunit-tests\" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, \"hidepass\" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\tdetails.runtime,\n\t\t\t\" milliseconds.<br />\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tdetails.passed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tdetails.total,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tdetails.failed,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show ✖ for good, ✔ for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = \"\";\n\n\tif ( module ) {\n\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t}\n\n\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = \"running\";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( \"qunit-testresult\" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\"Running: <br />\" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, \"\" ).replace( /\\&quot;/g, \"\" ).replace( /\\s+/g, \"\" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\n\t// The pushFailure doesn't provide details.expected\n\t// when it calls, it's implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = \"NOT \" + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\tescapeText( expected ) +\n\t\t\t\"</pre></td></tr>\";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\tescapeText( actual ) + \"</pre></td></tr>\";\n\n\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t}\n\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\" run with a higher max depth or <a href='\" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + \"'>\" +\n\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t} else {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the expected and actual results have an equivalent\" +\n\t\t\t\t\" serialization</td></tr>\";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tmessage += \"</table>\";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += \"<table>\" +\n\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\"</table>\";\n\t}\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tassertLi = document.createElement( \"li\" );\n\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\"\";\n\n\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\tdetails.assertions.length + \")</b>\";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = \"skipped\";\n\t\tskipped = document.createElement( \"em\" );\n\t\tskipped.className = \"qunit-skipped-label\";\n\t\tskipped.innerHTML = \"skipped\";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t} );\n\n\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\t\ttime = document.createElement( \"span\" );\n\t\ttime.className = \"runtime\";\n\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( \"p\" );\n\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\taddClass( sourceName, \"qunit-source\" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t}\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === \"complete\" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, \"load\", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = \"<ins>\" + escapeText( data ) + \"</ins>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = \"<del>\" + escapeText( data ) + \"</del>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = \"<span>\" + escapeText( data ) + \"</span>\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( \"\" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {};  // E.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = \"\";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n","QUnit.notifications = function( options ) {\n  \"use strict\";\n\n  options         = options         || {};\n  options.icons   = options.icons   || {};\n  options.timeout = options.timeout || 4000;\n  options.titles  = options.titles  || { passed: \"Passed!\", failed: \"Failed!\" };\n  options.bodies  = options.bodies  || {\n    passed: \"{{passed}} of {{total}} passed\",\n    failed: \"{{passed}} passed. {{failed}} failed.\"\n  };\n\n  var renderBody = function( body, details ) {\n    [ \"passed\", \"failed\", \"total\", \"runtime\" ].forEach( function( type ) {\n      body = body.replace( \"{{\" + type + \"}}\", details[ type ] );\n    } );\n\n    return body;\n  };\n\n  function generateQueryString( params ) {\n    var key,\n      querystring = \"?\";\n\n    params = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n    for ( key in params ) {\n      if ( params.hasOwnProperty( key ) ) {\n        if ( params[ key ] === undefined ) {\n          continue;\n        }\n        querystring += encodeURIComponent( key );\n        if ( params[ key ] !== true ) {\n          querystring += \"=\" + encodeURIComponent( params[ key ] );\n        }\n        querystring += \"&\";\n      }\n    }\n    return location.protocol + \"//\" + location.host +\n      location.pathname + querystring.slice( 0, -1 );\n  }\n\n  if ( window.Notification ) {\n    QUnit.done( function( details ) {\n      var title,\n          _options = {},\n          notification;\n\n      if ( window.Notification && QUnit.urlParams.notifications ) {\n        if ( details.failed === 0 ) {\n          title = options.titles.passed;\n          _options.body = renderBody( options.bodies.passed, details );\n\n          if ( options.icons.passed ) {\n            _options.icon = options.icons.passed;\n          }\n        } else {\n          title = options.titles.failed;\n          _options.body = renderBody( options.bodies.failed, details );\n\n          if ( options.icons.failed ) {\n            _options.icon = options.icons.failed;\n          }\n        }\n\n        notification = new window.Notification( title, _options );\n\n        setTimeout( function() {\n          notification.close();\n        }, options.timeout );\n      }\n    } );\n\n    QUnit.begin( function() {\n      var toolbar      = document.getElementById( \"qunit-testrunner-toolbar\" );\n      if ( !toolbar ) { return; }\n\n      var notification = document.createElement( \"input\" ),\n          label        = document.createElement( \"label\" ),\n          disableCheckbox = function() {\n            notification.checked = false;\n            notification.disabled = true;\n            label.style.opacity = 0.5;\n            label.title = notification.title = \"Note: Notifications have been \" +\n              \"disabled in this browser.\";\n          };\n\n      notification.type = \"checkbox\";\n      notification.id   = \"qunit-notifications\";\n\n      label.innerHTML = \"Notifications\";\n      label.for = \"qunit-notifications\";\n      label.title = \"Show notifications.\";\n      if ( window.Notification.permission === \"denied\" ) {\n        disableCheckbox();\n      } else if ( QUnit.urlParams.notifications ) {\n        notification.checked = true;\n      }\n\n      notification.addEventListener( \"click\", function( event ) {\n        if ( event.target.checked ) {\n          if ( window.Notification.permission === \"granted\" ) {\n            window.location = generateQueryString( { notifications: true } );\n          } else if ( window.Notification.permission === \"denied\" ) {\n            disableCheckbox();\n          } else {\n            window.Notification.requestPermission( function( permission ) {\n              if ( permission === \"denied\" ) {\n                disableCheckbox();\n              } else {\n                window.location = generateQueryString( { notifications: true } );\n              }\n            } );\n          }\n        } else {\n          window.location = generateQueryString( { notifications: undefined } );\n        }\n      }, false );\n\n      toolbar.appendChild( notification );\n      toolbar.appendChild( label );\n   } );\n  }\n};\n","/* globals jQuery, QUnit */\n\n(function() {\n  QUnit.config.urlConfig.push({ id: 'nocontainer', label: 'Hide container'});\n  QUnit.config.urlConfig.push({ id: 'nolint', label: 'Disable Linting'});\n  QUnit.config.urlConfig.push({ id: 'dockcontainer', label: 'Dock container'});\n  QUnit.config.urlConfig.push({ id: 'devmode', label: 'Development mode' });\n\n  QUnit.config.testTimeout = QUnit.urlParams.devmode ? null : 60000; //Default Test Timeout 60 Seconds\n\n  if (QUnit.notifications) {\n    QUnit.notifications({\n      icons: {\n        passed: '/assets/passed.png',\n        failed: '/assets/failed.png'\n      }\n    });\n  }\n\n  function ready(fn) {\n    if (typeof jQuery === 'function') {\n      jQuery(document).ready(fn);\n      return;\n    }\n\n    if (document.readyState != 'loading'){\n      fn();\n    } else {\n      document.addEventListener('DOMContentLoaded', fn);\n    }\n  }\n\n  ready(function() {\n    var testContainer = document.getElementById('ember-testing-container');\n    if (!testContainer) { return; }\n\n    var params = QUnit.urlParams;\n\n    var containerVisibility = params.nocontainer ? 'hidden' : 'visible';\n    var containerPosition = (params.dockcontainer || params.devmode) ? 'absolute' : 'relative';\n\n    if (params.devmode) {\n      testContainer.className = ' full-screen';\n    }\n\n    testContainer.style.visibility = containerVisibility;\n    testContainer.style.position = containerPosition;\n  });\n})();\n","/* globals jQuery, QUnit, require, requirejs */\n\n(function() {\n  function ready(fn) {\n    if (typeof jQuery === 'function') {\n      jQuery(document).ready(fn);\n      return;\n    }\n\n    if (document.readyState != 'loading'){\n      fn();\n    } else {\n      document.addEventListener('DOMContentLoaded', fn);\n    }\n  }\n\n  ready(function() {\n    var QUnitAdapter = require('ember-qunit').QUnitAdapter;\n    Ember.Test.adapter = QUnitAdapter.create();\n\n    var testLoaderModulePath = 'ember-cli-test-loader/test-support/index';\n\n    if (!requirejs.entries[testLoaderModulePath]) {\n      testLoaderModulePath = 'ember-cli/test-loader';\n    }\n\n    var TestLoaderModule = require(testLoaderModulePath);\n    var TestLoader = TestLoaderModule['default'];\n    var addModuleExcludeMatcher = TestLoaderModule['addModuleExcludeMatcher'];\n    var addModuleIncludeMatcher = TestLoaderModule['addModuleIncludeMatcher'];\n\n    function excludeModule(moduleName) {\n      return QUnit.urlParams.nolint &&\n        moduleName.match(/\\.(jshint|lint-test)$/);\n    }\n\n    function includeModule(moduleName) {\n      return moduleName.match(/\\.jshint$/);\n    }\n\n    if (addModuleExcludeMatcher && addModuleIncludeMatcher) {\n      addModuleExcludeMatcher(excludeModule);\n      addModuleIncludeMatcher(includeModule);\n    } else {\n      TestLoader.prototype.shouldLoadModule = function shouldLoadModule(moduleName) {\n        return (moduleName.match(/[-_]test$/) || includeModule(moduleName)) && !excludeModule(moduleName);\n      };\n    }\n\n    var moduleLoadFailures = [];\n\n    TestLoader.prototype.moduleLoadFailure = function(moduleName, error) {\n      moduleLoadFailures.push(error);\n\n      QUnit.module('TestLoader Failures');\n      QUnit.test(moduleName + ': could not be loaded', function() {\n        throw error;\n      });\n    };\n\n    QUnit.done(function() {\n      if (moduleLoadFailures.length) {\n        throw new Error('\\n' + moduleLoadFailures.join('\\n'));\n      }\n    });\n\n    var autostart = QUnit.config.autostart !== false;\n    QUnit.config.autostart = false;\n\n    setTimeout(function() {\n      TestLoader.load();\n\n      if (autostart) {\n        QUnit.start();\n      }\n    }, 250);\n  });\n\n})();\n","/**\n * Sinon.JS 1.17.5, 2016/07/26\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @author Contributors: https://github.com/cjohansen/Sinon.JS/blob/master/AUTHORS\n *\n * (The BSD License)\n * \n * Copyright (c) 2010-2014, Christian Johansen, christian@cjohansen.no\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *     * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n *     * Neither the name of Christian Johansen nor the names of his contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function (root, factory) {\n  'use strict';\n  if (typeof define === 'function' && define.amd) {\n    define('sinon', [], function () {\n      return (root.sinon = factory());\n    });\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.sinon = factory();\n  }\n}(this, function () {\n  'use strict';\n  var samsam, formatio, lolex;\n  (function () {\n                function define(mod, deps, fn) {\n                  if (mod == \"samsam\") {\n                    samsam = deps();\n                  } else if (typeof deps === \"function\" && mod.length === 0) {\n                    lolex = deps();\n                  } else if (typeof fn === \"function\") {\n                    formatio = fn(samsam);\n                  }\n                }\n    define.amd = {};\n((typeof define === \"function\" && define.amd && function (m) { define(\"samsam\", m); }) ||\n (typeof module === \"object\" &&\n      function (m) { module.exports = m(); }) || // Node\n function (m) { this.samsam = m(); } // Browser globals\n)(function () {\n    var o = Object.prototype;\n    var div = typeof document !== \"undefined\" && document.createElement(\"div\");\n\n    function isNaN(value) {\n        // Unlike global isNaN, this avoids type coercion\n        // typeof check avoids IE host object issues, hat tip to\n        // lodash\n        var val = value; // JsLint thinks value !== value is \"weird\"\n        return typeof value === \"number\" && value !== val;\n    }\n\n    function getClass(value) {\n        // Returns the internal [[Class]] by calling Object.prototype.toString\n        // with the provided value as this. Return value is a string, naming the\n        // internal class, e.g. \"Array\"\n        return o.toString.call(value).split(/[ \\]]/)[1];\n    }\n\n    /**\n     * @name samsam.isArguments\n     * @param Object object\n     *\n     * Returns ``true`` if ``object`` is an ``arguments`` object,\n     * ``false`` otherwise.\n     */\n    function isArguments(object) {\n        if (getClass(object) === 'Arguments') { return true; }\n        if (typeof object !== \"object\" || typeof object.length !== \"number\" ||\n                getClass(object) === \"Array\") {\n            return false;\n        }\n        if (typeof object.callee == \"function\") { return true; }\n        try {\n            object[object.length] = 6;\n            delete object[object.length];\n        } catch (e) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @name samsam.isElement\n     * @param Object object\n     *\n     * Returns ``true`` if ``object`` is a DOM element node. Unlike\n     * Underscore.js/lodash, this function will return ``false`` if ``object``\n     * is an *element-like* object, i.e. a regular object with a ``nodeType``\n     * property that holds the value ``1``.\n     */\n    function isElement(object) {\n        if (!object || object.nodeType !== 1 || !div) { return false; }\n        try {\n            object.appendChild(div);\n            object.removeChild(div);\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @name samsam.keys\n     * @param Object object\n     *\n     * Return an array of own property names.\n     */\n    function keys(object) {\n        var ks = [], prop;\n        for (prop in object) {\n            if (o.hasOwnProperty.call(object, prop)) { ks.push(prop); }\n        }\n        return ks;\n    }\n\n    /**\n     * @name samsam.isDate\n     * @param Object value\n     *\n     * Returns true if the object is a ``Date``, or *date-like*. Duck typing\n     * of date objects work by checking that the object has a ``getTime``\n     * function whose return value equals the return value from the object's\n     * ``valueOf``.\n     */\n    function isDate(value) {\n        return typeof value.getTime == \"function\" &&\n            value.getTime() == value.valueOf();\n    }\n\n    /**\n     * @name samsam.isNegZero\n     * @param Object value\n     *\n     * Returns ``true`` if ``value`` is ``-0``.\n     */\n    function isNegZero(value) {\n        return value === 0 && 1 / value === -Infinity;\n    }\n\n    /**\n     * @name samsam.equal\n     * @param Object obj1\n     * @param Object obj2\n     *\n     * Returns ``true`` if two objects are strictly equal. Compared to\n     * ``===`` there are two exceptions:\n     *\n     *   - NaN is considered equal to NaN\n     *   - -0 and +0 are not considered equal\n     */\n    function identical(obj1, obj2) {\n        if (obj1 === obj2 || (isNaN(obj1) && isNaN(obj2))) {\n            return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);\n        }\n    }\n\n\n    /**\n     * @name samsam.deepEqual\n     * @param Object obj1\n     * @param Object obj2\n     *\n     * Deep equal comparison. Two values are \"deep equal\" if:\n     *\n     *   - They are equal, according to samsam.identical\n     *   - They are both date objects representing the same time\n     *   - They are both arrays containing elements that are all deepEqual\n     *   - They are objects with the same set of properties, and each property\n     *     in ``obj1`` is deepEqual to the corresponding property in ``obj2``\n     *\n     * Supports cyclic objects.\n     */\n    function deepEqualCyclic(obj1, obj2) {\n\n        // used for cyclic comparison\n        // contain already visited objects\n        var objects1 = [],\n            objects2 = [],\n        // contain pathes (position in the object structure)\n        // of the already visited objects\n        // indexes same as in objects arrays\n            paths1 = [],\n            paths2 = [],\n        // contains combinations of already compared objects\n        // in the manner: { \"$1['ref']$2['ref']\": true }\n            compared = {};\n\n        /**\n         * used to check, if the value of a property is an object\n         * (cyclic logic is only needed for objects)\n         * only needed for cyclic logic\n         */\n        function isObject(value) {\n\n            if (typeof value === 'object' && value !== null &&\n                    !(value instanceof Boolean) &&\n                    !(value instanceof Date)    &&\n                    !(value instanceof Number)  &&\n                    !(value instanceof RegExp)  &&\n                    !(value instanceof String)) {\n\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * returns the index of the given object in the\n         * given objects array, -1 if not contained\n         * only needed for cyclic logic\n         */\n        function getIndex(objects, obj) {\n\n            var i;\n            for (i = 0; i < objects.length; i++) {\n                if (objects[i] === obj) {\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n\n        // does the recursion for the deep equal check\n        return (function deepEqual(obj1, obj2, path1, path2) {\n            var type1 = typeof obj1;\n            var type2 = typeof obj2;\n\n            // == null also matches undefined\n            if (obj1 === obj2 ||\n                    isNaN(obj1) || isNaN(obj2) ||\n                    obj1 == null || obj2 == null ||\n                    type1 !== \"object\" || type2 !== \"object\") {\n\n                return identical(obj1, obj2);\n            }\n\n            // Elements are only equal if identical(expected, actual)\n            if (isElement(obj1) || isElement(obj2)) { return false; }\n\n            var isDate1 = isDate(obj1), isDate2 = isDate(obj2);\n            if (isDate1 || isDate2) {\n                if (!isDate1 || !isDate2 || obj1.getTime() !== obj2.getTime()) {\n                    return false;\n                }\n            }\n\n            if (obj1 instanceof RegExp && obj2 instanceof RegExp) {\n                if (obj1.toString() !== obj2.toString()) { return false; }\n            }\n\n            var class1 = getClass(obj1);\n            var class2 = getClass(obj2);\n            var keys1 = keys(obj1);\n            var keys2 = keys(obj2);\n\n            if (isArguments(obj1) || isArguments(obj2)) {\n                if (obj1.length !== obj2.length) { return false; }\n            } else {\n                if (type1 !== type2 || class1 !== class2 ||\n                        keys1.length !== keys2.length) {\n                    return false;\n                }\n            }\n\n            var key, i, l,\n                // following vars are used for the cyclic logic\n                value1, value2,\n                isObject1, isObject2,\n                index1, index2,\n                newPath1, newPath2;\n\n            for (i = 0, l = keys1.length; i < l; i++) {\n                key = keys1[i];\n                if (!o.hasOwnProperty.call(obj2, key)) {\n                    return false;\n                }\n\n                // Start of the cyclic logic\n\n                value1 = obj1[key];\n                value2 = obj2[key];\n\n                isObject1 = isObject(value1);\n                isObject2 = isObject(value2);\n\n                // determine, if the objects were already visited\n                // (it's faster to check for isObject first, than to\n                // get -1 from getIndex for non objects)\n                index1 = isObject1 ? getIndex(objects1, value1) : -1;\n                index2 = isObject2 ? getIndex(objects2, value2) : -1;\n\n                // determine the new pathes of the objects\n                // - for non cyclic objects the current path will be extended\n                //   by current property name\n                // - for cyclic objects the stored path is taken\n                newPath1 = index1 !== -1\n                    ? paths1[index1]\n                    : path1 + '[' + JSON.stringify(key) + ']';\n                newPath2 = index2 !== -1\n                    ? paths2[index2]\n                    : path2 + '[' + JSON.stringify(key) + ']';\n\n                // stop recursion if current objects are already compared\n                if (compared[newPath1 + newPath2]) {\n                    return true;\n                }\n\n                // remember the current objects and their pathes\n                if (index1 === -1 && isObject1) {\n                    objects1.push(value1);\n                    paths1.push(newPath1);\n                }\n                if (index2 === -1 && isObject2) {\n                    objects2.push(value2);\n                    paths2.push(newPath2);\n                }\n\n                // remember that the current objects are already compared\n                if (isObject1 && isObject2) {\n                    compared[newPath1 + newPath2] = true;\n                }\n\n                // End of cyclic logic\n\n                // neither value1 nor value2 is a cycle\n                // continue with next level\n                if (!deepEqual(value1, value2, newPath1, newPath2)) {\n                    return false;\n                }\n            }\n\n            return true;\n\n        }(obj1, obj2, '$1', '$2'));\n    }\n\n    var match;\n\n    function arrayContains(array, subset) {\n        if (subset.length === 0) { return true; }\n        var i, l, j, k;\n        for (i = 0, l = array.length; i < l; ++i) {\n            if (match(array[i], subset[0])) {\n                for (j = 0, k = subset.length; j < k; ++j) {\n                    if (!match(array[i + j], subset[j])) { return false; }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @name samsam.match\n     * @param Object object\n     * @param Object matcher\n     *\n     * Compare arbitrary value ``object`` with matcher.\n     */\n    match = function match(object, matcher) {\n        if (matcher && typeof matcher.test === \"function\") {\n            return matcher.test(object);\n        }\n\n        if (typeof matcher === \"function\") {\n            return matcher(object) === true;\n        }\n\n        if (typeof matcher === \"string\") {\n            matcher = matcher.toLowerCase();\n            var notNull = typeof object === \"string\" || !!object;\n            return notNull &&\n                (String(object)).toLowerCase().indexOf(matcher) >= 0;\n        }\n\n        if (typeof matcher === \"number\") {\n            return matcher === object;\n        }\n\n        if (typeof matcher === \"boolean\") {\n            return matcher === object;\n        }\n\n        if (typeof(matcher) === \"undefined\") {\n            return typeof(object) === \"undefined\";\n        }\n\n        if (matcher === null) {\n            return object === null;\n        }\n\n        if (getClass(object) === \"Array\" && getClass(matcher) === \"Array\") {\n            return arrayContains(object, matcher);\n        }\n\n        if (matcher && typeof matcher === \"object\") {\n            if (matcher === object) {\n                return true;\n            }\n            var prop;\n            for (prop in matcher) {\n                var value = object[prop];\n                if (typeof value === \"undefined\" &&\n                        typeof object.getAttribute === \"function\") {\n                    value = object.getAttribute(prop);\n                }\n                if (matcher[prop] === null || typeof matcher[prop] === 'undefined') {\n                    if (value !== matcher[prop]) {\n                        return false;\n                    }\n                } else if (typeof  value === \"undefined\" || !match(value, matcher[prop])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        throw new Error(\"Matcher was not a string, a number, a \" +\n                        \"function, a boolean or an object\");\n    };\n\n    return {\n        isArguments: isArguments,\n        isElement: isElement,\n        isDate: isDate,\n        isNegZero: isNegZero,\n        identical: identical,\n        deepEqual: deepEqualCyclic,\n        match: match,\n        keys: keys\n    };\n});\n((typeof define === \"function\" && define.amd && function (m) {\n    define(\"formatio\", [\"samsam\"], m);\n}) || (typeof module === \"object\" && function (m) {\n    module.exports = m(require(\"samsam\"));\n}) || function (m) { this.formatio = m(this.samsam); }\n)(function (samsam) {\n    \n    var formatio = {\n        excludeConstructors: [\"Object\", /^.$/],\n        quoteStrings: true,\n        limitChildrenCount: 0\n    };\n\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    var specialObjects = [];\n    if (typeof global !== \"undefined\") {\n        specialObjects.push({ object: global, value: \"[object global]\" });\n    }\n    if (typeof document !== \"undefined\") {\n        specialObjects.push({\n            object: document,\n            value: \"[object HTMLDocument]\"\n        });\n    }\n    if (typeof window !== \"undefined\") {\n        specialObjects.push({ object: window, value: \"[object Window]\" });\n    }\n\n    function functionName(func) {\n        if (!func) { return \"\"; }\n        if (func.displayName) { return func.displayName; }\n        if (func.name) { return func.name; }\n        var matches = func.toString().match(/function\\s+([^\\(]+)/m);\n        return (matches && matches[1]) || \"\";\n    }\n\n    function constructorName(f, object) {\n        var name = functionName(object && object.constructor);\n        var excludes = f.excludeConstructors ||\n                formatio.excludeConstructors || [];\n\n        var i, l;\n        for (i = 0, l = excludes.length; i < l; ++i) {\n            if (typeof excludes[i] === \"string\" && excludes[i] === name) {\n                return \"\";\n            } else if (excludes[i].test && excludes[i].test(name)) {\n                return \"\";\n            }\n        }\n\n        return name;\n    }\n\n    function isCircular(object, objects) {\n        if (typeof object !== \"object\") { return false; }\n        var i, l;\n        for (i = 0, l = objects.length; i < l; ++i) {\n            if (objects[i] === object) { return true; }\n        }\n        return false;\n    }\n\n    function ascii(f, object, processed, indent) {\n        if (typeof object === \"string\") {\n            var qs = f.quoteStrings;\n            var quote = typeof qs !== \"boolean\" || qs;\n            return processed || quote ? '\"' + object + '\"' : object;\n        }\n\n        if (typeof object === \"function\" && !(object instanceof RegExp)) {\n            return ascii.func(object);\n        }\n\n        processed = processed || [];\n\n        if (isCircular(object, processed)) { return \"[Circular]\"; }\n\n        if (Object.prototype.toString.call(object) === \"[object Array]\") {\n            return ascii.array.call(f, object, processed);\n        }\n\n        if (!object) { return String((1/object) === -Infinity ? \"-0\" : object); }\n        if (samsam.isElement(object)) { return ascii.element(object); }\n\n        if (typeof object.toString === \"function\" &&\n                object.toString !== Object.prototype.toString) {\n            return object.toString();\n        }\n\n        var i, l;\n        for (i = 0, l = specialObjects.length; i < l; i++) {\n            if (object === specialObjects[i].object) {\n                return specialObjects[i].value;\n            }\n        }\n\n        return ascii.object.call(f, object, processed, indent);\n    }\n\n    ascii.func = function (func) {\n        return \"function \" + functionName(func) + \"() {}\";\n    };\n\n    ascii.array = function (array, processed) {\n        processed = processed || [];\n        processed.push(array);\n        var pieces = [];\n        var i, l;\n        l = (this.limitChildrenCount > 0) ? \n            Math.min(this.limitChildrenCount, array.length) : array.length;\n\n        for (i = 0; i < l; ++i) {\n            pieces.push(ascii(this, array[i], processed));\n        }\n\n        if(l < array.length)\n            pieces.push(\"[... \" + (array.length - l) + \" more elements]\");\n\n        return \"[\" + pieces.join(\", \") + \"]\";\n    };\n\n    ascii.object = function (object, processed, indent) {\n        processed = processed || [];\n        processed.push(object);\n        indent = indent || 0;\n        var pieces = [], properties = samsam.keys(object).sort();\n        var length = 3;\n        var prop, str, obj, i, k, l;\n        l = (this.limitChildrenCount > 0) ? \n            Math.min(this.limitChildrenCount, properties.length) : properties.length;\n\n        for (i = 0; i < l; ++i) {\n            prop = properties[i];\n            obj = object[prop];\n\n            if (isCircular(obj, processed)) {\n                str = \"[Circular]\";\n            } else {\n                str = ascii(this, obj, processed, indent + 2);\n            }\n\n            str = (/\\s/.test(prop) ? '\"' + prop + '\"' : prop) + \": \" + str;\n            length += str.length;\n            pieces.push(str);\n        }\n\n        var cons = constructorName(this, object);\n        var prefix = cons ? \"[\" + cons + \"] \" : \"\";\n        var is = \"\";\n        for (i = 0, k = indent; i < k; ++i) { is += \" \"; }\n\n        if(l < properties.length)\n            pieces.push(\"[... \" + (properties.length - l) + \" more elements]\");\n\n        if (length + indent > 80) {\n            return prefix + \"{\\n  \" + is + pieces.join(\",\\n  \" + is) + \"\\n\" +\n                is + \"}\";\n        }\n        return prefix + \"{ \" + pieces.join(\", \") + \" }\";\n    };\n\n    ascii.element = function (element) {\n        var tagName = element.tagName.toLowerCase();\n        var attrs = element.attributes, attr, pairs = [], attrName, i, l, val;\n\n        for (i = 0, l = attrs.length; i < l; ++i) {\n            attr = attrs.item(i);\n            attrName = attr.nodeName.toLowerCase().replace(\"html:\", \"\");\n            val = attr.nodeValue;\n            if (attrName !== \"contenteditable\" || val !== \"inherit\") {\n                if (!!val) { pairs.push(attrName + \"=\\\"\" + val + \"\\\"\"); }\n            }\n        }\n\n        var formatted = \"<\" + tagName + (pairs.length > 0 ? \" \" : \"\");\n        var content = element.innerHTML;\n\n        if (content.length > 20) {\n            content = content.substr(0, 20) + \"[...]\";\n        }\n\n        var res = formatted + pairs.join(\" \") + \">\" + content +\n                \"</\" + tagName + \">\";\n\n        return res.replace(/ contentEditable=\"inherit\"/, \"\");\n    };\n\n    function Formatio(options) {\n        for (var opt in options) {\n            this[opt] = options[opt];\n        }\n    }\n\n    Formatio.prototype = {\n        functionName: functionName,\n\n        configure: function (options) {\n            return new Formatio(options);\n        },\n\n        constructorName: function (object) {\n            return constructorName(this, object);\n        },\n\n        ascii: function (object, processed, indent) {\n            return ascii(this, object, processed, indent);\n        }\n    };\n\n    return Formatio.prototype;\n});\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.lolex=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\n/*global global, window*/\n/**\n * @author Christian Johansen (christian@cjohansen.no) and contributors\n * @license BSD\n *\n * Copyright (c) 2010-2014 Christian Johansen\n */\n\n(function (global) {\n    \n    // Make properties writable in IE, as per\n    // http://www.adequatelygood.com/Replacing-setTimeout-Globally.html\n    // JSLint being anal\n    var glbl = global;\n\n    global.setTimeout = glbl.setTimeout;\n    global.clearTimeout = glbl.clearTimeout;\n    global.setInterval = glbl.setInterval;\n    global.clearInterval = glbl.clearInterval;\n    global.Date = glbl.Date;\n\n    // setImmediate is not a standard function\n    // avoid adding the prop to the window object if not present\n    if('setImmediate' in global) {\n        global.setImmediate = glbl.setImmediate;\n        global.clearImmediate = glbl.clearImmediate;\n    }\n\n    // node expects setTimeout/setInterval to return a fn object w/ .ref()/.unref()\n    // browsers, a number.\n    // see https://github.com/cjohansen/Sinon.JS/pull/436\n\n    var NOOP = function () { return undefined; };\n    var timeoutResult = setTimeout(NOOP, 0);\n    var addTimerReturnsObject = typeof timeoutResult === \"object\";\n    clearTimeout(timeoutResult);\n\n    var NativeDate = Date;\n    var uniqueTimerId = 1;\n\n    /**\n     * Parse strings like \"01:10:00\" (meaning 1 hour, 10 minutes, 0 seconds) into\n     * number of milliseconds. This is used to support human-readable strings passed\n     * to clock.tick()\n     */\n    function parseTime(str) {\n        if (!str) {\n            return 0;\n        }\n\n        var strings = str.split(\":\");\n        var l = strings.length, i = l;\n        var ms = 0, parsed;\n\n        if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n            throw new Error(\"tick only understands numbers and 'h:m:s'\");\n        }\n\n        while (i--) {\n            parsed = parseInt(strings[i], 10);\n\n            if (parsed >= 60) {\n                throw new Error(\"Invalid time \" + str);\n            }\n\n            ms += parsed * Math.pow(60, (l - i - 1));\n        }\n\n        return ms * 1000;\n    }\n\n    /**\n     * Used to grok the `now` parameter to createClock.\n     */\n    function getEpoch(epoch) {\n        if (!epoch) { return 0; }\n        if (typeof epoch.getTime === \"function\") { return epoch.getTime(); }\n        if (typeof epoch === \"number\") { return epoch; }\n        throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n    }\n\n    function inRange(from, to, timer) {\n        return timer && timer.callAt >= from && timer.callAt <= to;\n    }\n\n    function mirrorDateProperties(target, source) {\n        var prop;\n        for (prop in source) {\n            if (source.hasOwnProperty(prop)) {\n                target[prop] = source[prop];\n            }\n        }\n\n        // set special now implementation\n        if (source.now) {\n            target.now = function now() {\n                return target.clock.now;\n            };\n        } else {\n            delete target.now;\n        }\n\n        // set special toSource implementation\n        if (source.toSource) {\n            target.toSource = function toSource() {\n                return source.toSource();\n            };\n        } else {\n            delete target.toSource;\n        }\n\n        // set special toString implementation\n        target.toString = function toString() {\n            return source.toString();\n        };\n\n        target.prototype = source.prototype;\n        target.parse = source.parse;\n        target.UTC = source.UTC;\n        target.prototype.toUTCString = source.prototype.toUTCString;\n\n        return target;\n    }\n\n    function createDate() {\n        function ClockDate(year, month, date, hour, minute, second, ms) {\n            // Defensive and verbose to avoid potential harm in passing\n            // explicit undefined when user does not pass argument\n            switch (arguments.length) {\n            case 0:\n                return new NativeDate(ClockDate.clock.now);\n            case 1:\n                return new NativeDate(year);\n            case 2:\n                return new NativeDate(year, month);\n            case 3:\n                return new NativeDate(year, month, date);\n            case 4:\n                return new NativeDate(year, month, date, hour);\n            case 5:\n                return new NativeDate(year, month, date, hour, minute);\n            case 6:\n                return new NativeDate(year, month, date, hour, minute, second);\n            default:\n                return new NativeDate(year, month, date, hour, minute, second, ms);\n            }\n        }\n\n        return mirrorDateProperties(ClockDate, NativeDate);\n    }\n\n    function addTimer(clock, timer) {\n        if (timer.func === undefined) {\n            throw new Error(\"Callback must be provided to timer calls\");\n        }\n\n        if (!clock.timers) {\n            clock.timers = {};\n        }\n\n        timer.id = uniqueTimerId++;\n        timer.createdAt = clock.now;\n        timer.callAt = clock.now + (timer.delay || (clock.duringTick ? 1 : 0));\n\n        clock.timers[timer.id] = timer;\n\n        if (addTimerReturnsObject) {\n            return {\n                id: timer.id,\n                ref: NOOP,\n                unref: NOOP\n            };\n        }\n\n        return timer.id;\n    }\n\n\n    function compareTimers(a, b) {\n        // Sort first by absolute timing\n        if (a.callAt < b.callAt) {\n            return -1;\n        }\n        if (a.callAt > b.callAt) {\n            return 1;\n        }\n\n        // Sort next by immediate, immediate timers take precedence\n        if (a.immediate && !b.immediate) {\n            return -1;\n        }\n        if (!a.immediate && b.immediate) {\n            return 1;\n        }\n\n        // Sort next by creation time, earlier-created timers take precedence\n        if (a.createdAt < b.createdAt) {\n            return -1;\n        }\n        if (a.createdAt > b.createdAt) {\n            return 1;\n        }\n\n        // Sort next by id, lower-id timers take precedence\n        if (a.id < b.id) {\n            return -1;\n        }\n        if (a.id > b.id) {\n            return 1;\n        }\n\n        // As timer ids are unique, no fallback `0` is necessary\n    }\n\n    function firstTimerInRange(clock, from, to) {\n        var timers = clock.timers,\n            timer = null,\n            id,\n            isInRange;\n\n        for (id in timers) {\n            if (timers.hasOwnProperty(id)) {\n                isInRange = inRange(from, to, timers[id]);\n\n                if (isInRange && (!timer || compareTimers(timer, timers[id]) === 1)) {\n                    timer = timers[id];\n                }\n            }\n        }\n\n        return timer;\n    }\n\n    function callTimer(clock, timer) {\n        var exception;\n\n        if (typeof timer.interval === \"number\") {\n            clock.timers[timer.id].callAt += timer.interval;\n        } else {\n            delete clock.timers[timer.id];\n        }\n\n        try {\n            if (typeof timer.func === \"function\") {\n                timer.func.apply(null, timer.args);\n            } else {\n                eval(timer.func);\n            }\n        } catch (e) {\n            exception = e;\n        }\n\n        if (!clock.timers[timer.id]) {\n            if (exception) {\n                throw exception;\n            }\n            return;\n        }\n\n        if (exception) {\n            throw exception;\n        }\n    }\n\n    function timerType(timer) {\n        if (timer.immediate) {\n            return \"Immediate\";\n        } else if (typeof timer.interval !== \"undefined\") {\n            return \"Interval\";\n        } else {\n            return \"Timeout\";\n        }\n    }\n\n    function clearTimer(clock, timerId, ttype) {\n        if (!timerId) {\n            // null appears to be allowed in most browsers, and appears to be\n            // relied upon by some libraries, like Bootstrap carousel\n            return;\n        }\n\n        if (!clock.timers) {\n            clock.timers = [];\n        }\n\n        // in Node, timerId is an object with .ref()/.unref(), and\n        // its .id field is the actual timer id.\n        if (typeof timerId === \"object\") {\n            timerId = timerId.id;\n        }\n\n        if (clock.timers.hasOwnProperty(timerId)) {\n            // check that the ID matches a timer of the correct type\n            var timer = clock.timers[timerId];\n            if (timerType(timer) === ttype) {\n                delete clock.timers[timerId];\n            } else {\n\t\t\t\tthrow new Error(\"Cannot clear timer: timer created with set\" + ttype + \"() but cleared with clear\" + timerType(timer) + \"()\");\n\t\t\t}\n        }\n    }\n\n    function uninstall(clock, target) {\n        var method,\n            i,\n            l;\n\n        for (i = 0, l = clock.methods.length; i < l; i++) {\n            method = clock.methods[i];\n\n            if (target[method].hadOwnProperty) {\n                target[method] = clock[\"_\" + method];\n            } else {\n                try {\n                    delete target[method];\n                } catch (ignore) {}\n            }\n        }\n\n        // Prevent multiple executions which will completely remove these props\n        clock.methods = [];\n    }\n\n    function hijackMethod(target, method, clock) {\n        var prop;\n\n        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);\n        clock[\"_\" + method] = target[method];\n\n        if (method === \"Date\") {\n            var date = mirrorDateProperties(clock[method], target[method]);\n            target[method] = date;\n        } else {\n            target[method] = function () {\n                return clock[method].apply(clock, arguments);\n            };\n\n            for (prop in clock[method]) {\n                if (clock[method].hasOwnProperty(prop)) {\n                    target[method][prop] = clock[method][prop];\n                }\n            }\n        }\n\n        target[method].clock = clock;\n    }\n\n    var timers = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout,\n        setImmediate: global.setImmediate,\n        clearImmediate: global.clearImmediate,\n        setInterval: setInterval,\n        clearInterval: clearInterval,\n        Date: Date\n    };\n\n    var keys = Object.keys || function (obj) {\n        var ks = [],\n            key;\n\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ks.push(key);\n            }\n        }\n\n        return ks;\n    };\n\n    exports.timers = timers;\n\n    function createClock(now) {\n        var clock = {\n            now: getEpoch(now),\n            timeouts: {},\n            Date: createDate()\n        };\n\n        clock.Date.clock = clock;\n\n        clock.setTimeout = function setTimeout(func, timeout) {\n            return addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 2),\n                delay: timeout\n            });\n        };\n\n        clock.clearTimeout = function clearTimeout(timerId) {\n            return clearTimer(clock, timerId, \"Timeout\");\n        };\n\n        clock.setInterval = function setInterval(func, timeout) {\n            return addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 2),\n                delay: timeout,\n                interval: timeout\n            });\n        };\n\n        clock.clearInterval = function clearInterval(timerId) {\n            return clearTimer(clock, timerId, \"Interval\");\n        };\n\n        clock.setImmediate = function setImmediate(func) {\n            return addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 1),\n                immediate: true\n            });\n        };\n\n        clock.clearImmediate = function clearImmediate(timerId) {\n            return clearTimer(clock, timerId, \"Immediate\");\n        };\n\n        clock.tick = function tick(ms) {\n            ms = typeof ms === \"number\" ? ms : parseTime(ms);\n            var tickFrom = clock.now, tickTo = clock.now + ms, previous = clock.now;\n            var timer = firstTimerInRange(clock, tickFrom, tickTo);\n            var oldNow;\n\n            clock.duringTick = true;\n\n            var firstException;\n            while (timer && tickFrom <= tickTo) {\n                if (clock.timers[timer.id]) {\n                    tickFrom = clock.now = timer.callAt;\n                    try {\n                        oldNow = clock.now;\n                        callTimer(clock, timer);\n                        // compensate for any setSystemTime() call during timer callback\n                        if (oldNow !== clock.now) {\n                            tickFrom += clock.now - oldNow;\n                            tickTo += clock.now - oldNow;\n                            previous += clock.now - oldNow;\n                        }\n                    } catch (e) {\n                        firstException = firstException || e;\n                    }\n                }\n\n                timer = firstTimerInRange(clock, previous, tickTo);\n                previous = tickFrom;\n            }\n\n            clock.duringTick = false;\n            clock.now = tickTo;\n\n            if (firstException) {\n                throw firstException;\n            }\n\n            return clock.now;\n        };\n\n        clock.reset = function reset() {\n            clock.timers = {};\n        };\n\n        clock.setSystemTime = function setSystemTime(now) {\n            // determine time difference\n            var newNow = getEpoch(now);\n            var difference = newNow - clock.now;\n\n            // update 'system clock'\n            clock.now = newNow;\n\n            // update timers and intervals to keep them stable\n            for (var id in clock.timers) {\n                if (clock.timers.hasOwnProperty(id)) {\n                    var timer = clock.timers[id];\n                    timer.createdAt += difference;\n                    timer.callAt += difference;\n                }\n            }\n        };\n\n        return clock;\n    }\n    exports.createClock = createClock;\n\n    exports.install = function install(target, now, toFake) {\n        var i,\n            l;\n\n        if (typeof target === \"number\") {\n            toFake = now;\n            now = target;\n            target = null;\n        }\n\n        if (!target) {\n            target = global;\n        }\n\n        var clock = createClock(now);\n\n        clock.uninstall = function () {\n            uninstall(clock, target);\n        };\n\n        clock.methods = toFake || [];\n\n        if (clock.methods.length === 0) {\n            clock.methods = keys(timers);\n        }\n\n        for (i = 0, l = clock.methods.length; i < l; i++) {\n            hijackMethod(target, clock.methods[i], clock);\n        }\n\n        return clock;\n    };\n\n}(global || this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}]},{},[1])(1)\n});\n  })();\n  var define;\n/**\n * Sinon core utilities. For internal use only.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\nvar sinon = (function () {\n\"use strict\";\n // eslint-disable-line no-unused-vars\n    \n    var sinonModule;\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        sinonModule = module.exports = require(\"./sinon/util/core\");\n        require(\"./sinon/extend\");\n        require(\"./sinon/walk\");\n        require(\"./sinon/typeOf\");\n        require(\"./sinon/times_in_words\");\n        require(\"./sinon/spy\");\n        require(\"./sinon/call\");\n        require(\"./sinon/behavior\");\n        require(\"./sinon/stub\");\n        require(\"./sinon/mock\");\n        require(\"./sinon/collection\");\n        require(\"./sinon/assert\");\n        require(\"./sinon/sandbox\");\n        require(\"./sinon/test\");\n        require(\"./sinon/test_case\");\n        require(\"./sinon/match\");\n        require(\"./sinon/format\");\n        require(\"./sinon/log_error\");\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n    } else if (isNode) {\n        loadDependencies(require, module.exports, module);\n        sinonModule = module.exports;\n    } else {\n        sinonModule = {};\n    }\n\n    return sinonModule;\n}());\n\n/**\n * @depend ../../sinon.js\n */\n/**\n * Sinon core utilities. For internal use only.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    var div = typeof document !== \"undefined\" && document.createElement(\"div\");\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    function isDOMNode(obj) {\n        var success = false;\n\n        try {\n            obj.appendChild(div);\n            success = div.parentNode === obj;\n        } catch (e) {\n            return false;\n        } finally {\n            try {\n                obj.removeChild(div);\n            } catch (e) {\n                // Remove failed, not much we can do about that\n            }\n        }\n\n        return success;\n    }\n\n    function isElement(obj) {\n        return div && obj && obj.nodeType === 1 && isDOMNode(obj);\n    }\n\n    function isFunction(obj) {\n        return typeof obj === \"function\" || !!(obj && obj.constructor && obj.call && obj.apply);\n    }\n\n    function isReallyNaN(val) {\n        return typeof val === \"number\" && isNaN(val);\n    }\n\n    function mirrorProperties(target, source) {\n        for (var prop in source) {\n            if (!hasOwn.call(target, prop)) {\n                target[prop] = source[prop];\n            }\n        }\n    }\n\n    function isRestorable(obj) {\n        return typeof obj === \"function\" && typeof obj.restore === \"function\" && obj.restore.sinon;\n    }\n\n    // Cheap way to detect if we have ES5 support.\n    var hasES5Support = \"keys\" in Object;\n\n    function makeApi(sinon) {\n        sinon.wrapMethod = function wrapMethod(object, property, method) {\n            if (!object) {\n                throw new TypeError(\"Should wrap property of object\");\n            }\n\n            if (typeof method !== \"function\" && typeof method !== \"object\") {\n                throw new TypeError(\"Method wrapper should be a function or a property descriptor\");\n            }\n\n            function checkWrappedMethod(wrappedMethod) {\n                var error;\n\n                if (!isFunction(wrappedMethod)) {\n                    error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                        property + \" as function\");\n                } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n                    error = new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n                } else if (wrappedMethod.calledBefore) {\n                    var verb = wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n                    error = new TypeError(\"Attempted to wrap \" + property + \" which is already \" + verb);\n                }\n\n                if (error) {\n                    if (wrappedMethod && wrappedMethod.stackTrace) {\n                        error.stack += \"\\n--------------\\n\" + wrappedMethod.stackTrace;\n                    }\n                    throw error;\n                }\n            }\n\n            var error, wrappedMethod, i;\n\n            // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem\n            // when using hasOwn.call on objects from other frames.\n            var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);\n\n            if (hasES5Support) {\n                var methodDesc = (typeof method === \"function\") ? {value: method} : method;\n                var wrappedMethodDesc = sinon.getPropertyDescriptor(object, property);\n\n                if (!wrappedMethodDesc) {\n                    error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                        property + \" as function\");\n                } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {\n                    error = new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n                }\n                if (error) {\n                    if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {\n                        error.stack += \"\\n--------------\\n\" + wrappedMethodDesc.stackTrace;\n                    }\n                    throw error;\n                }\n\n                var types = sinon.objectKeys(methodDesc);\n                for (i = 0; i < types.length; i++) {\n                    wrappedMethod = wrappedMethodDesc[types[i]];\n                    checkWrappedMethod(wrappedMethod);\n                }\n\n                mirrorProperties(methodDesc, wrappedMethodDesc);\n                for (i = 0; i < types.length; i++) {\n                    mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n                }\n                Object.defineProperty(object, property, methodDesc);\n            } else {\n                wrappedMethod = object[property];\n                checkWrappedMethod(wrappedMethod);\n                object[property] = method;\n                method.displayName = property;\n            }\n\n            method.displayName = property;\n\n            // Set up a stack trace which can be used later to find what line of\n            // code the original method was created on.\n            method.stackTrace = (new Error(\"Stack Trace for original\")).stack;\n\n            method.restore = function () {\n                // For prototype properties try to reset by delete first.\n                // If this fails (ex: localStorage on mobile safari) then force a reset\n                // via direct assignment.\n                if (!owned) {\n                    // In some cases `delete` may throw an error\n                    try {\n                        delete object[property];\n                    } catch (e) {} // eslint-disable-line no-empty\n                    // For native code functions `delete` fails without throwing an error\n                    // on Chrome < 43, PhantomJS, etc.\n                } else if (hasES5Support) {\n                    Object.defineProperty(object, property, wrappedMethodDesc);\n                }\n\n                // Use strict equality comparison to check failures then force a reset\n                // via direct assignment.\n                if (object[property] === method) {\n                    object[property] = wrappedMethod;\n                }\n            };\n\n            method.restore.sinon = true;\n\n            if (!hasES5Support) {\n                mirrorProperties(method, wrappedMethod);\n            }\n\n            return method;\n        };\n\n        sinon.create = function create(proto) {\n            var F = function () {};\n            F.prototype = proto;\n            return new F();\n        };\n\n        sinon.deepEqual = function deepEqual(a, b) {\n            if (sinon.match && sinon.match.isMatcher(a)) {\n                return a.test(b);\n            }\n\n            if (typeof a !== \"object\" || typeof b !== \"object\") {\n                return isReallyNaN(a) && isReallyNaN(b) || a === b;\n            }\n\n            if (isElement(a) || isElement(b)) {\n                return a === b;\n            }\n\n            if (a === b) {\n                return true;\n            }\n\n            if ((a === null && b !== null) || (a !== null && b === null)) {\n                return false;\n            }\n\n            if (a instanceof RegExp && b instanceof RegExp) {\n                return (a.source === b.source) && (a.global === b.global) &&\n                    (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);\n            }\n\n            var aString = Object.prototype.toString.call(a);\n            if (aString !== Object.prototype.toString.call(b)) {\n                return false;\n            }\n\n            if (aString === \"[object Date]\") {\n                return a.valueOf() === b.valueOf();\n            }\n\n            var prop;\n            var aLength = 0;\n            var bLength = 0;\n\n            if (aString === \"[object Array]\" && a.length !== b.length) {\n                return false;\n            }\n\n            for (prop in a) {\n                if (hasOwn.call(a, prop)) {\n                    aLength += 1;\n\n                    if (!(prop in b)) {\n                        return false;\n                    }\n\n                    if (!deepEqual(a[prop], b[prop])) {\n                        return false;\n                    }\n                }\n            }\n\n            for (prop in b) {\n                if (hasOwn.call(b, prop)) {\n                    bLength += 1;\n                }\n            }\n\n            return aLength === bLength;\n        };\n\n        sinon.functionName = function functionName(func) {\n            var name = func.displayName || func.name;\n\n            // Use function decomposition as a last resort to get function\n            // name. Does not rely on function decomposition to work - if it\n            // doesn't debugging will be slightly less informative\n            // (i.e. toString will say 'spy' rather than 'myFunc').\n            if (!name) {\n                var matches = func.toString().match(/function ([^\\s\\(]+)/);\n                name = matches && matches[1];\n            }\n\n            return name;\n        };\n\n        sinon.functionToString = function toString() {\n            if (this.getCall && this.callCount) {\n                var thisValue,\n                    prop;\n                var i = this.callCount;\n\n                while (i--) {\n                    thisValue = this.getCall(i).thisValue;\n\n                    for (prop in thisValue) {\n                        if (thisValue[prop] === this) {\n                            return prop;\n                        }\n                    }\n                }\n            }\n\n            return this.displayName || \"sinon fake\";\n        };\n\n        sinon.objectKeys = function objectKeys(obj) {\n            if (obj !== Object(obj)) {\n                throw new TypeError(\"sinon.objectKeys called on a non-object\");\n            }\n\n            var keys = [];\n            var key;\n            for (key in obj) {\n                if (hasOwn.call(obj, key)) {\n                    keys.push(key);\n                }\n            }\n\n            return keys;\n        };\n\n        sinon.getPropertyDescriptor = function getPropertyDescriptor(object, property) {\n            var proto = object;\n            var descriptor;\n\n            while (proto && !(descriptor = Object.getOwnPropertyDescriptor(proto, property))) {\n                proto = Object.getPrototypeOf(proto);\n            }\n            return descriptor;\n        };\n\n        sinon.getConfig = function (custom) {\n            var config = {};\n            custom = custom || {};\n            var defaults = sinon.defaultConfig;\n\n            for (var prop in defaults) {\n                if (defaults.hasOwnProperty(prop)) {\n                    config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];\n                }\n            }\n\n            return config;\n        };\n\n        sinon.defaultConfig = {\n            injectIntoThis: true,\n            injectInto: null,\n            properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n            useFakeTimers: true,\n            useFakeServer: true\n        };\n\n        sinon.timesInWords = function timesInWords(count) {\n            return count === 1 && \"once\" ||\n                count === 2 && \"twice\" ||\n                count === 3 && \"thrice\" ||\n                (count || 0) + \" times\";\n        };\n\n        sinon.calledInOrder = function (spies) {\n            for (var i = 1, l = spies.length; i < l; i++) {\n                if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {\n                    return false;\n                }\n            }\n\n            return true;\n        };\n\n        sinon.orderByFirstCall = function (spies) {\n            return spies.sort(function (a, b) {\n                // uuid, won't ever be equal\n                var aCall = a.getCall(0);\n                var bCall = b.getCall(0);\n                var aId = aCall && aCall.callId || -1;\n                var bId = bCall && bCall.callId || -1;\n\n                return aId < bId ? -1 : 1;\n            });\n        };\n\n        sinon.createStubInstance = function (constructor) {\n            if (typeof constructor !== \"function\") {\n                throw new TypeError(\"The constructor should be a function.\");\n            }\n            return sinon.stub(sinon.create(constructor.prototype));\n        };\n\n        sinon.restore = function (object) {\n            if (object !== null && typeof object === \"object\") {\n                for (var prop in object) {\n                    if (isRestorable(object[prop])) {\n                        object[prop].restore();\n                    }\n                }\n            } else if (isRestorable(object)) {\n                object.restore();\n            }\n        };\n\n        return sinon;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports) {\n        makeApi(exports);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n\n        // Adapted from https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\n        var hasDontEnumBug = (function () {\n            var obj = {\n                constructor: function () {\n                    return \"0\";\n                },\n                toString: function () {\n                    return \"1\";\n                },\n                valueOf: function () {\n                    return \"2\";\n                },\n                toLocaleString: function () {\n                    return \"3\";\n                },\n                prototype: function () {\n                    return \"4\";\n                },\n                isPrototypeOf: function () {\n                    return \"5\";\n                },\n                propertyIsEnumerable: function () {\n                    return \"6\";\n                },\n                hasOwnProperty: function () {\n                    return \"7\";\n                },\n                length: function () {\n                    return \"8\";\n                },\n                unique: function () {\n                    return \"9\";\n                }\n            };\n\n            var result = [];\n            for (var prop in obj) {\n                if (obj.hasOwnProperty(prop)) {\n                    result.push(obj[prop]());\n                }\n            }\n            return result.join(\"\") !== \"0123456789\";\n        })();\n\n        /* Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will\n         *         override properties in previous sources.\n         *\n         * target - The Object to extend\n         * sources - Objects to copy properties from.\n         *\n         * Returns the extended target\n         */\n        function extend(target /*, sources */) {\n            var sources = Array.prototype.slice.call(arguments, 1);\n            var source, i, prop;\n\n            for (i = 0; i < sources.length; i++) {\n                source = sources[i];\n\n                for (prop in source) {\n                    if (source.hasOwnProperty(prop)) {\n                        target[prop] = source[prop];\n                    }\n                }\n\n                // Make sure we copy (own) toString method even when in JScript with DontEnum bug\n                // See https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\n                if (hasDontEnumBug && source.hasOwnProperty(\"toString\") && source.toString !== target.toString) {\n                    target.toString = source.toString;\n                }\n            }\n\n            return target;\n        }\n\n        sinon.extend = extend;\n        return sinon.extend;\n    }\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        module.exports = makeApi(sinon);\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n\n        function timesInWords(count) {\n            switch (count) {\n                case 1:\n                    return \"once\";\n                case 2:\n                    return \"twice\";\n                case 3:\n                    return \"thrice\";\n                default:\n                    return (count || 0) + \" times\";\n            }\n        }\n\n        sinon.timesInWords = timesInWords;\n        return sinon.timesInWords;\n    }\n\n    function loadDependencies(require, exports, module) {\n        var core = require(\"./util/core\");\n        module.exports = makeApi(core);\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n */\n/**\n * Format functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2014 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n        function typeOf(value) {\n            if (value === null) {\n                return \"null\";\n            } else if (value === undefined) {\n                return \"undefined\";\n            }\n            var string = Object.prototype.toString.call(value);\n            return string.substring(8, string.length - 1).toLowerCase();\n        }\n\n        sinon.typeOf = typeOf;\n        return sinon.typeOf;\n    }\n\n    function loadDependencies(require, exports, module) {\n        var core = require(\"./util/core\");\n        module.exports = makeApi(core);\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n * @depend typeOf.js\n */\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\n/*global module, require, sinon*/\n/**\n * Match functions\n *\n * @author Maximilian Antoni (mail@maxantoni.de)\n * @license BSD\n *\n * Copyright (c) 2012 Maximilian Antoni\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n        function assertType(value, type, name) {\n            var actual = sinon.typeOf(value);\n            if (actual !== type) {\n                throw new TypeError(\"Expected type of \" + name + \" to be \" +\n                    type + \", but was \" + actual);\n            }\n        }\n\n        var matcher = {\n            toString: function () {\n                return this.message;\n            }\n        };\n\n        function isMatcher(object) {\n            return matcher.isPrototypeOf(object);\n        }\n\n        function matchObject(expectation, actual) {\n            if (actual === null || actual === undefined) {\n                return false;\n            }\n            for (var key in expectation) {\n                if (expectation.hasOwnProperty(key)) {\n                    var exp = expectation[key];\n                    var act = actual[key];\n                    if (isMatcher(exp)) {\n                        if (!exp.test(act)) {\n                            return false;\n                        }\n                    } else if (sinon.typeOf(exp) === \"object\") {\n                        if (!matchObject(exp, act)) {\n                            return false;\n                        }\n                    } else if (!sinon.deepEqual(exp, act)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        function match(expectation, message) {\n            var m = sinon.create(matcher);\n            var type = sinon.typeOf(expectation);\n            switch (type) {\n            case \"object\":\n                if (typeof expectation.test === \"function\") {\n                    m.test = function (actual) {\n                        return expectation.test(actual) === true;\n                    };\n                    m.message = \"match(\" + sinon.functionName(expectation.test) + \")\";\n                    return m;\n                }\n                var str = [];\n                for (var key in expectation) {\n                    if (expectation.hasOwnProperty(key)) {\n                        str.push(key + \": \" + expectation[key]);\n                    }\n                }\n                m.test = function (actual) {\n                    return matchObject(expectation, actual);\n                };\n                m.message = \"match(\" + str.join(\", \") + \")\";\n                break;\n            case \"number\":\n                m.test = function (actual) {\n                    // we need type coercion here\n                    return expectation == actual; // eslint-disable-line eqeqeq\n                };\n                break;\n            case \"string\":\n                m.test = function (actual) {\n                    if (typeof actual !== \"string\") {\n                        return false;\n                    }\n                    return actual.indexOf(expectation) !== -1;\n                };\n                m.message = \"match(\\\"\" + expectation + \"\\\")\";\n                break;\n            case \"regexp\":\n                m.test = function (actual) {\n                    if (typeof actual !== \"string\") {\n                        return false;\n                    }\n                    return expectation.test(actual);\n                };\n                break;\n            case \"function\":\n                m.test = expectation;\n                if (message) {\n                    m.message = message;\n                } else {\n                    m.message = \"match(\" + sinon.functionName(expectation) + \")\";\n                }\n                break;\n            default:\n                m.test = function (actual) {\n                    return sinon.deepEqual(expectation, actual);\n                };\n            }\n            if (!m.message) {\n                m.message = \"match(\" + expectation + \")\";\n            }\n            return m;\n        }\n\n        matcher.or = function (m2) {\n            if (!arguments.length) {\n                throw new TypeError(\"Matcher expected\");\n            } else if (!isMatcher(m2)) {\n                m2 = match(m2);\n            }\n            var m1 = this;\n            var or = sinon.create(matcher);\n            or.test = function (actual) {\n                return m1.test(actual) || m2.test(actual);\n            };\n            or.message = m1.message + \".or(\" + m2.message + \")\";\n            return or;\n        };\n\n        matcher.and = function (m2) {\n            if (!arguments.length) {\n                throw new TypeError(\"Matcher expected\");\n            } else if (!isMatcher(m2)) {\n                m2 = match(m2);\n            }\n            var m1 = this;\n            var and = sinon.create(matcher);\n            and.test = function (actual) {\n                return m1.test(actual) && m2.test(actual);\n            };\n            and.message = m1.message + \".and(\" + m2.message + \")\";\n            return and;\n        };\n\n        match.isMatcher = isMatcher;\n\n        match.any = match(function () {\n            return true;\n        }, \"any\");\n\n        match.defined = match(function (actual) {\n            return actual !== null && actual !== undefined;\n        }, \"defined\");\n\n        match.truthy = match(function (actual) {\n            return !!actual;\n        }, \"truthy\");\n\n        match.falsy = match(function (actual) {\n            return !actual;\n        }, \"falsy\");\n\n        match.same = function (expectation) {\n            return match(function (actual) {\n                return expectation === actual;\n            }, \"same(\" + expectation + \")\");\n        };\n\n        match.typeOf = function (type) {\n            assertType(type, \"string\", \"type\");\n            return match(function (actual) {\n                return sinon.typeOf(actual) === type;\n            }, \"typeOf(\\\"\" + type + \"\\\")\");\n        };\n\n        match.instanceOf = function (type) {\n            assertType(type, \"function\", \"type\");\n            return match(function (actual) {\n                return actual instanceof type;\n            }, \"instanceOf(\" + sinon.functionName(type) + \")\");\n        };\n\n        function createPropertyMatcher(propertyTest, messagePrefix) {\n            return function (property, value) {\n                assertType(property, \"string\", \"property\");\n                var onlyProperty = arguments.length === 1;\n                var message = messagePrefix + \"(\\\"\" + property + \"\\\"\";\n                if (!onlyProperty) {\n                    message += \", \" + value;\n                }\n                message += \")\";\n                return match(function (actual) {\n                    if (actual === undefined || actual === null ||\n                            !propertyTest(actual, property)) {\n                        return false;\n                    }\n                    return onlyProperty || sinon.deepEqual(value, actual[property]);\n                }, message);\n            };\n        }\n\n        match.has = createPropertyMatcher(function (actual, property) {\n            if (typeof actual === \"object\") {\n                return property in actual;\n            }\n            return actual[property] !== undefined;\n        }, \"has\");\n\n        match.hasOwn = createPropertyMatcher(function (actual, property) {\n            return actual.hasOwnProperty(property);\n        }, \"hasOwn\");\n\n        match.bool = match.typeOf(\"boolean\");\n        match.number = match.typeOf(\"number\");\n        match.string = match.typeOf(\"string\");\n        match.object = match.typeOf(\"object\");\n        match.func = match.typeOf(\"function\");\n        match.array = match.typeOf(\"array\");\n        match.regexp = match.typeOf(\"regexp\");\n        match.date = match.typeOf(\"date\");\n\n        sinon.match = match;\n        return match;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        require(\"./typeOf\");\n        module.exports = makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n */\n/**\n * Format functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2014 Christian Johansen\n */\n(function (sinonGlobal, formatio) {\n    \n    function makeApi(sinon) {\n        function valueFormatter(value) {\n            return \"\" + value;\n        }\n\n        function getFormatioFormatter() {\n            var formatter = formatio.configure({\n                    quoteStrings: false,\n                    limitChildrenCount: 250\n                });\n\n            function format() {\n                return formatter.ascii.apply(formatter, arguments);\n            }\n\n            return format;\n        }\n\n        function getNodeFormatter() {\n            try {\n                var util = require(\"util\");\n            } catch (e) {\n                /* Node, but no util module - would be very old, but better safe than sorry */\n            }\n\n            function format(v) {\n                var isObjectWithNativeToString = typeof v === \"object\" && v.toString === Object.prototype.toString;\n                return isObjectWithNativeToString ? util.inspect(v) : v;\n            }\n\n            return util ? format : valueFormatter;\n        }\n\n        var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n        var formatter;\n\n        if (isNode) {\n            try {\n                formatio = require(\"formatio\");\n            }\n            catch (e) {} // eslint-disable-line no-empty\n        }\n\n        if (formatio) {\n            formatter = getFormatioFormatter();\n        } else if (isNode) {\n            formatter = getNodeFormatter();\n        } else {\n            formatter = valueFormatter;\n        }\n\n        sinon.format = formatter;\n        return sinon.format;\n    }\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        module.exports = makeApi(sinon);\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon, // eslint-disable-line no-undef\n    typeof formatio === \"object\" && formatio // eslint-disable-line no-undef\n));\n\n/**\n  * @depend util/core.js\n  * @depend match.js\n  * @depend format.js\n  */\n/**\n  * Spy calls\n  *\n  * @author Christian Johansen (christian@cjohansen.no)\n  * @author Maximilian Antoni (mail@maxantoni.de)\n  * @license BSD\n  *\n  * Copyright (c) 2010-2013 Christian Johansen\n  * Copyright (c) 2013 Maximilian Antoni\n  */\n(function (sinonGlobal) {\n    \n    var slice = Array.prototype.slice;\n\n    function makeApi(sinon) {\n        function throwYieldError(proxy, text, args) {\n            var msg = sinon.functionName(proxy) + text;\n            if (args.length) {\n                msg += \" Received [\" + slice.call(args).join(\", \") + \"]\";\n            }\n            throw new Error(msg);\n        }\n\n        var callProto = {\n            calledOn: function calledOn(thisValue) {\n                if (sinon.match && sinon.match.isMatcher(thisValue)) {\n                    return thisValue.test(this.thisValue);\n                }\n                return this.thisValue === thisValue;\n            },\n\n            calledWith: function calledWith() {\n                var l = arguments.length;\n                if (l > this.args.length) {\n                    return false;\n                }\n                for (var i = 0; i < l; i += 1) {\n                    if (!sinon.deepEqual(arguments[i], this.args[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n\n            calledWithMatch: function calledWithMatch() {\n                var l = arguments.length;\n                if (l > this.args.length) {\n                    return false;\n                }\n                for (var i = 0; i < l; i += 1) {\n                    var actual = this.args[i];\n                    var expectation = arguments[i];\n                    if (!sinon.match || !sinon.match(expectation).test(actual)) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n\n            calledWithExactly: function calledWithExactly() {\n                return arguments.length === this.args.length &&\n                    this.calledWith.apply(this, arguments);\n            },\n\n            notCalledWith: function notCalledWith() {\n                return !this.calledWith.apply(this, arguments);\n            },\n\n            notCalledWithMatch: function notCalledWithMatch() {\n                return !this.calledWithMatch.apply(this, arguments);\n            },\n\n            returned: function returned(value) {\n                return sinon.deepEqual(value, this.returnValue);\n            },\n\n            threw: function threw(error) {\n                if (typeof error === \"undefined\" || !this.exception) {\n                    return !!this.exception;\n                }\n\n                return this.exception === error || this.exception.name === error;\n            },\n\n            calledWithNew: function calledWithNew() {\n                return this.proxy.prototype && this.thisValue instanceof this.proxy;\n            },\n\n            calledBefore: function (other) {\n                return this.callId < other.callId;\n            },\n\n            calledAfter: function (other) {\n                return this.callId > other.callId;\n            },\n\n            callArg: function (pos) {\n                this.args[pos]();\n            },\n\n            callArgOn: function (pos, thisValue) {\n                this.args[pos].apply(thisValue);\n            },\n\n            callArgWith: function (pos) {\n                this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));\n            },\n\n            callArgOnWith: function (pos, thisValue) {\n                var args = slice.call(arguments, 2);\n                this.args[pos].apply(thisValue, args);\n            },\n\n            \"yield\": function () {\n                this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));\n            },\n\n            yieldOn: function (thisValue) {\n                var args = this.args;\n                for (var i = 0, l = args.length; i < l; ++i) {\n                    if (typeof args[i] === \"function\") {\n                        args[i].apply(thisValue, slice.call(arguments, 1));\n                        return;\n                    }\n                }\n                throwYieldError(this.proxy, \" cannot yield since no callback was passed.\", args);\n            },\n\n            yieldTo: function (prop) {\n                this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));\n            },\n\n            yieldToOn: function (prop, thisValue) {\n                var args = this.args;\n                for (var i = 0, l = args.length; i < l; ++i) {\n                    if (args[i] && typeof args[i][prop] === \"function\") {\n                        args[i][prop].apply(thisValue, slice.call(arguments, 2));\n                        return;\n                    }\n                }\n                throwYieldError(this.proxy, \" cannot yield to '\" + prop +\n                    \"' since no callback was passed.\", args);\n            },\n\n            getStackFrames: function () {\n                // Omit the error message and the two top stack frames in sinon itself:\n                return this.stack && this.stack.split(\"\\n\").slice(3);\n            },\n\n            toString: function () {\n                var callStr = this.proxy ? this.proxy.toString() + \"(\" : \"\";\n                var args = [];\n\n                if (!this.args) {\n                    return \":(\";\n                }\n\n                for (var i = 0, l = this.args.length; i < l; ++i) {\n                    args.push(sinon.format(this.args[i]));\n                }\n\n                callStr = callStr + args.join(\", \") + \")\";\n\n                if (typeof this.returnValue !== \"undefined\") {\n                    callStr += \" => \" + sinon.format(this.returnValue);\n                }\n\n                if (this.exception) {\n                    callStr += \" !\" + this.exception.name;\n\n                    if (this.exception.message) {\n                        callStr += \"(\" + this.exception.message + \")\";\n                    }\n                }\n                if (this.stack) {\n                    callStr += this.getStackFrames()[0].replace(/^\\s*(?:at\\s+|@)?/, \" at \");\n\n                }\n\n                return callStr;\n            }\n        };\n\n        callProto.invokeCallback = callProto.yield;\n\n        function createSpyCall(spy, thisValue, args, returnValue, exception, id, stack) {\n            if (typeof id !== \"number\") {\n                throw new TypeError(\"Call id is not a number\");\n            }\n            var proxyCall = sinon.create(callProto);\n            proxyCall.proxy = spy;\n            proxyCall.thisValue = thisValue;\n            proxyCall.args = args;\n            proxyCall.returnValue = returnValue;\n            proxyCall.exception = exception;\n            proxyCall.callId = id;\n            proxyCall.stack = stack;\n\n            return proxyCall;\n        }\n        createSpyCall.toString = callProto.toString; // used by mocks\n\n        sinon.spyCall = createSpyCall;\n        return createSpyCall;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        require(\"./match\");\n        require(\"./format\");\n        module.exports = makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n  * @depend times_in_words.js\n  * @depend util/core.js\n  * @depend extend.js\n  * @depend call.js\n  * @depend format.js\n  */\n/**\n  * Spy functions\n  *\n  * @author Christian Johansen (christian@cjohansen.no)\n  * @license BSD\n  *\n  * Copyright (c) 2010-2013 Christian Johansen\n  */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n        var push = Array.prototype.push;\n        var slice = Array.prototype.slice;\n        var callId = 0;\n\n        function spy(object, property, types) {\n            if (!property && typeof object === \"function\") {\n                return spy.create(object);\n            }\n\n            if (!object && !property) {\n                return spy.create(function () { });\n            }\n\n            if (types) {\n                var methodDesc = sinon.getPropertyDescriptor(object, property);\n                for (var i = 0; i < types.length; i++) {\n                    methodDesc[types[i]] = spy.create(methodDesc[types[i]]);\n                }\n                return sinon.wrapMethod(object, property, methodDesc);\n            }\n\n            return sinon.wrapMethod(object, property, spy.create(object[property]));\n        }\n\n        function matchingFake(fakes, args, strict) {\n            if (!fakes) {\n                return undefined;\n            }\n\n            for (var i = 0, l = fakes.length; i < l; i++) {\n                if (fakes[i].matches(args, strict)) {\n                    return fakes[i];\n                }\n            }\n        }\n\n        function incrementCallCount() {\n            this.called = true;\n            this.callCount += 1;\n            this.notCalled = false;\n            this.calledOnce = this.callCount === 1;\n            this.calledTwice = this.callCount === 2;\n            this.calledThrice = this.callCount === 3;\n        }\n\n        function createCallProperties() {\n            this.firstCall = this.getCall(0);\n            this.secondCall = this.getCall(1);\n            this.thirdCall = this.getCall(2);\n            this.lastCall = this.getCall(this.callCount - 1);\n        }\n\n        var vars = \"a,b,c,d,e,f,g,h,i,j,k,l\";\n        function createProxy(func, proxyLength) {\n            // Retain the function length:\n            var p;\n            if (proxyLength) {\n                eval(\"p = (function proxy(\" + vars.substring(0, proxyLength * 2 - 1) + // eslint-disable-line no-eval\n                    \") { return p.invoke(func, this, slice.call(arguments)); });\");\n            } else {\n                p = function proxy() {\n                    return p.invoke(func, this, slice.call(arguments));\n                };\n            }\n            p.isSinonProxy = true;\n            return p;\n        }\n\n        var uuid = 0;\n\n        // Public API\n        var spyApi = {\n            reset: function () {\n                if (this.invoking) {\n                    var err = new Error(\"Cannot reset Sinon function while invoking it. \" +\n                                        \"Move the call to .reset outside of the callback.\");\n                    err.name = \"InvalidResetException\";\n                    throw err;\n                }\n\n                this.called = false;\n                this.notCalled = true;\n                this.calledOnce = false;\n                this.calledTwice = false;\n                this.calledThrice = false;\n                this.callCount = 0;\n                this.firstCall = null;\n                this.secondCall = null;\n                this.thirdCall = null;\n                this.lastCall = null;\n                this.args = [];\n                this.returnValues = [];\n                this.thisValues = [];\n                this.exceptions = [];\n                this.callIds = [];\n                this.stacks = [];\n                if (this.fakes) {\n                    for (var i = 0; i < this.fakes.length; i++) {\n                        this.fakes[i].reset();\n                    }\n                }\n\n                return this;\n            },\n\n            create: function create(func, spyLength) {\n                var name;\n\n                if (typeof func !== \"function\") {\n                    func = function () { };\n                } else {\n                    name = sinon.functionName(func);\n                }\n\n                if (!spyLength) {\n                    spyLength = func.length;\n                }\n\n                var proxy = createProxy(func, spyLength);\n\n                sinon.extend(proxy, spy);\n                delete proxy.create;\n                sinon.extend(proxy, func);\n\n                proxy.reset();\n                proxy.prototype = func.prototype;\n                proxy.displayName = name || \"spy\";\n                proxy.toString = sinon.functionToString;\n                proxy.instantiateFake = sinon.spy.create;\n                proxy.id = \"spy#\" + uuid++;\n\n                return proxy;\n            },\n\n            invoke: function invoke(func, thisValue, args) {\n                var matching = matchingFake(this.fakes, args);\n                var exception, returnValue;\n\n                incrementCallCount.call(this);\n                push.call(this.thisValues, thisValue);\n                push.call(this.args, args);\n                push.call(this.callIds, callId++);\n\n                // Make call properties available from within the spied function:\n                createCallProperties.call(this);\n\n                try {\n                    this.invoking = true;\n\n                    if (matching) {\n                        returnValue = matching.invoke(func, thisValue, args);\n                    } else {\n                        returnValue = (this.func || func).apply(thisValue, args);\n                    }\n\n                    var thisCall = this.getCall(this.callCount - 1);\n                    if (thisCall.calledWithNew() && typeof returnValue !== \"object\") {\n                        returnValue = thisValue;\n                    }\n                } catch (e) {\n                    exception = e;\n                } finally {\n                    delete this.invoking;\n                }\n\n                push.call(this.exceptions, exception);\n                push.call(this.returnValues, returnValue);\n                push.call(this.stacks, new Error().stack);\n\n                // Make return value and exception available in the calls:\n                createCallProperties.call(this);\n\n                if (exception !== undefined) {\n                    throw exception;\n                }\n\n                return returnValue;\n            },\n\n            named: function named(name) {\n                this.displayName = name;\n                return this;\n            },\n\n            getCall: function getCall(i) {\n                if (i < 0 || i >= this.callCount) {\n                    return null;\n                }\n\n                return sinon.spyCall(this, this.thisValues[i], this.args[i],\n                                        this.returnValues[i], this.exceptions[i],\n                                        this.callIds[i], this.stacks[i]);\n            },\n\n            getCalls: function () {\n                var calls = [];\n                var i;\n\n                for (i = 0; i < this.callCount; i++) {\n                    calls.push(this.getCall(i));\n                }\n\n                return calls;\n            },\n\n            calledBefore: function calledBefore(spyFn) {\n                if (!this.called) {\n                    return false;\n                }\n\n                if (!spyFn.called) {\n                    return true;\n                }\n\n                return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];\n            },\n\n            calledAfter: function calledAfter(spyFn) {\n                if (!this.called || !spyFn.called) {\n                    return false;\n                }\n\n                return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];\n            },\n\n            withArgs: function () {\n                var args = slice.call(arguments);\n\n                if (this.fakes) {\n                    var match = matchingFake(this.fakes, args, true);\n\n                    if (match) {\n                        return match;\n                    }\n                } else {\n                    this.fakes = [];\n                }\n\n                var original = this;\n                var fake = this.instantiateFake();\n                fake.matchingAguments = args;\n                fake.parent = this;\n                push.call(this.fakes, fake);\n\n                fake.withArgs = function () {\n                    return original.withArgs.apply(original, arguments);\n                };\n\n                for (var i = 0; i < this.args.length; i++) {\n                    if (fake.matches(this.args[i])) {\n                        incrementCallCount.call(fake);\n                        push.call(fake.thisValues, this.thisValues[i]);\n                        push.call(fake.args, this.args[i]);\n                        push.call(fake.returnValues, this.returnValues[i]);\n                        push.call(fake.exceptions, this.exceptions[i]);\n                        push.call(fake.callIds, this.callIds[i]);\n                    }\n                }\n                createCallProperties.call(fake);\n\n                return fake;\n            },\n\n            matches: function (args, strict) {\n                var margs = this.matchingAguments;\n\n                if (margs.length <= args.length &&\n                    sinon.deepEqual(margs, args.slice(0, margs.length))) {\n                    return !strict || margs.length === args.length;\n                }\n            },\n\n            printf: function (format) {\n                var spyInstance = this;\n                var args = slice.call(arguments, 1);\n                var formatter;\n\n                return (format || \"\").replace(/%(.)/g, function (match, specifyer) {\n                    formatter = spyApi.formatters[specifyer];\n\n                    if (typeof formatter === \"function\") {\n                        return formatter.call(null, spyInstance, args);\n                    } else if (!isNaN(parseInt(specifyer, 10))) {\n                        return sinon.format(args[specifyer - 1]);\n                    }\n\n                    return \"%\" + specifyer;\n                });\n            }\n        };\n\n        function delegateToCalls(method, matchAny, actual, notCalled) {\n            spyApi[method] = function () {\n                if (!this.called) {\n                    if (notCalled) {\n                        return notCalled.apply(this, arguments);\n                    }\n                    return false;\n                }\n\n                var currentCall;\n                var matches = 0;\n\n                for (var i = 0, l = this.callCount; i < l; i += 1) {\n                    currentCall = this.getCall(i);\n\n                    if (currentCall[actual || method].apply(currentCall, arguments)) {\n                        matches += 1;\n\n                        if (matchAny) {\n                            return true;\n                        }\n                    }\n                }\n\n                return matches === this.callCount;\n            };\n        }\n\n        delegateToCalls(\"calledOn\", true);\n        delegateToCalls(\"alwaysCalledOn\", false, \"calledOn\");\n        delegateToCalls(\"calledWith\", true);\n        delegateToCalls(\"calledWithMatch\", true);\n        delegateToCalls(\"alwaysCalledWith\", false, \"calledWith\");\n        delegateToCalls(\"alwaysCalledWithMatch\", false, \"calledWithMatch\");\n        delegateToCalls(\"calledWithExactly\", true);\n        delegateToCalls(\"alwaysCalledWithExactly\", false, \"calledWithExactly\");\n        delegateToCalls(\"neverCalledWith\", false, \"notCalledWith\", function () {\n            return true;\n        });\n        delegateToCalls(\"neverCalledWithMatch\", false, \"notCalledWithMatch\", function () {\n            return true;\n        });\n        delegateToCalls(\"threw\", true);\n        delegateToCalls(\"alwaysThrew\", false, \"threw\");\n        delegateToCalls(\"returned\", true);\n        delegateToCalls(\"alwaysReturned\", false, \"returned\");\n        delegateToCalls(\"calledWithNew\", true);\n        delegateToCalls(\"alwaysCalledWithNew\", false, \"calledWithNew\");\n        delegateToCalls(\"callArg\", false, \"callArgWith\", function () {\n            throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\n        });\n        spyApi.callArgWith = spyApi.callArg;\n        delegateToCalls(\"callArgOn\", false, \"callArgOnWith\", function () {\n            throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\n        });\n        spyApi.callArgOnWith = spyApi.callArgOn;\n        delegateToCalls(\"yield\", false, \"yield\", function () {\n            throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\n        });\n        // \"invokeCallback\" is an alias for \"yield\" since \"yield\" is invalid in strict mode.\n        spyApi.invokeCallback = spyApi.yield;\n        delegateToCalls(\"yieldOn\", false, \"yieldOn\", function () {\n            throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\n        });\n        delegateToCalls(\"yieldTo\", false, \"yieldTo\", function (property) {\n            throw new Error(this.toString() + \" cannot yield to '\" + property +\n                \"' since it was not yet invoked.\");\n        });\n        delegateToCalls(\"yieldToOn\", false, \"yieldToOn\", function (property) {\n            throw new Error(this.toString() + \" cannot yield to '\" + property +\n                \"' since it was not yet invoked.\");\n        });\n\n        spyApi.formatters = {\n            c: function (spyInstance) {\n                return sinon.timesInWords(spyInstance.callCount);\n            },\n\n            n: function (spyInstance) {\n                return spyInstance.toString();\n            },\n\n            C: function (spyInstance) {\n                var calls = [];\n\n                for (var i = 0, l = spyInstance.callCount; i < l; ++i) {\n                    var stringifiedCall = \"    \" + spyInstance.getCall(i).toString();\n                    if (/\\n/.test(calls[i - 1])) {\n                        stringifiedCall = \"\\n\" + stringifiedCall;\n                    }\n                    push.call(calls, stringifiedCall);\n                }\n\n                return calls.length > 0 ? \"\\n\" + calls.join(\"\\n\") : \"\";\n            },\n\n            t: function (spyInstance) {\n                var objects = [];\n\n                for (var i = 0, l = spyInstance.callCount; i < l; ++i) {\n                    push.call(objects, sinon.format(spyInstance.thisValues[i]));\n                }\n\n                return objects.join(\", \");\n            },\n\n            \"*\": function (spyInstance, args) {\n                var formatted = [];\n\n                for (var i = 0, l = args.length; i < l; ++i) {\n                    push.call(formatted, sinon.format(args[i]));\n                }\n\n                return formatted.join(\", \");\n            }\n        };\n\n        sinon.extend(spy, spyApi);\n\n        spy.spyCall = sinon.spyCall;\n        sinon.spy = spy;\n\n        return spy;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var core = require(\"./util/core\");\n        require(\"./call\");\n        require(\"./extend\");\n        require(\"./times_in_words\");\n        require(\"./format\");\n        module.exports = makeApi(core);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n * @depend extend.js\n */\n/**\n * Stub behavior\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @author Tim Fischbach (mail@timfischbach.de)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    var slice = Array.prototype.slice;\n    var join = Array.prototype.join;\n    var useLeftMostCallback = -1;\n    var useRightMostCallback = -2;\n\n    var nextTick = (function () {\n        if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n            return process.nextTick;\n        }\n\n        if (typeof setImmediate === \"function\") {\n            return setImmediate;\n        }\n\n        return function (callback) {\n            setTimeout(callback, 0);\n        };\n    })();\n\n    function throwsException(error, message) {\n        if (typeof error === \"string\") {\n            this.exception = new Error(message || \"\");\n            this.exception.name = error;\n        } else if (!error) {\n            this.exception = new Error(\"Error\");\n        } else {\n            this.exception = error;\n        }\n\n        return this;\n    }\n\n    function getCallback(behavior, args) {\n        var callArgAt = behavior.callArgAt;\n\n        if (callArgAt >= 0) {\n            return args[callArgAt];\n        }\n\n        var argumentList;\n\n        if (callArgAt === useLeftMostCallback) {\n            argumentList = args;\n        }\n\n        if (callArgAt === useRightMostCallback) {\n            argumentList = slice.call(args).reverse();\n        }\n\n        var callArgProp = behavior.callArgProp;\n\n        for (var i = 0, l = argumentList.length; i < l; ++i) {\n            if (!callArgProp && typeof argumentList[i] === \"function\") {\n                return argumentList[i];\n            }\n\n            if (callArgProp && argumentList[i] &&\n                typeof argumentList[i][callArgProp] === \"function\") {\n                return argumentList[i][callArgProp];\n            }\n        }\n\n        return null;\n    }\n\n    function makeApi(sinon) {\n        function getCallbackError(behavior, func, args) {\n            if (behavior.callArgAt < 0) {\n                var msg;\n\n                if (behavior.callArgProp) {\n                    msg = sinon.functionName(behavior.stub) +\n                        \" expected to yield to '\" + behavior.callArgProp +\n                        \"', but no object with such a property was passed.\";\n                } else {\n                    msg = sinon.functionName(behavior.stub) +\n                        \" expected to yield, but no callback was passed.\";\n                }\n\n                if (args.length > 0) {\n                    msg += \" Received [\" + join.call(args, \", \") + \"]\";\n                }\n\n                return msg;\n            }\n\n            return \"argument at index \" + behavior.callArgAt + \" is not a function: \" + func;\n        }\n\n        function callCallback(behavior, args) {\n            if (typeof behavior.callArgAt === \"number\") {\n                var func = getCallback(behavior, args);\n\n                if (typeof func !== \"function\") {\n                    throw new TypeError(getCallbackError(behavior, func, args));\n                }\n\n                if (behavior.callbackAsync) {\n                    nextTick(function () {\n                        func.apply(behavior.callbackContext, behavior.callbackArguments);\n                    });\n                } else {\n                    func.apply(behavior.callbackContext, behavior.callbackArguments);\n                }\n            }\n        }\n\n        var proto = {\n            create: function create(stub) {\n                var behavior = sinon.extend({}, sinon.behavior);\n                delete behavior.create;\n                behavior.stub = stub;\n\n                return behavior;\n            },\n\n            isPresent: function isPresent() {\n                return (typeof this.callArgAt === \"number\" ||\n                        this.exception ||\n                        typeof this.returnArgAt === \"number\" ||\n                        this.returnThis ||\n                        this.returnValueDefined);\n            },\n\n            invoke: function invoke(context, args) {\n                callCallback(this, args);\n\n                if (this.exception) {\n                    throw this.exception;\n                } else if (typeof this.returnArgAt === \"number\") {\n                    return args[this.returnArgAt];\n                } else if (this.returnThis) {\n                    return context;\n                }\n\n                return this.returnValue;\n            },\n\n            onCall: function onCall(index) {\n                return this.stub.onCall(index);\n            },\n\n            onFirstCall: function onFirstCall() {\n                return this.stub.onFirstCall();\n            },\n\n            onSecondCall: function onSecondCall() {\n                return this.stub.onSecondCall();\n            },\n\n            onThirdCall: function onThirdCall() {\n                return this.stub.onThirdCall();\n            },\n\n            withArgs: function withArgs(/* arguments */) {\n                throw new Error(\n                    \"Defining a stub by invoking \\\"stub.onCall(...).withArgs(...)\\\" \" +\n                    \"is not supported. Use \\\"stub.withArgs(...).onCall(...)\\\" \" +\n                    \"to define sequential behavior for calls with certain arguments.\"\n                );\n            },\n\n            callsArg: function callsArg(pos) {\n                if (typeof pos !== \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n\n                this.callArgAt = pos;\n                this.callbackArguments = [];\n                this.callbackContext = undefined;\n                this.callArgProp = undefined;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            callsArgOn: function callsArgOn(pos, context) {\n                if (typeof pos !== \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n                if (typeof context !== \"object\") {\n                    throw new TypeError(\"argument context is not an object\");\n                }\n\n                this.callArgAt = pos;\n                this.callbackArguments = [];\n                this.callbackContext = context;\n                this.callArgProp = undefined;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            callsArgWith: function callsArgWith(pos) {\n                if (typeof pos !== \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n\n                this.callArgAt = pos;\n                this.callbackArguments = slice.call(arguments, 1);\n                this.callbackContext = undefined;\n                this.callArgProp = undefined;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            callsArgOnWith: function callsArgWith(pos, context) {\n                if (typeof pos !== \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n                if (typeof context !== \"object\") {\n                    throw new TypeError(\"argument context is not an object\");\n                }\n\n                this.callArgAt = pos;\n                this.callbackArguments = slice.call(arguments, 2);\n                this.callbackContext = context;\n                this.callArgProp = undefined;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            yields: function () {\n                this.callArgAt = useLeftMostCallback;\n                this.callbackArguments = slice.call(arguments, 0);\n                this.callbackContext = undefined;\n                this.callArgProp = undefined;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            yieldsRight: function () {\n                this.callArgAt = useRightMostCallback;\n                this.callbackArguments = slice.call(arguments, 0);\n                this.callbackContext = undefined;\n                this.callArgProp = undefined;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            yieldsOn: function (context) {\n                if (typeof context !== \"object\") {\n                    throw new TypeError(\"argument context is not an object\");\n                }\n\n                this.callArgAt = useLeftMostCallback;\n                this.callbackArguments = slice.call(arguments, 1);\n                this.callbackContext = context;\n                this.callArgProp = undefined;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            yieldsTo: function (prop) {\n                this.callArgAt = useLeftMostCallback;\n                this.callbackArguments = slice.call(arguments, 1);\n                this.callbackContext = undefined;\n                this.callArgProp = prop;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            yieldsToOn: function (prop, context) {\n                if (typeof context !== \"object\") {\n                    throw new TypeError(\"argument context is not an object\");\n                }\n\n                this.callArgAt = useLeftMostCallback;\n                this.callbackArguments = slice.call(arguments, 2);\n                this.callbackContext = context;\n                this.callArgProp = prop;\n                this.callbackAsync = false;\n\n                return this;\n            },\n\n            throws: throwsException,\n            throwsException: throwsException,\n\n            returns: function returns(value) {\n                this.returnValue = value;\n                this.returnValueDefined = true;\n                this.exception = undefined;\n\n                return this;\n            },\n\n            returnsArg: function returnsArg(pos) {\n                if (typeof pos !== \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n\n                this.returnArgAt = pos;\n\n                return this;\n            },\n\n            returnsThis: function returnsThis() {\n                this.returnThis = true;\n\n                return this;\n            }\n        };\n\n        function createAsyncVersion(syncFnName) {\n            return function () {\n                var result = this[syncFnName].apply(this, arguments);\n                this.callbackAsync = true;\n                return result;\n            };\n        }\n\n        // create asynchronous versions of callsArg* and yields* methods\n        for (var method in proto) {\n            // need to avoid creating anotherasync versions of the newly added async methods\n            if (proto.hasOwnProperty(method) && method.match(/^(callsArg|yields)/) && !method.match(/Async/)) {\n                proto[method + \"Async\"] = createAsyncVersion(method);\n            }\n        }\n\n        sinon.behavior = proto;\n        return proto;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        require(\"./extend\");\n        module.exports = makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n        function walkInternal(obj, iterator, context, originalObj, seen) {\n            var proto, prop;\n\n            if (typeof Object.getOwnPropertyNames !== \"function\") {\n                // We explicitly want to enumerate through all of the prototype's properties\n                // in this case, therefore we deliberately leave out an own property check.\n                /* eslint-disable guard-for-in */\n                for (prop in obj) {\n                    iterator.call(context, obj[prop], prop, obj);\n                }\n                /* eslint-enable guard-for-in */\n\n                return;\n            }\n\n            Object.getOwnPropertyNames(obj).forEach(function (k) {\n                if (!seen[k]) {\n                    seen[k] = true;\n                    var target = typeof Object.getOwnPropertyDescriptor(obj, k).get === \"function\" ?\n                        originalObj : obj;\n                    iterator.call(context, target[k], k, target);\n                }\n            });\n\n            proto = Object.getPrototypeOf(obj);\n            if (proto) {\n                walkInternal(proto, iterator, context, originalObj, seen);\n            }\n        }\n\n        /* Public: walks the prototype chain of an object and iterates over every own property\n         * name encountered. The iterator is called in the same fashion that Array.prototype.forEach\n         * works, where it is passed the value, key, and own object as the 1st, 2nd, and 3rd positional\n         * argument, respectively. In cases where Object.getOwnPropertyNames is not available, walk will\n         * default to using a simple for..in loop.\n         *\n         * obj - The object to walk the prototype chain for.\n         * iterator - The function to be called on each pass of the walk.\n         * context - (Optional) When given, the iterator will be called with this object as the receiver.\n         */\n        function walk(obj, iterator, context) {\n            return walkInternal(obj, iterator, context, obj, {});\n        }\n\n        sinon.walk = walk;\n        return sinon.walk;\n    }\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        module.exports = makeApi(sinon);\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n * @depend extend.js\n * @depend spy.js\n * @depend behavior.js\n * @depend walk.js\n */\n/**\n * Stub functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n        function stub(object, property, func) {\n            if (!!func && typeof func !== \"function\" && typeof func !== \"object\") {\n                throw new TypeError(\"Custom stub should be a function or a property descriptor\");\n            }\n\n            var wrapper;\n\n            if (func) {\n                if (typeof func === \"function\") {\n                    wrapper = sinon.spy && sinon.spy.create ? sinon.spy.create(func) : func;\n                } else {\n                    wrapper = func;\n                    if (sinon.spy && sinon.spy.create) {\n                        var types = sinon.objectKeys(wrapper);\n                        for (var i = 0; i < types.length; i++) {\n                            wrapper[types[i]] = sinon.spy.create(wrapper[types[i]]);\n                        }\n                    }\n                }\n            } else {\n                var stubLength = 0;\n                if (typeof object === \"object\" && typeof object[property] === \"function\") {\n                    stubLength = object[property].length;\n                }\n                wrapper = stub.create(stubLength);\n            }\n\n            if (!object && typeof property === \"undefined\") {\n                return sinon.stub.create();\n            }\n\n            if (typeof property === \"undefined\" && typeof object === \"object\") {\n                sinon.walk(object || {}, function (value, prop, propOwner) {\n                    // we don't want to stub things like toString(), valueOf(), etc. so we only stub if the object\n                    // is not Object.prototype\n                    if (\n                        propOwner !== Object.prototype &&\n                        prop !== \"constructor\" &&\n                        typeof sinon.getPropertyDescriptor(propOwner, prop).value === \"function\"\n                    ) {\n                        stub(object, prop);\n                    }\n                });\n\n                return object;\n            }\n\n            return sinon.wrapMethod(object, property, wrapper);\n        }\n\n\n        /*eslint-disable no-use-before-define*/\n        function getParentBehaviour(stubInstance) {\n            return (stubInstance.parent && getCurrentBehavior(stubInstance.parent));\n        }\n\n        function getDefaultBehavior(stubInstance) {\n            return stubInstance.defaultBehavior ||\n                    getParentBehaviour(stubInstance) ||\n                    sinon.behavior.create(stubInstance);\n        }\n\n        function getCurrentBehavior(stubInstance) {\n            var behavior = stubInstance.behaviors[stubInstance.callCount - 1];\n            return behavior && behavior.isPresent() ? behavior : getDefaultBehavior(stubInstance);\n        }\n        /*eslint-enable no-use-before-define*/\n\n        var uuid = 0;\n\n        var proto = {\n            create: function create(stubLength) {\n                var functionStub = function () {\n                    return getCurrentBehavior(functionStub).invoke(this, arguments);\n                };\n\n                functionStub.id = \"stub#\" + uuid++;\n                var orig = functionStub;\n                functionStub = sinon.spy.create(functionStub, stubLength);\n                functionStub.func = orig;\n\n                sinon.extend(functionStub, stub);\n                functionStub.instantiateFake = sinon.stub.create;\n                functionStub.displayName = \"stub\";\n                functionStub.toString = sinon.functionToString;\n\n                functionStub.defaultBehavior = null;\n                functionStub.behaviors = [];\n\n                return functionStub;\n            },\n\n            resetBehavior: function () {\n                var i;\n\n                this.defaultBehavior = null;\n                this.behaviors = [];\n\n                delete this.returnValue;\n                delete this.returnArgAt;\n                this.returnThis = false;\n\n                if (this.fakes) {\n                    for (i = 0; i < this.fakes.length; i++) {\n                        this.fakes[i].resetBehavior();\n                    }\n                }\n            },\n\n            onCall: function onCall(index) {\n                if (!this.behaviors[index]) {\n                    this.behaviors[index] = sinon.behavior.create(this);\n                }\n\n                return this.behaviors[index];\n            },\n\n            onFirstCall: function onFirstCall() {\n                return this.onCall(0);\n            },\n\n            onSecondCall: function onSecondCall() {\n                return this.onCall(1);\n            },\n\n            onThirdCall: function onThirdCall() {\n                return this.onCall(2);\n            }\n        };\n\n        function createBehavior(behaviorMethod) {\n            return function () {\n                this.defaultBehavior = this.defaultBehavior || sinon.behavior.create(this);\n                this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);\n                return this;\n            };\n        }\n\n        for (var method in sinon.behavior) {\n            if (sinon.behavior.hasOwnProperty(method) &&\n                !proto.hasOwnProperty(method) &&\n                method !== \"create\" &&\n                method !== \"withArgs\" &&\n                method !== \"invoke\") {\n                proto[method] = createBehavior(method);\n            }\n        }\n\n        sinon.extend(stub, proto);\n        sinon.stub = stub;\n\n        return stub;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var core = require(\"./util/core\");\n        require(\"./behavior\");\n        require(\"./spy\");\n        require(\"./extend\");\n        module.exports = makeApi(core);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend times_in_words.js\n * @depend util/core.js\n * @depend call.js\n * @depend extend.js\n * @depend match.js\n * @depend spy.js\n * @depend stub.js\n * @depend format.js\n */\n/**\n * Mock functions.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n        var push = [].push;\n        var match = sinon.match;\n\n        function mock(object) {\n            // if (typeof console !== undefined && console.warn) {\n            //     console.warn(\"mock will be removed from Sinon.JS v2.0\");\n            // }\n\n            if (!object) {\n                return sinon.expectation.create(\"Anonymous mock\");\n            }\n\n            return mock.create(object);\n        }\n\n        function each(collection, callback) {\n            if (!collection) {\n                return;\n            }\n\n            for (var i = 0, l = collection.length; i < l; i += 1) {\n                callback(collection[i]);\n            }\n        }\n\n        function arrayEquals(arr1, arr2, compareLength) {\n            if (compareLength && (arr1.length !== arr2.length)) {\n                return false;\n            }\n\n            for (var i = 0, l = arr1.length; i < l; i++) {\n                if (!sinon.deepEqual(arr1[i], arr2[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        sinon.extend(mock, {\n            create: function create(object) {\n                if (!object) {\n                    throw new TypeError(\"object is null\");\n                }\n\n                var mockObject = sinon.extend({}, mock);\n                mockObject.object = object;\n                delete mockObject.create;\n\n                return mockObject;\n            },\n\n            expects: function expects(method) {\n                if (!method) {\n                    throw new TypeError(\"method is falsy\");\n                }\n\n                if (!this.expectations) {\n                    this.expectations = {};\n                    this.proxies = [];\n                }\n\n                if (!this.expectations[method]) {\n                    this.expectations[method] = [];\n                    var mockObject = this;\n\n                    sinon.wrapMethod(this.object, method, function () {\n                        return mockObject.invokeMethod(method, this, arguments);\n                    });\n\n                    push.call(this.proxies, method);\n                }\n\n                var expectation = sinon.expectation.create(method);\n                push.call(this.expectations[method], expectation);\n\n                return expectation;\n            },\n\n            restore: function restore() {\n                var object = this.object;\n\n                each(this.proxies, function (proxy) {\n                    if (typeof object[proxy].restore === \"function\") {\n                        object[proxy].restore();\n                    }\n                });\n            },\n\n            verify: function verify() {\n                var expectations = this.expectations || {};\n                var messages = [];\n                var met = [];\n\n                each(this.proxies, function (proxy) {\n                    each(expectations[proxy], function (expectation) {\n                        if (!expectation.met()) {\n                            push.call(messages, expectation.toString());\n                        } else {\n                            push.call(met, expectation.toString());\n                        }\n                    });\n                });\n\n                this.restore();\n\n                if (messages.length > 0) {\n                    sinon.expectation.fail(messages.concat(met).join(\"\\n\"));\n                } else if (met.length > 0) {\n                    sinon.expectation.pass(messages.concat(met).join(\"\\n\"));\n                }\n\n                return true;\n            },\n\n            invokeMethod: function invokeMethod(method, thisValue, args) {\n                var expectations = this.expectations && this.expectations[method] ? this.expectations[method] : [];\n                var expectationsWithMatchingArgs = [];\n                var currentArgs = args || [];\n                var i, available;\n\n                for (i = 0; i < expectations.length; i += 1) {\n                    var expectedArgs = expectations[i].expectedArguments || [];\n                    if (arrayEquals(expectedArgs, currentArgs, expectations[i].expectsExactArgCount)) {\n                        expectationsWithMatchingArgs.push(expectations[i]);\n                    }\n                }\n\n                for (i = 0; i < expectationsWithMatchingArgs.length; i += 1) {\n                    if (!expectationsWithMatchingArgs[i].met() &&\n                        expectationsWithMatchingArgs[i].allowsCall(thisValue, args)) {\n                        return expectationsWithMatchingArgs[i].apply(thisValue, args);\n                    }\n                }\n\n                var messages = [];\n                var exhausted = 0;\n\n                for (i = 0; i < expectationsWithMatchingArgs.length; i += 1) {\n                    if (expectationsWithMatchingArgs[i].allowsCall(thisValue, args)) {\n                        available = available || expectationsWithMatchingArgs[i];\n                    } else {\n                        exhausted += 1;\n                    }\n                }\n\n                if (available && exhausted === 0) {\n                    return available.apply(thisValue, args);\n                }\n\n                for (i = 0; i < expectations.length; i += 1) {\n                    push.call(messages, \"    \" + expectations[i].toString());\n                }\n\n                messages.unshift(\"Unexpected call: \" + sinon.spyCall.toString.call({\n                    proxy: method,\n                    args: args\n                }));\n\n                sinon.expectation.fail(messages.join(\"\\n\"));\n            }\n        });\n\n        var times = sinon.timesInWords;\n        var slice = Array.prototype.slice;\n\n        function callCountInWords(callCount) {\n            if (callCount === 0) {\n                return \"never called\";\n            }\n\n            return \"called \" + times(callCount);\n        }\n\n        function expectedCallCountInWords(expectation) {\n            var min = expectation.minCalls;\n            var max = expectation.maxCalls;\n\n            if (typeof min === \"number\" && typeof max === \"number\") {\n                var str = times(min);\n\n                if (min !== max) {\n                    str = \"at least \" + str + \" and at most \" + times(max);\n                }\n\n                return str;\n            }\n\n            if (typeof min === \"number\") {\n                return \"at least \" + times(min);\n            }\n\n            return \"at most \" + times(max);\n        }\n\n        function receivedMinCalls(expectation) {\n            var hasMinLimit = typeof expectation.minCalls === \"number\";\n            return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n        }\n\n        function receivedMaxCalls(expectation) {\n            if (typeof expectation.maxCalls !== \"number\") {\n                return false;\n            }\n\n            return expectation.callCount === expectation.maxCalls;\n        }\n\n        function verifyMatcher(possibleMatcher, arg) {\n            var isMatcher = match && match.isMatcher(possibleMatcher);\n\n            return isMatcher && possibleMatcher.test(arg) || true;\n        }\n\n        sinon.expectation = {\n            minCalls: 1,\n            maxCalls: 1,\n\n            create: function create(methodName) {\n                var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);\n                delete expectation.create;\n                expectation.method = methodName;\n\n                return expectation;\n            },\n\n            invoke: function invoke(func, thisValue, args) {\n                this.verifyCallAllowed(thisValue, args);\n\n                return sinon.spy.invoke.apply(this, arguments);\n            },\n\n            atLeast: function atLeast(num) {\n                if (typeof num !== \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not number\");\n                }\n\n                if (!this.limitsSet) {\n                    this.maxCalls = null;\n                    this.limitsSet = true;\n                }\n\n                this.minCalls = num;\n\n                return this;\n            },\n\n            atMost: function atMost(num) {\n                if (typeof num !== \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not number\");\n                }\n\n                if (!this.limitsSet) {\n                    this.minCalls = null;\n                    this.limitsSet = true;\n                }\n\n                this.maxCalls = num;\n\n                return this;\n            },\n\n            never: function never() {\n                return this.exactly(0);\n            },\n\n            once: function once() {\n                return this.exactly(1);\n            },\n\n            twice: function twice() {\n                return this.exactly(2);\n            },\n\n            thrice: function thrice() {\n                return this.exactly(3);\n            },\n\n            exactly: function exactly(num) {\n                if (typeof num !== \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not a number\");\n                }\n\n                this.atLeast(num);\n                return this.atMost(num);\n            },\n\n            met: function met() {\n                return !this.failed && receivedMinCalls(this);\n            },\n\n            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n                if (receivedMaxCalls(this)) {\n                    this.failed = true;\n                    sinon.expectation.fail(this.method + \" already called \" + times(this.maxCalls));\n                }\n\n                if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n                    sinon.expectation.fail(this.method + \" called with \" + thisValue + \" as thisValue, expected \" +\n                        this.expectedThis);\n                }\n\n                if (!(\"expectedArguments\" in this)) {\n                    return;\n                }\n\n                if (!args) {\n                    sinon.expectation.fail(this.method + \" received no arguments, expected \" +\n                        sinon.format(this.expectedArguments));\n                }\n\n                if (args.length < this.expectedArguments.length) {\n                    sinon.expectation.fail(this.method + \" received too few arguments (\" + sinon.format(args) +\n                        \"), expected \" + sinon.format(this.expectedArguments));\n                }\n\n                if (this.expectsExactArgCount &&\n                    args.length !== this.expectedArguments.length) {\n                    sinon.expectation.fail(this.method + \" received too many arguments (\" + sinon.format(args) +\n                        \"), expected \" + sinon.format(this.expectedArguments));\n                }\n\n                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\n\n                    if (!verifyMatcher(this.expectedArguments[i], args[i])) {\n                        sinon.expectation.fail(this.method + \" received wrong arguments \" + sinon.format(args) +\n                            \", didn't match \" + this.expectedArguments.toString());\n                    }\n\n                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\n                        sinon.expectation.fail(this.method + \" received wrong arguments \" + sinon.format(args) +\n                            \", expected \" + sinon.format(this.expectedArguments));\n                    }\n                }\n            },\n\n            allowsCall: function allowsCall(thisValue, args) {\n                if (this.met() && receivedMaxCalls(this)) {\n                    return false;\n                }\n\n                if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n                    return false;\n                }\n\n                if (!(\"expectedArguments\" in this)) {\n                    return true;\n                }\n\n                args = args || [];\n\n                if (args.length < this.expectedArguments.length) {\n                    return false;\n                }\n\n                if (this.expectsExactArgCount &&\n                    args.length !== this.expectedArguments.length) {\n                    return false;\n                }\n\n                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\n                    if (!verifyMatcher(this.expectedArguments[i], args[i])) {\n                        return false;\n                    }\n\n                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n\n            withArgs: function withArgs() {\n                this.expectedArguments = slice.call(arguments);\n                return this;\n            },\n\n            withExactArgs: function withExactArgs() {\n                this.withArgs.apply(this, arguments);\n                this.expectsExactArgCount = true;\n                return this;\n            },\n\n            on: function on(thisValue) {\n                this.expectedThis = thisValue;\n                return this;\n            },\n\n            toString: function () {\n                var args = (this.expectedArguments || []).slice();\n\n                if (!this.expectsExactArgCount) {\n                    push.call(args, \"[...]\");\n                }\n\n                var callStr = sinon.spyCall.toString.call({\n                    proxy: this.method || \"anonymous mock expectation\",\n                    args: args\n                });\n\n                var message = callStr.replace(\", [...\", \"[, ...\") + \" \" +\n                    expectedCallCountInWords(this);\n\n                if (this.met()) {\n                    return \"Expectation met: \" + message;\n                }\n\n                return \"Expected \" + message + \" (\" +\n                    callCountInWords(this.callCount) + \")\";\n            },\n\n            verify: function verify() {\n                if (!this.met()) {\n                    sinon.expectation.fail(this.toString());\n                } else {\n                    sinon.expectation.pass(this.toString());\n                }\n\n                return true;\n            },\n\n            pass: function pass(message) {\n                sinon.assert.pass(message);\n            },\n\n            fail: function fail(message) {\n                var exception = new Error(message);\n                exception.name = \"ExpectationError\";\n\n                throw exception;\n            }\n        };\n\n        sinon.mock = mock;\n        return mock;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        require(\"./times_in_words\");\n        require(\"./call\");\n        require(\"./extend\");\n        require(\"./match\");\n        require(\"./spy\");\n        require(\"./stub\");\n        require(\"./format\");\n\n        module.exports = makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n * @depend spy.js\n * @depend stub.js\n * @depend mock.js\n */\n/**\n * Collections of stubs, spies and mocks.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    var push = [].push;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    function getFakes(fakeCollection) {\n        if (!fakeCollection.fakes) {\n            fakeCollection.fakes = [];\n        }\n\n        return fakeCollection.fakes;\n    }\n\n    function each(fakeCollection, method) {\n        var fakes = getFakes(fakeCollection);\n\n        for (var i = 0, l = fakes.length; i < l; i += 1) {\n            if (typeof fakes[i][method] === \"function\") {\n                fakes[i][method]();\n            }\n        }\n    }\n\n    function compact(fakeCollection) {\n        var fakes = getFakes(fakeCollection);\n        var i = 0;\n        while (i < fakes.length) {\n            fakes.splice(i, 1);\n        }\n    }\n\n    function makeApi(sinon) {\n        var collection = {\n            verify: function resolve() {\n                each(this, \"verify\");\n            },\n\n            restore: function restore() {\n                each(this, \"restore\");\n                compact(this);\n            },\n\n            reset: function restore() {\n                each(this, \"reset\");\n            },\n\n            verifyAndRestore: function verifyAndRestore() {\n                var exception;\n\n                try {\n                    this.verify();\n                } catch (e) {\n                    exception = e;\n                }\n\n                this.restore();\n\n                if (exception) {\n                    throw exception;\n                }\n            },\n\n            add: function add(fake) {\n                push.call(getFakes(this), fake);\n                return fake;\n            },\n\n            spy: function spy() {\n                return this.add(sinon.spy.apply(sinon, arguments));\n            },\n\n            stub: function stub(object, property, value) {\n                if (property) {\n                    var original = object[property];\n\n                    if (typeof original !== \"function\") {\n                        if (!hasOwnProperty.call(object, property)) {\n                            throw new TypeError(\"Cannot stub non-existent own property \" + property);\n                        }\n\n                        object[property] = value;\n\n                        return this.add({\n                            restore: function () {\n                                object[property] = original;\n                            }\n                        });\n                    }\n                }\n                if (!property && !!object && typeof object === \"object\") {\n                    var stubbedObj = sinon.stub.apply(sinon, arguments);\n\n                    for (var prop in stubbedObj) {\n                        if (typeof stubbedObj[prop] === \"function\") {\n                            this.add(stubbedObj[prop]);\n                        }\n                    }\n\n                    return stubbedObj;\n                }\n\n                return this.add(sinon.stub.apply(sinon, arguments));\n            },\n\n            mock: function mock() {\n                return this.add(sinon.mock.apply(sinon, arguments));\n            },\n\n            inject: function inject(obj) {\n                var col = this;\n\n                obj.spy = function () {\n                    return col.spy.apply(col, arguments);\n                };\n\n                obj.stub = function () {\n                    return col.stub.apply(col, arguments);\n                };\n\n                obj.mock = function () {\n                    return col.mock.apply(col, arguments);\n                };\n\n                return obj;\n            }\n        };\n\n        sinon.collection = collection;\n        return collection;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        require(\"./mock\");\n        require(\"./spy\");\n        require(\"./stub\");\n        module.exports = makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * Fake timer API\n * setTimeout\n * setInterval\n * clearTimeout\n * clearInterval\n * tick\n * reset\n * Date\n *\n * Inspired by jsUnitMockTimeOut from JsUnit\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function () {\n    \n    function makeApi(s, lol) {\n        /*global lolex */\n        var llx = typeof lolex !== \"undefined\" ? lolex : lol;\n\n        s.useFakeTimers = function () {\n            var now;\n            var methods = Array.prototype.slice.call(arguments);\n\n            if (typeof methods[0] === \"string\") {\n                now = 0;\n            } else {\n                now = methods.shift();\n            }\n\n            var clock = llx.install(now || 0, methods);\n            clock.restore = clock.uninstall;\n            return clock;\n        };\n\n        s.clock = {\n            create: function (now) {\n                return llx.createClock(now);\n            }\n        };\n\n        s.timers = {\n            setTimeout: setTimeout,\n            clearTimeout: clearTimeout,\n            setImmediate: (typeof setImmediate !== \"undefined\" ? setImmediate : undefined),\n            clearImmediate: (typeof clearImmediate !== \"undefined\" ? clearImmediate : undefined),\n            setInterval: setInterval,\n            clearInterval: clearInterval,\n            Date: Date\n        };\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, epxorts, module, lolex) {\n        var core = require(\"./core\");\n        makeApi(core, lolex);\n        module.exports = core;\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n    } else if (isNode) {\n        loadDependencies(require, module.exports, module, require(\"lolex\"));\n    } else {\n        makeApi(sinon); // eslint-disable-line no-undef\n    }\n}());\n\n/**\n * Minimal Event interface implementation\n *\n * Original implementation by Sven Fuchs: https://gist.github.com/995028\n * Modifications and tests by Christian Johansen.\n *\n * @author Sven Fuchs (svenfuchs@artweb-design.de)\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2011 Sven Fuchs, Christian Johansen\n */\nif (typeof sinon === \"undefined\") {\n    this.sinon = {};\n}\n\n(function () {\n    \n    var push = [].push;\n\n    function makeApi(sinon) {\n        sinon.Event = function Event(type, bubbles, cancelable, target) {\n            this.initEvent(type, bubbles, cancelable, target);\n        };\n\n        sinon.Event.prototype = {\n            initEvent: function (type, bubbles, cancelable, target) {\n                this.type = type;\n                this.bubbles = bubbles;\n                this.cancelable = cancelable;\n                this.target = target;\n            },\n\n            stopPropagation: function () {},\n\n            preventDefault: function () {\n                this.defaultPrevented = true;\n            }\n        };\n\n        sinon.ProgressEvent = function ProgressEvent(type, progressEventRaw, target) {\n            this.initEvent(type, false, false, target);\n            this.loaded = typeof progressEventRaw.loaded === \"number\" ? progressEventRaw.loaded : null;\n            this.total = typeof progressEventRaw.total === \"number\" ? progressEventRaw.total : null;\n            this.lengthComputable = !!progressEventRaw.total;\n        };\n\n        sinon.ProgressEvent.prototype = new sinon.Event();\n\n        sinon.ProgressEvent.prototype.constructor = sinon.ProgressEvent;\n\n        sinon.CustomEvent = function CustomEvent(type, customData, target) {\n            this.initEvent(type, false, false, target);\n            this.detail = customData.detail || null;\n        };\n\n        sinon.CustomEvent.prototype = new sinon.Event();\n\n        sinon.CustomEvent.prototype.constructor = sinon.CustomEvent;\n\n        sinon.EventTarget = {\n            addEventListener: function addEventListener(event, listener) {\n                this.eventListeners = this.eventListeners || {};\n                this.eventListeners[event] = this.eventListeners[event] || [];\n                push.call(this.eventListeners[event], listener);\n            },\n\n            removeEventListener: function removeEventListener(event, listener) {\n                var listeners = this.eventListeners && this.eventListeners[event] || [];\n\n                for (var i = 0, l = listeners.length; i < l; ++i) {\n                    if (listeners[i] === listener) {\n                        return listeners.splice(i, 1);\n                    }\n                }\n            },\n\n            dispatchEvent: function dispatchEvent(event) {\n                var type = event.type;\n                var listeners = this.eventListeners && this.eventListeners[type] || [];\n\n                for (var i = 0; i < listeners.length; i++) {\n                    if (typeof listeners[i] === \"function\") {\n                        listeners[i].call(this, event);\n                    } else {\n                        listeners[i].handleEvent(event);\n                    }\n                }\n\n                return !!event.defaultPrevented;\n            }\n        };\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require) {\n        var sinon = require(\"./core\");\n        makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n    } else if (isNode) {\n        loadDependencies(require);\n    } else {\n        makeApi(sinon); // eslint-disable-line no-undef\n    }\n}());\n\n/**\n * @depend util/core.js\n */\n/**\n * Logs errors\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2014 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    // cache a reference to setTimeout, so that our reference won't be stubbed out\n    // when using fake timers and errors will still get logged\n    // https://github.com/cjohansen/Sinon.JS/issues/381\n    var realSetTimeout = setTimeout;\n\n    function makeApi(sinon) {\n\n        function log() {}\n\n        function logError(label, err) {\n            var msg = label + \" threw exception: \";\n\n            function throwLoggedError() {\n                err.message = msg + err.message;\n                throw err;\n            }\n\n            sinon.log(msg + \"[\" + err.name + \"] \" + err.message);\n\n            if (err.stack) {\n                sinon.log(err.stack);\n            }\n\n            if (logError.useImmediateExceptions) {\n                throwLoggedError();\n            } else {\n                logError.setTimeout(throwLoggedError, 0);\n            }\n        }\n\n        // When set to true, any errors logged will be thrown immediately;\n        // If set to false, the errors will be thrown in separate execution frame.\n        logError.useImmediateExceptions = false;\n\n        // wrap realSetTimeout with something we can stub in tests\n        logError.setTimeout = function (func, timeout) {\n            realSetTimeout(func, timeout);\n        };\n\n        var exports = {};\n        exports.log = sinon.log = log;\n        exports.logError = sinon.logError = logError;\n\n        return exports;\n    }\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        module.exports = makeApi(sinon);\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend core.js\n * @depend ../extend.js\n * @depend event.js\n * @depend ../log_error.js\n */\n/**\n * Fake XDomainRequest object\n */\n\n/**\n * Returns the global to prevent assigning values to 'this' when this is undefined.\n * This can occur when files are interpreted by node in strict mode.\n * @private\n */\nfunction getGlobal() {\n    \n    return typeof window !== \"undefined\" ? window : global;\n}\n\nif (typeof sinon === \"undefined\") {\n    if (typeof this === \"undefined\") {\n        getGlobal().sinon = {};\n    } else {\n        this.sinon = {};\n    }\n}\n\n// wrapper for global\n(function (global) {\n    \n    var xdr = { XDomainRequest: global.XDomainRequest };\n    xdr.GlobalXDomainRequest = global.XDomainRequest;\n    xdr.supportsXDR = typeof xdr.GlobalXDomainRequest !== \"undefined\";\n    xdr.workingXDR = xdr.supportsXDR ? xdr.GlobalXDomainRequest : false;\n\n    function makeApi(sinon) {\n        sinon.xdr = xdr;\n\n        function FakeXDomainRequest() {\n            this.readyState = FakeXDomainRequest.UNSENT;\n            this.requestBody = null;\n            this.requestHeaders = {};\n            this.status = 0;\n            this.timeout = null;\n\n            if (typeof FakeXDomainRequest.onCreate === \"function\") {\n                FakeXDomainRequest.onCreate(this);\n            }\n        }\n\n        function verifyState(x) {\n            if (x.readyState !== FakeXDomainRequest.OPENED) {\n                throw new Error(\"INVALID_STATE_ERR\");\n            }\n\n            if (x.sendFlag) {\n                throw new Error(\"INVALID_STATE_ERR\");\n            }\n        }\n\n        function verifyRequestSent(x) {\n            if (x.readyState === FakeXDomainRequest.UNSENT) {\n                throw new Error(\"Request not sent\");\n            }\n            if (x.readyState === FakeXDomainRequest.DONE) {\n                throw new Error(\"Request done\");\n            }\n        }\n\n        function verifyResponseBodyType(body) {\n            if (typeof body !== \"string\") {\n                var error = new Error(\"Attempted to respond to fake XDomainRequest with \" +\n                                    body + \", which is not a string.\");\n                error.name = \"InvalidBodyException\";\n                throw error;\n            }\n        }\n\n        sinon.extend(FakeXDomainRequest.prototype, sinon.EventTarget, {\n            open: function open(method, url) {\n                this.method = method;\n                this.url = url;\n\n                this.responseText = null;\n                this.sendFlag = false;\n\n                this.readyStateChange(FakeXDomainRequest.OPENED);\n            },\n\n            readyStateChange: function readyStateChange(state) {\n                this.readyState = state;\n                var eventName = \"\";\n                switch (this.readyState) {\n                case FakeXDomainRequest.UNSENT:\n                    break;\n                case FakeXDomainRequest.OPENED:\n                    break;\n                case FakeXDomainRequest.LOADING:\n                    if (this.sendFlag) {\n                        //raise the progress event\n                        eventName = \"onprogress\";\n                    }\n                    break;\n                case FakeXDomainRequest.DONE:\n                    if (this.isTimeout) {\n                        eventName = \"ontimeout\";\n                    } else if (this.errorFlag || (this.status < 200 || this.status > 299)) {\n                        eventName = \"onerror\";\n                    } else {\n                        eventName = \"onload\";\n                    }\n                    break;\n                }\n\n                // raising event (if defined)\n                if (eventName) {\n                    if (typeof this[eventName] === \"function\") {\n                        try {\n                            this[eventName]();\n                        } catch (e) {\n                            sinon.logError(\"Fake XHR \" + eventName + \" handler\", e);\n                        }\n                    }\n                }\n            },\n\n            send: function send(data) {\n                verifyState(this);\n\n                if (!/^(get|head)$/i.test(this.method)) {\n                    this.requestBody = data;\n                }\n                this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=utf-8\";\n\n                this.errorFlag = false;\n                this.sendFlag = true;\n                this.readyStateChange(FakeXDomainRequest.OPENED);\n\n                if (typeof this.onSend === \"function\") {\n                    this.onSend(this);\n                }\n            },\n\n            abort: function abort() {\n                this.aborted = true;\n                this.responseText = null;\n                this.errorFlag = true;\n\n                if (this.readyState > sinon.FakeXDomainRequest.UNSENT && this.sendFlag) {\n                    this.readyStateChange(sinon.FakeXDomainRequest.DONE);\n                    this.sendFlag = false;\n                }\n            },\n\n            setResponseBody: function setResponseBody(body) {\n                verifyRequestSent(this);\n                verifyResponseBodyType(body);\n\n                var chunkSize = this.chunkSize || 10;\n                var index = 0;\n                this.responseText = \"\";\n\n                do {\n                    this.readyStateChange(FakeXDomainRequest.LOADING);\n                    this.responseText += body.substring(index, index + chunkSize);\n                    index += chunkSize;\n                } while (index < body.length);\n\n                this.readyStateChange(FakeXDomainRequest.DONE);\n            },\n\n            respond: function respond(status, contentType, body) {\n                // content-type ignored, since XDomainRequest does not carry this\n                // we keep the same syntax for respond(...) as for FakeXMLHttpRequest to ease\n                // test integration across browsers\n                this.status = typeof status === \"number\" ? status : 200;\n                this.setResponseBody(body || \"\");\n            },\n\n            simulatetimeout: function simulatetimeout() {\n                this.status = 0;\n                this.isTimeout = true;\n                // Access to this should actually throw an error\n                this.responseText = undefined;\n                this.readyStateChange(FakeXDomainRequest.DONE);\n            }\n        });\n\n        sinon.extend(FakeXDomainRequest, {\n            UNSENT: 0,\n            OPENED: 1,\n            LOADING: 3,\n            DONE: 4\n        });\n\n        sinon.useFakeXDomainRequest = function useFakeXDomainRequest() {\n            sinon.FakeXDomainRequest.restore = function restore(keepOnCreate) {\n                if (xdr.supportsXDR) {\n                    global.XDomainRequest = xdr.GlobalXDomainRequest;\n                }\n\n                delete sinon.FakeXDomainRequest.restore;\n\n                if (keepOnCreate !== true) {\n                    delete sinon.FakeXDomainRequest.onCreate;\n                }\n            };\n            if (xdr.supportsXDR) {\n                global.XDomainRequest = sinon.FakeXDomainRequest;\n            }\n            return sinon.FakeXDomainRequest;\n        };\n\n        sinon.FakeXDomainRequest = FakeXDomainRequest;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./core\");\n        require(\"../extend\");\n        require(\"./event\");\n        require(\"../log_error\");\n        makeApi(sinon);\n        module.exports = sinon;\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n    } else if (isNode) {\n        loadDependencies(require, module.exports, module);\n    } else {\n        makeApi(sinon); // eslint-disable-line no-undef\n    }\n})(typeof global !== \"undefined\" ? global : self);\n\n/**\n * @depend core.js\n * @depend ../extend.js\n * @depend event.js\n * @depend ../log_error.js\n */\n/**\n * Fake XMLHttpRequest object\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal, global) {\n    \n    function getWorkingXHR(globalScope) {\n        var supportsXHR = typeof globalScope.XMLHttpRequest !== \"undefined\";\n        if (supportsXHR) {\n            return globalScope.XMLHttpRequest;\n        }\n\n        var supportsActiveX = typeof globalScope.ActiveXObject !== \"undefined\";\n        if (supportsActiveX) {\n            return function () {\n                return new globalScope.ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n            };\n        }\n\n        return false;\n    }\n\n    var supportsProgress = typeof ProgressEvent !== \"undefined\";\n    var supportsCustomEvent = typeof CustomEvent !== \"undefined\";\n    var supportsFormData = typeof FormData !== \"undefined\";\n    var supportsArrayBuffer = typeof ArrayBuffer !== \"undefined\";\n    var supportsBlob = (function () {\n        try {\n            return !!new Blob();\n        } catch (e) {\n            return false;\n        }\n    })();\n    var sinonXhr = { XMLHttpRequest: global.XMLHttpRequest };\n    sinonXhr.GlobalXMLHttpRequest = global.XMLHttpRequest;\n    sinonXhr.GlobalActiveXObject = global.ActiveXObject;\n    sinonXhr.supportsActiveX = typeof sinonXhr.GlobalActiveXObject !== \"undefined\";\n    sinonXhr.supportsXHR = typeof sinonXhr.GlobalXMLHttpRequest !== \"undefined\";\n    sinonXhr.workingXHR = getWorkingXHR(global);\n    sinonXhr.supportsCORS = sinonXhr.supportsXHR && \"withCredentials\" in (new sinonXhr.GlobalXMLHttpRequest());\n\n    var unsafeHeaders = {\n        \"Accept-Charset\": true,\n        \"Accept-Encoding\": true,\n        Connection: true,\n        \"Content-Length\": true,\n        Cookie: true,\n        Cookie2: true,\n        \"Content-Transfer-Encoding\": true,\n        Date: true,\n        Expect: true,\n        Host: true,\n        \"Keep-Alive\": true,\n        Referer: true,\n        TE: true,\n        Trailer: true,\n        \"Transfer-Encoding\": true,\n        Upgrade: true,\n        \"User-Agent\": true,\n        Via: true\n    };\n\n    // An upload object is created for each\n    // FakeXMLHttpRequest and allows upload\n    // events to be simulated using uploadProgress\n    // and uploadError.\n    function UploadProgress() {\n        this.eventListeners = {\n            abort: [],\n            error: [],\n            load: [],\n            loadend: [],\n            progress: []\n        };\n    }\n\n    UploadProgress.prototype.addEventListener = function addEventListener(event, listener) {\n        this.eventListeners[event].push(listener);\n    };\n\n    UploadProgress.prototype.removeEventListener = function removeEventListener(event, listener) {\n        var listeners = this.eventListeners[event] || [];\n\n        for (var i = 0, l = listeners.length; i < l; ++i) {\n            if (listeners[i] === listener) {\n                return listeners.splice(i, 1);\n            }\n        }\n    };\n\n    UploadProgress.prototype.dispatchEvent = function dispatchEvent(event) {\n        var listeners = this.eventListeners[event.type] || [];\n\n        for (var i = 0, listener; (listener = listeners[i]) != null; i++) {\n            listener(event);\n        }\n    };\n\n    // Note that for FakeXMLHttpRequest to work pre ES5\n    // we lose some of the alignment with the spec.\n    // To ensure as close a match as possible,\n    // set responseType before calling open, send or respond;\n    function FakeXMLHttpRequest() {\n        this.readyState = FakeXMLHttpRequest.UNSENT;\n        this.requestHeaders = {};\n        this.requestBody = null;\n        this.status = 0;\n        this.statusText = \"\";\n        this.upload = new UploadProgress();\n        this.responseType = \"\";\n        this.response = \"\";\n        if (sinonXhr.supportsCORS) {\n            this.withCredentials = false;\n        }\n\n        var xhr = this;\n        var events = [\"loadstart\", \"load\", \"abort\", \"error\", \"loadend\"];\n\n        function addEventListener(eventName) {\n            xhr.addEventListener(eventName, function (event) {\n                var listener = xhr[\"on\" + eventName];\n\n                if (listener && typeof listener === \"function\") {\n                    listener.call(this, event);\n                }\n            });\n        }\n\n        for (var i = events.length - 1; i >= 0; i--) {\n            addEventListener(events[i]);\n        }\n\n        if (typeof FakeXMLHttpRequest.onCreate === \"function\") {\n            FakeXMLHttpRequest.onCreate(this);\n        }\n    }\n\n    function verifyState(xhr) {\n        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n\n        if (xhr.sendFlag) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n    }\n\n    function getHeader(headers, header) {\n        header = header.toLowerCase();\n\n        for (var h in headers) {\n            if (h.toLowerCase() === header) {\n                return h;\n            }\n        }\n\n        return null;\n    }\n\n    // filtering to enable a white-list version of Sinon FakeXhr,\n    // where whitelisted requests are passed through to real XHR\n    function each(collection, callback) {\n        if (!collection) {\n            return;\n        }\n\n        for (var i = 0, l = collection.length; i < l; i += 1) {\n            callback(collection[i]);\n        }\n    }\n    function some(collection, callback) {\n        for (var index = 0; index < collection.length; index++) {\n            if (callback(collection[index]) === true) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // largest arity in XHR is 5 - XHR#open\n    var apply = function (obj, method, args) {\n        switch (args.length) {\n        case 0: return obj[method]();\n        case 1: return obj[method](args[0]);\n        case 2: return obj[method](args[0], args[1]);\n        case 3: return obj[method](args[0], args[1], args[2]);\n        case 4: return obj[method](args[0], args[1], args[2], args[3]);\n        case 5: return obj[method](args[0], args[1], args[2], args[3], args[4]);\n        }\n    };\n\n    FakeXMLHttpRequest.filters = [];\n    FakeXMLHttpRequest.addFilter = function addFilter(fn) {\n        this.filters.push(fn);\n    };\n    var IE6Re = /MSIE 6/;\n    FakeXMLHttpRequest.defake = function defake(fakeXhr, xhrArgs) {\n        var xhr = new sinonXhr.workingXHR(); // eslint-disable-line new-cap\n\n        each([\n            \"open\",\n            \"setRequestHeader\",\n            \"send\",\n            \"abort\",\n            \"getResponseHeader\",\n            \"getAllResponseHeaders\",\n            \"addEventListener\",\n            \"overrideMimeType\",\n            \"removeEventListener\"\n        ], function (method) {\n            fakeXhr[method] = function () {\n                return apply(xhr, method, arguments);\n            };\n        });\n\n        var copyAttrs = function (args) {\n            each(args, function (attr) {\n                try {\n                    fakeXhr[attr] = xhr[attr];\n                } catch (e) {\n                    if (!IE6Re.test(navigator.userAgent)) {\n                        throw e;\n                    }\n                }\n            });\n        };\n\n        var stateChange = function stateChange() {\n            fakeXhr.readyState = xhr.readyState;\n            if (xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                copyAttrs([\"status\", \"statusText\"]);\n            }\n            if (xhr.readyState >= FakeXMLHttpRequest.LOADING) {\n                copyAttrs([\"responseText\", \"response\"]);\n            }\n            if (xhr.readyState === FakeXMLHttpRequest.DONE) {\n                copyAttrs([\"responseXML\"]);\n            }\n            if (fakeXhr.onreadystatechange) {\n                fakeXhr.onreadystatechange.call(fakeXhr, { target: fakeXhr });\n            }\n        };\n\n        if (xhr.addEventListener) {\n            for (var event in fakeXhr.eventListeners) {\n                if (fakeXhr.eventListeners.hasOwnProperty(event)) {\n\n                    /*eslint-disable no-loop-func*/\n                    each(fakeXhr.eventListeners[event], function (handler) {\n                        xhr.addEventListener(event, handler);\n                    });\n                    /*eslint-enable no-loop-func*/\n                }\n            }\n            xhr.addEventListener(\"readystatechange\", stateChange);\n        } else {\n            xhr.onreadystatechange = stateChange;\n        }\n        apply(xhr, \"open\", xhrArgs);\n    };\n    FakeXMLHttpRequest.useFilters = false;\n\n    function verifyRequestOpened(xhr) {\n        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n            throw new Error(\"INVALID_STATE_ERR - \" + xhr.readyState);\n        }\n    }\n\n    function verifyRequestSent(xhr) {\n        if (xhr.readyState === FakeXMLHttpRequest.DONE) {\n            throw new Error(\"Request done\");\n        }\n    }\n\n    function verifyHeadersReceived(xhr) {\n        if (xhr.async && xhr.readyState !== FakeXMLHttpRequest.HEADERS_RECEIVED) {\n            throw new Error(\"No headers received\");\n        }\n    }\n\n    function verifyResponseBodyType(body) {\n        if (typeof body !== \"string\") {\n            var error = new Error(\"Attempted to respond to fake XMLHttpRequest with \" +\n                                 body + \", which is not a string.\");\n            error.name = \"InvalidBodyException\";\n            throw error;\n        }\n    }\n\n    function convertToArrayBuffer(body) {\n        var buffer = new ArrayBuffer(body.length);\n        var view = new Uint8Array(buffer);\n        for (var i = 0; i < body.length; i++) {\n            var charCode = body.charCodeAt(i);\n            if (charCode >= 256) {\n                throw new TypeError(\"arraybuffer or blob responseTypes require binary string, \" +\n                                    \"invalid character \" + body[i] + \" found.\");\n            }\n            view[i] = charCode;\n        }\n        return buffer;\n    }\n\n    function isXmlContentType(contentType) {\n        return !contentType || /(text\\/xml)|(application\\/xml)|(\\+xml)/.test(contentType);\n    }\n\n    function convertResponseBody(responseType, contentType, body) {\n        if (responseType === \"\" || responseType === \"text\") {\n            return body;\n        } else if (supportsArrayBuffer && responseType === \"arraybuffer\") {\n            return convertToArrayBuffer(body);\n        } else if (responseType === \"json\") {\n            try {\n                return JSON.parse(body);\n            } catch (e) {\n                // Return parsing failure as null\n                return null;\n            }\n        } else if (supportsBlob && responseType === \"blob\") {\n            var blobOptions = {};\n            if (contentType) {\n                blobOptions.type = contentType;\n            }\n            return new Blob([convertToArrayBuffer(body)], blobOptions);\n        } else if (responseType === \"document\") {\n            if (isXmlContentType(contentType)) {\n                return FakeXMLHttpRequest.parseXML(body);\n            }\n            return null;\n        }\n        throw new Error(\"Invalid responseType \" + responseType);\n    }\n\n    function clearResponse(xhr) {\n        if (xhr.responseType === \"\" || xhr.responseType === \"text\") {\n            xhr.response = xhr.responseText = \"\";\n        } else {\n            xhr.response = xhr.responseText = null;\n        }\n        xhr.responseXML = null;\n    }\n\n    FakeXMLHttpRequest.parseXML = function parseXML(text) {\n        // Treat empty string as parsing failure\n        if (text !== \"\") {\n            try {\n                if (typeof DOMParser !== \"undefined\") {\n                    var parser = new DOMParser();\n                    return parser.parseFromString(text, \"text/xml\");\n                }\n                var xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n                xmlDoc.async = \"false\";\n                xmlDoc.loadXML(text);\n                return xmlDoc;\n            } catch (e) {\n                // Unable to parse XML - no biggie\n            }\n        }\n\n        return null;\n    };\n\n    FakeXMLHttpRequest.statusCodes = {\n        100: \"Continue\",\n        101: \"Switching Protocols\",\n        200: \"OK\",\n        201: \"Created\",\n        202: \"Accepted\",\n        203: \"Non-Authoritative Information\",\n        204: \"No Content\",\n        205: \"Reset Content\",\n        206: \"Partial Content\",\n        207: \"Multi-Status\",\n        300: \"Multiple Choice\",\n        301: \"Moved Permanently\",\n        302: \"Found\",\n        303: \"See Other\",\n        304: \"Not Modified\",\n        305: \"Use Proxy\",\n        307: \"Temporary Redirect\",\n        400: \"Bad Request\",\n        401: \"Unauthorized\",\n        402: \"Payment Required\",\n        403: \"Forbidden\",\n        404: \"Not Found\",\n        405: \"Method Not Allowed\",\n        406: \"Not Acceptable\",\n        407: \"Proxy Authentication Required\",\n        408: \"Request Timeout\",\n        409: \"Conflict\",\n        410: \"Gone\",\n        411: \"Length Required\",\n        412: \"Precondition Failed\",\n        413: \"Request Entity Too Large\",\n        414: \"Request-URI Too Long\",\n        415: \"Unsupported Media Type\",\n        416: \"Requested Range Not Satisfiable\",\n        417: \"Expectation Failed\",\n        422: \"Unprocessable Entity\",\n        500: \"Internal Server Error\",\n        501: \"Not Implemented\",\n        502: \"Bad Gateway\",\n        503: \"Service Unavailable\",\n        504: \"Gateway Timeout\",\n        505: \"HTTP Version Not Supported\"\n    };\n\n    function makeApi(sinon) {\n        sinon.xhr = sinonXhr;\n\n        sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {\n            async: true,\n\n            open: function open(method, url, async, username, password) {\n                this.method = method;\n                this.url = url;\n                this.async = typeof async === \"boolean\" ? async : true;\n                this.username = username;\n                this.password = password;\n                clearResponse(this);\n                this.requestHeaders = {};\n                this.sendFlag = false;\n\n                if (FakeXMLHttpRequest.useFilters === true) {\n                    var xhrArgs = arguments;\n                    var defake = some(FakeXMLHttpRequest.filters, function (filter) {\n                        return filter.apply(this, xhrArgs);\n                    });\n                    if (defake) {\n                        return FakeXMLHttpRequest.defake(this, arguments);\n                    }\n                }\n                this.readyStateChange(FakeXMLHttpRequest.OPENED);\n            },\n\n            readyStateChange: function readyStateChange(state) {\n                this.readyState = state;\n\n                var readyStateChangeEvent = new sinon.Event(\"readystatechange\", false, false, this);\n                var event, progress;\n\n                if (typeof this.onreadystatechange === \"function\") {\n                    try {\n                        this.onreadystatechange(readyStateChangeEvent);\n                    } catch (e) {\n                        sinon.logError(\"Fake XHR onreadystatechange handler\", e);\n                    }\n                }\n\n                if (this.readyState === FakeXMLHttpRequest.DONE) {\n                    // ensure loaded and total are numbers\n                    progress = {\n                      loaded: this.progress || 0,\n                      total: this.progress || 0\n                    };\n\n                    if (this.status === 0) {\n                        event = this.aborted ? \"abort\" : \"error\";\n                    }\n                    else {\n                        event = \"load\";\n                    }\n\n                    if (supportsProgress) {\n                        this.upload.dispatchEvent(new sinon.ProgressEvent(\"progress\", progress, this));\n                        this.upload.dispatchEvent(new sinon.ProgressEvent(event, progress, this));\n                        this.upload.dispatchEvent(new sinon.ProgressEvent(\"loadend\", progress, this));\n                    }\n\n                    this.dispatchEvent(new sinon.ProgressEvent(\"progress\", progress, this));\n                    this.dispatchEvent(new sinon.ProgressEvent(event, progress, this));\n                    this.dispatchEvent(new sinon.ProgressEvent(\"loadend\", progress, this));\n                }\n\n                this.dispatchEvent(readyStateChangeEvent);\n            },\n\n            setRequestHeader: function setRequestHeader(header, value) {\n                verifyState(this);\n\n                if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {\n                    throw new Error(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n                }\n\n                if (this.requestHeaders[header]) {\n                    this.requestHeaders[header] += \",\" + value;\n                } else {\n                    this.requestHeaders[header] = value;\n                }\n            },\n\n            // Helps testing\n            setResponseHeaders: function setResponseHeaders(headers) {\n                verifyRequestOpened(this);\n                this.responseHeaders = {};\n\n                for (var header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        this.responseHeaders[header] = headers[header];\n                    }\n                }\n\n                if (this.async) {\n                    this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);\n                } else {\n                    this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;\n                }\n            },\n\n            // Currently treats ALL data as a DOMString (i.e. no Document)\n            send: function send(data) {\n                verifyState(this);\n\n                if (!/^(get|head)$/i.test(this.method)) {\n                    var contentType = getHeader(this.requestHeaders, \"Content-Type\");\n                    if (this.requestHeaders[contentType]) {\n                        var value = this.requestHeaders[contentType].split(\";\");\n                        this.requestHeaders[contentType] = value[0] + \";charset=utf-8\";\n                    } else if (supportsFormData && !(data instanceof FormData)) {\n                        this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=utf-8\";\n                    }\n\n                    this.requestBody = data;\n                }\n\n                this.errorFlag = false;\n                this.sendFlag = this.async;\n                clearResponse(this);\n                this.readyStateChange(FakeXMLHttpRequest.OPENED);\n\n                if (typeof this.onSend === \"function\") {\n                    this.onSend(this);\n                }\n\n                this.dispatchEvent(new sinon.Event(\"loadstart\", false, false, this));\n            },\n\n            abort: function abort() {\n                this.aborted = true;\n                clearResponse(this);\n                this.errorFlag = true;\n                this.requestHeaders = {};\n                this.responseHeaders = {};\n\n                if (this.readyState > FakeXMLHttpRequest.UNSENT && this.sendFlag) {\n                    this.readyStateChange(FakeXMLHttpRequest.DONE);\n                    this.sendFlag = false;\n                }\n\n                this.readyState = FakeXMLHttpRequest.UNSENT;\n            },\n\n            error: function error() {\n                clearResponse(this);\n                this.errorFlag = true;\n                this.requestHeaders = {};\n                this.responseHeaders = {};\n\n                this.readyStateChange(FakeXMLHttpRequest.DONE);\n            },\n\n            getResponseHeader: function getResponseHeader(header) {\n                if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                    return null;\n                }\n\n                if (/^Set-Cookie2?$/i.test(header)) {\n                    return null;\n                }\n\n                header = getHeader(this.responseHeaders, header);\n\n                return this.responseHeaders[header] || null;\n            },\n\n            getAllResponseHeaders: function getAllResponseHeaders() {\n                if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                    return \"\";\n                }\n\n                var headers = \"\";\n\n                for (var header in this.responseHeaders) {\n                    if (this.responseHeaders.hasOwnProperty(header) &&\n                        !/^Set-Cookie2?$/i.test(header)) {\n                        headers += header + \": \" + this.responseHeaders[header] + \"\\r\\n\";\n                    }\n                }\n\n                return headers;\n            },\n\n            setResponseBody: function setResponseBody(body) {\n                verifyRequestSent(this);\n                verifyHeadersReceived(this);\n                verifyResponseBodyType(body);\n                var contentType = this.getResponseHeader(\"Content-Type\");\n\n                var isTextResponse = this.responseType === \"\" || this.responseType === \"text\";\n                clearResponse(this);\n                if (this.async) {\n                    var chunkSize = this.chunkSize || 10;\n                    var index = 0;\n\n                    do {\n                        this.readyStateChange(FakeXMLHttpRequest.LOADING);\n\n                        if (isTextResponse) {\n                            this.responseText = this.response += body.substring(index, index + chunkSize);\n                        }\n                        index += chunkSize;\n                    } while (index < body.length);\n                }\n\n                this.response = convertResponseBody(this.responseType, contentType, body);\n                if (isTextResponse) {\n                    this.responseText = this.response;\n                }\n\n                if (this.responseType === \"document\") {\n                    this.responseXML = this.response;\n                } else if (this.responseType === \"\" && isXmlContentType(contentType)) {\n                    this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);\n                }\n                this.progress = body.length;\n                this.readyStateChange(FakeXMLHttpRequest.DONE);\n            },\n\n            respond: function respond(status, headers, body) {\n                this.status = typeof status === \"number\" ? status : 200;\n                this.statusText = FakeXMLHttpRequest.statusCodes[this.status];\n                this.setResponseHeaders(headers || {});\n                this.setResponseBody(body || \"\");\n            },\n\n            uploadProgress: function uploadProgress(progressEventRaw) {\n                if (supportsProgress) {\n                    this.upload.dispatchEvent(new sinon.ProgressEvent(\"progress\", progressEventRaw));\n                }\n            },\n\n            downloadProgress: function downloadProgress(progressEventRaw) {\n                if (supportsProgress) {\n                    this.dispatchEvent(new sinon.ProgressEvent(\"progress\", progressEventRaw));\n                }\n            },\n\n            uploadError: function uploadError(error) {\n                if (supportsCustomEvent) {\n                    this.upload.dispatchEvent(new sinon.CustomEvent(\"error\", {detail: error}));\n                }\n            }\n        });\n\n        sinon.extend(FakeXMLHttpRequest, {\n            UNSENT: 0,\n            OPENED: 1,\n            HEADERS_RECEIVED: 2,\n            LOADING: 3,\n            DONE: 4\n        });\n\n        sinon.useFakeXMLHttpRequest = function () {\n            FakeXMLHttpRequest.restore = function restore(keepOnCreate) {\n                if (sinonXhr.supportsXHR) {\n                    global.XMLHttpRequest = sinonXhr.GlobalXMLHttpRequest;\n                }\n\n                if (sinonXhr.supportsActiveX) {\n                    global.ActiveXObject = sinonXhr.GlobalActiveXObject;\n                }\n\n                delete FakeXMLHttpRequest.restore;\n\n                if (keepOnCreate !== true) {\n                    delete FakeXMLHttpRequest.onCreate;\n                }\n            };\n            if (sinonXhr.supportsXHR) {\n                global.XMLHttpRequest = FakeXMLHttpRequest;\n            }\n\n            if (sinonXhr.supportsActiveX) {\n                global.ActiveXObject = function ActiveXObject(objId) {\n                    if (objId === \"Microsoft.XMLHTTP\" || /^Msxml2\\.XMLHTTP/i.test(objId)) {\n\n                        return new FakeXMLHttpRequest();\n                    }\n\n                    return new sinonXhr.GlobalActiveXObject(objId);\n                };\n            }\n\n            return FakeXMLHttpRequest;\n        };\n\n        sinon.FakeXMLHttpRequest = FakeXMLHttpRequest;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./core\");\n        require(\"../extend\");\n        require(\"./event\");\n        require(\"../log_error\");\n        makeApi(sinon);\n        module.exports = sinon;\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon, // eslint-disable-line no-undef\n    typeof global !== \"undefined\" ? global : self\n));\n\n/**\n * @depend fake_xdomain_request.js\n * @depend fake_xml_http_request.js\n * @depend ../format.js\n * @depend ../log_error.js\n */\n/**\n * The Sinon \"server\" mimics a web server that receives requests from\n * sinon.FakeXMLHttpRequest and provides an API to respond to those requests,\n * both synchronously and asynchronously. To respond synchronuously, canned\n * answers have to be provided upfront.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function () {\n    \n    var push = [].push;\n\n    function responseArray(handler) {\n        var response = handler;\n\n        if (Object.prototype.toString.call(handler) !== \"[object Array]\") {\n            response = [200, {}, handler];\n        }\n\n        if (typeof response[2] !== \"string\") {\n            throw new TypeError(\"Fake server response body should be string, but was \" +\n                                typeof response[2]);\n        }\n\n        return response;\n    }\n\n    var wloc = typeof window !== \"undefined\" ? window.location : {};\n    var rCurrLoc = new RegExp(\"^\" + wloc.protocol + \"//\" + wloc.host);\n\n    function matchOne(response, reqMethod, reqUrl) {\n        var rmeth = response.method;\n        var matchMethod = !rmeth || rmeth.toLowerCase() === reqMethod.toLowerCase();\n        var url = response.url;\n        var matchUrl = !url || url === reqUrl || (typeof url.test === \"function\" && url.test(reqUrl));\n\n        return matchMethod && matchUrl;\n    }\n\n    function match(response, request) {\n        var requestUrl = request.url;\n\n        if (!/^https?:\\/\\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {\n            requestUrl = requestUrl.replace(rCurrLoc, \"\");\n        }\n\n        if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {\n            if (typeof response.response === \"function\") {\n                var ru = response.url;\n                var args = [request].concat(ru && typeof ru.exec === \"function\" ? ru.exec(requestUrl).slice(1) : []);\n                return response.response.apply(response, args);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    function makeApi(sinon) {\n        sinon.fakeServer = {\n            create: function (config) {\n                var server = sinon.create(this);\n                server.configure(config);\n                if (!sinon.xhr.supportsCORS) {\n                    this.xhr = sinon.useFakeXDomainRequest();\n                } else {\n                    this.xhr = sinon.useFakeXMLHttpRequest();\n                }\n                server.requests = [];\n\n                this.xhr.onCreate = function (xhrObj) {\n                    server.addRequest(xhrObj);\n                };\n\n                return server;\n            },\n            configure: function (config) {\n                var whitelist = {\n                    \"autoRespond\": true,\n                    \"autoRespondAfter\": true,\n                    \"respondImmediately\": true,\n                    \"fakeHTTPMethods\": true\n                };\n                var setting;\n\n                config = config || {};\n                for (setting in config) {\n                    if (whitelist.hasOwnProperty(setting) && config.hasOwnProperty(setting)) {\n                        this[setting] = config[setting];\n                    }\n                }\n            },\n            addRequest: function addRequest(xhrObj) {\n                var server = this;\n                push.call(this.requests, xhrObj);\n\n                xhrObj.onSend = function () {\n                    server.handleRequest(this);\n\n                    if (server.respondImmediately) {\n                        server.respond();\n                    } else if (server.autoRespond && !server.responding) {\n                        setTimeout(function () {\n                            server.responding = false;\n                            server.respond();\n                        }, server.autoRespondAfter || 10);\n\n                        server.responding = true;\n                    }\n                };\n            },\n\n            getHTTPMethod: function getHTTPMethod(request) {\n                if (this.fakeHTTPMethods && /post/i.test(request.method)) {\n                    var matches = (request.requestBody || \"\").match(/_method=([^\\b;]+)/);\n                    return matches ? matches[1] : request.method;\n                }\n\n                return request.method;\n            },\n\n            handleRequest: function handleRequest(xhr) {\n                if (xhr.async) {\n                    if (!this.queue) {\n                        this.queue = [];\n                    }\n\n                    push.call(this.queue, xhr);\n                } else {\n                    this.processRequest(xhr);\n                }\n            },\n\n            log: function log(response, request) {\n                var str;\n\n                str = \"Request:\\n\" + sinon.format(request) + \"\\n\\n\";\n                str += \"Response:\\n\" + sinon.format(response) + \"\\n\\n\";\n\n                sinon.log(str);\n            },\n\n            respondWith: function respondWith(method, url, body) {\n                if (arguments.length === 1 && typeof method !== \"function\") {\n                    this.response = responseArray(method);\n                    return;\n                }\n\n                if (!this.responses) {\n                    this.responses = [];\n                }\n\n                if (arguments.length === 1) {\n                    body = method;\n                    url = method = null;\n                }\n\n                if (arguments.length === 2) {\n                    body = url;\n                    url = method;\n                    method = null;\n                }\n\n                push.call(this.responses, {\n                    method: method,\n                    url: url,\n                    response: typeof body === \"function\" ? body : responseArray(body)\n                });\n            },\n\n            respond: function respond() {\n                if (arguments.length > 0) {\n                    this.respondWith.apply(this, arguments);\n                }\n\n                var queue = this.queue || [];\n                var requests = queue.splice(0, queue.length);\n\n                for (var i = 0; i < requests.length; i++) {\n                    this.processRequest(requests[i]);\n                }\n            },\n\n            processRequest: function processRequest(request) {\n                try {\n                    if (request.aborted) {\n                        return;\n                    }\n\n                    var response = this.response || [404, {}, \"\"];\n\n                    if (this.responses) {\n                        for (var l = this.responses.length, i = l - 1; i >= 0; i--) {\n                            if (match.call(this, this.responses[i], request)) {\n                                response = this.responses[i].response;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (request.readyState !== 4) {\n                        this.log(response, request);\n\n                        request.respond(response[0], response[1], response[2]);\n                    }\n                } catch (e) {\n                    sinon.logError(\"Fake server request processing\", e);\n                }\n            },\n\n            restore: function restore() {\n                return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);\n            }\n        };\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./core\");\n        require(\"./fake_xdomain_request\");\n        require(\"./fake_xml_http_request\");\n        require(\"../format\");\n        makeApi(sinon);\n        module.exports = sinon;\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n    } else if (isNode) {\n        loadDependencies(require, module.exports, module);\n    } else {\n        makeApi(sinon); // eslint-disable-line no-undef\n    }\n}());\n\n/**\n * @depend fake_server.js\n * @depend fake_timers.js\n */\n/**\n * Add-on for sinon.fakeServer that automatically handles a fake timer along with\n * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery\n * 1.3.x, which does not use xhr object's onreadystatehandler at all - instead,\n * it polls the object for completion with setInterval. Dispite the direct\n * motivation, there is nothing jQuery-specific in this file, so it can be used\n * in any environment where the ajax implementation depends on setInterval or\n * setTimeout.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function () {\n    \n    function makeApi(sinon) {\n        function Server() {}\n        Server.prototype = sinon.fakeServer;\n\n        sinon.fakeServerWithClock = new Server();\n\n        sinon.fakeServerWithClock.addRequest = function addRequest(xhr) {\n            if (xhr.async) {\n                if (typeof setTimeout.clock === \"object\") {\n                    this.clock = setTimeout.clock;\n                } else {\n                    this.clock = sinon.useFakeTimers();\n                    this.resetClock = true;\n                }\n\n                if (!this.longestTimeout) {\n                    var clockSetTimeout = this.clock.setTimeout;\n                    var clockSetInterval = this.clock.setInterval;\n                    var server = this;\n\n                    this.clock.setTimeout = function (fn, timeout) {\n                        server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n\n                        return clockSetTimeout.apply(this, arguments);\n                    };\n\n                    this.clock.setInterval = function (fn, timeout) {\n                        server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n\n                        return clockSetInterval.apply(this, arguments);\n                    };\n                }\n            }\n\n            return sinon.fakeServer.addRequest.call(this, xhr);\n        };\n\n        sinon.fakeServerWithClock.respond = function respond() {\n            var returnVal = sinon.fakeServer.respond.apply(this, arguments);\n\n            if (this.clock) {\n                this.clock.tick(this.longestTimeout || 0);\n                this.longestTimeout = 0;\n\n                if (this.resetClock) {\n                    this.clock.restore();\n                    this.resetClock = false;\n                }\n            }\n\n            return returnVal;\n        };\n\n        sinon.fakeServerWithClock.restore = function restore() {\n            if (this.clock) {\n                this.clock.restore();\n            }\n\n            return sinon.fakeServer.restore.apply(this, arguments);\n        };\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require) {\n        var sinon = require(\"./core\");\n        require(\"./fake_server\");\n        require(\"./fake_timers\");\n        makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n    } else if (isNode) {\n        loadDependencies(require);\n    } else {\n        makeApi(sinon); // eslint-disable-line no-undef\n    }\n}());\n\n/**\n * @depend util/core.js\n * @depend extend.js\n * @depend collection.js\n * @depend util/fake_timers.js\n * @depend util/fake_server_with_clock.js\n */\n/**\n * Manages fake collections as well as fake utilities such as Sinon's\n * timers and fake XHR implementation in one convenient object.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n        var push = [].push;\n\n        function exposeValue(sandbox, config, key, value) {\n            if (!value) {\n                return;\n            }\n\n            if (config.injectInto && !(key in config.injectInto)) {\n                config.injectInto[key] = value;\n                sandbox.injectedKeys.push(key);\n            } else {\n                push.call(sandbox.args, value);\n            }\n        }\n\n        function prepareSandboxFromConfig(config) {\n            var sandbox = sinon.create(sinon.sandbox);\n\n            if (config.useFakeServer) {\n                if (typeof config.useFakeServer === \"object\") {\n                    sandbox.serverPrototype = config.useFakeServer;\n                }\n\n                sandbox.useFakeServer();\n            }\n\n            if (config.useFakeTimers) {\n                if (typeof config.useFakeTimers === \"object\") {\n                    sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);\n                } else {\n                    sandbox.useFakeTimers();\n                }\n            }\n\n            return sandbox;\n        }\n\n        sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {\n            useFakeTimers: function useFakeTimers() {\n                this.clock = sinon.useFakeTimers.apply(sinon, arguments);\n\n                return this.add(this.clock);\n            },\n\n            serverPrototype: sinon.fakeServer,\n\n            useFakeServer: function useFakeServer() {\n                var proto = this.serverPrototype || sinon.fakeServer;\n\n                if (!proto || !proto.create) {\n                    return null;\n                }\n\n                this.server = proto.create();\n                return this.add(this.server);\n            },\n\n            inject: function (obj) {\n                sinon.collection.inject.call(this, obj);\n\n                if (this.clock) {\n                    obj.clock = this.clock;\n                }\n\n                if (this.server) {\n                    obj.server = this.server;\n                    obj.requests = this.server.requests;\n                }\n\n                obj.match = sinon.match;\n\n                return obj;\n            },\n\n            restore: function () {\n                sinon.collection.restore.apply(this, arguments);\n                this.restoreContext();\n            },\n\n            restoreContext: function () {\n                if (this.injectedKeys) {\n                    for (var i = 0, j = this.injectedKeys.length; i < j; i++) {\n                        delete this.injectInto[this.injectedKeys[i]];\n                    }\n                    this.injectedKeys = [];\n                }\n            },\n\n            create: function (config) {\n                if (!config) {\n                    return sinon.create(sinon.sandbox);\n                }\n\n                var sandbox = prepareSandboxFromConfig(config);\n                sandbox.args = sandbox.args || [];\n                sandbox.injectedKeys = [];\n                sandbox.injectInto = config.injectInto;\n                var prop,\n                    value;\n                var exposed = sandbox.inject({});\n\n                if (config.properties) {\n                    for (var i = 0, l = config.properties.length; i < l; i++) {\n                        prop = config.properties[i];\n                        value = exposed[prop] || prop === \"sandbox\" && sandbox;\n                        exposeValue(sandbox, config, prop, value);\n                    }\n                } else {\n                    exposeValue(sandbox, config, \"sandbox\", value);\n                }\n\n                return sandbox;\n            },\n\n            match: sinon.match\n        });\n\n        sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;\n\n        return sinon.sandbox;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        require(\"./extend\");\n        require(\"./util/fake_server_with_clock\");\n        require(\"./util/fake_timers\");\n        require(\"./collection\");\n        module.exports = makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend util/core.js\n * @depend sandbox.js\n */\n/**\n * Test function, sandboxes fakes\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    function makeApi(sinon) {\n        var slice = Array.prototype.slice;\n\n        function test(callback) {\n            var type = typeof callback;\n\n            if (type !== \"function\") {\n                throw new TypeError(\"sinon.test needs to wrap a test function, got \" + type);\n            }\n\n            function sinonSandboxedTest() {\n                var config = sinon.getConfig(sinon.config);\n                config.injectInto = config.injectIntoThis && this || config.injectInto;\n                var sandbox = sinon.sandbox.create(config);\n                var args = slice.call(arguments);\n                var oldDone = args.length && args[args.length - 1];\n                var exception, result;\n\n                if (typeof oldDone === \"function\") {\n                    args[args.length - 1] = function sinonDone(res) {\n                        if (res) {\n                            sandbox.restore();\n                        } else {\n                            sandbox.verifyAndRestore();\n                        }\n                        oldDone(res);\n                    };\n                }\n\n                try {\n                    result = callback.apply(this, args.concat(sandbox.args));\n                } catch (e) {\n                    exception = e;\n                }\n\n                if (typeof exception !== \"undefined\") {\n                    sandbox.restore();\n                    throw exception;\n                } else if (typeof oldDone !== \"function\") {\n                    sandbox.verifyAndRestore();\n                }\n\n                return result;\n            }\n\n            if (callback.length) {\n                return function sinonAsyncSandboxedTest(done) { // eslint-disable-line no-unused-vars\n                    return sinonSandboxedTest.apply(this, arguments);\n                };\n            }\n\n            return sinonSandboxedTest;\n        }\n\n        test.config = {\n            injectIntoThis: true,\n            injectInto: null,\n            properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n            useFakeTimers: true,\n            useFakeServer: true\n        };\n\n        sinon.test = test;\n        return test;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var core = require(\"./util/core\");\n        require(\"./sandbox\");\n        module.exports = makeApi(core);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n    } else if (isNode) {\n        loadDependencies(require, module.exports, module);\n    } else if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(typeof sinon === \"object\" && sinon || null)); // eslint-disable-line no-undef\n\n/**\n * @depend util/core.js\n * @depend test.js\n */\n/**\n * Test case, sandboxes all test functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal) {\n    \n    function createTest(property, setUp, tearDown) {\n        return function () {\n            if (setUp) {\n                setUp.apply(this, arguments);\n            }\n\n            var exception, result;\n\n            try {\n                result = property.apply(this, arguments);\n            } catch (e) {\n                exception = e;\n            }\n\n            if (tearDown) {\n                tearDown.apply(this, arguments);\n            }\n\n            if (exception) {\n                throw exception;\n            }\n\n            return result;\n        };\n    }\n\n    function makeApi(sinon) {\n        function testCase(tests, prefix) {\n            if (!tests || typeof tests !== \"object\") {\n                throw new TypeError(\"sinon.testCase needs an object with test functions\");\n            }\n\n            prefix = prefix || \"test\";\n            var rPrefix = new RegExp(\"^\" + prefix);\n            var methods = {};\n            var setUp = tests.setUp;\n            var tearDown = tests.tearDown;\n            var testName,\n                property,\n                method;\n\n            for (testName in tests) {\n                if (tests.hasOwnProperty(testName) && !/^(setUp|tearDown)$/.test(testName)) {\n                    property = tests[testName];\n\n                    if (typeof property === \"function\" && rPrefix.test(testName)) {\n                        method = property;\n\n                        if (setUp || tearDown) {\n                            method = createTest(property, setUp, tearDown);\n                        }\n\n                        methods[testName] = sinon.test(method);\n                    } else {\n                        methods[testName] = tests[testName];\n                    }\n                }\n            }\n\n            return methods;\n        }\n\n        sinon.testCase = testCase;\n        return testCase;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var core = require(\"./util/core\");\n        require(\"./test\");\n        module.exports = makeApi(core);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon // eslint-disable-line no-undef\n));\n\n/**\n * @depend times_in_words.js\n * @depend util/core.js\n * @depend match.js\n * @depend format.js\n */\n/**\n * Assertions matching the test spy retrieval interface.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2013 Christian Johansen\n */\n(function (sinonGlobal, global) {\n    \n    var slice = Array.prototype.slice;\n\n    function makeApi(sinon) {\n        var assert;\n\n        function verifyIsStub() {\n            var method;\n\n            for (var i = 0, l = arguments.length; i < l; ++i) {\n                method = arguments[i];\n\n                if (!method) {\n                    assert.fail(\"fake is not a spy\");\n                }\n\n                if (method.proxy && method.proxy.isSinonProxy) {\n                    verifyIsStub(method.proxy);\n                } else {\n                    if (typeof method !== \"function\") {\n                        assert.fail(method + \" is not a function\");\n                    }\n\n                    if (typeof method.getCall !== \"function\") {\n                        assert.fail(method + \" is not stubbed\");\n                    }\n                }\n\n            }\n        }\n\n        function verifyIsValidAssertion(assertionMethod, assertionArgs) {\n            switch (assertionMethod) {\n                case \"notCalled\":\n                case \"called\":\n                case \"calledOnce\":\n                case \"calledTwice\":\n                case \"calledThrice\":\n                    if (assertionArgs.length !== 0) {\n                        assert.fail(assertionMethod +\n                                    \" takes 1 argument but was called with \" +\n                                    (assertionArgs.length + 1) + \" arguments\");\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        function failAssertion(object, msg) {\n            object = object || global;\n            var failMethod = object.fail || assert.fail;\n            failMethod.call(object, msg);\n        }\n\n        function mirrorPropAsAssertion(name, method, message) {\n            if (arguments.length === 2) {\n                message = method;\n                method = name;\n            }\n\n            assert[name] = function (fake) {\n                verifyIsStub(fake);\n\n                var args = slice.call(arguments, 1);\n                verifyIsValidAssertion(name, args);\n\n                var failed = false;\n\n                if (typeof method === \"function\") {\n                    failed = !method(fake);\n                } else {\n                    failed = typeof fake[method] === \"function\" ?\n                        !fake[method].apply(fake, args) : !fake[method];\n                }\n\n                if (failed) {\n                    failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));\n                } else {\n                    assert.pass(name);\n                }\n            };\n        }\n\n        function exposedName(prefix, prop) {\n            return !prefix || /^fail/.test(prop) ? prop :\n                prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);\n        }\n\n        assert = {\n            failException: \"AssertError\",\n\n            fail: function fail(message) {\n                var error = new Error(message);\n                error.name = this.failException || assert.failException;\n\n                throw error;\n            },\n\n            pass: function pass() {},\n\n            callOrder: function assertCallOrder() {\n                verifyIsStub.apply(null, arguments);\n                var expected = \"\";\n                var actual = \"\";\n\n                if (!sinon.calledInOrder(arguments)) {\n                    try {\n                        expected = [].join.call(arguments, \", \");\n                        var calls = slice.call(arguments);\n                        var i = calls.length;\n                        while (i) {\n                            if (!calls[--i].called) {\n                                calls.splice(i, 1);\n                            }\n                        }\n                        actual = sinon.orderByFirstCall(calls).join(\", \");\n                    } catch (e) {\n                        // If this fails, we'll just fall back to the blank string\n                    }\n\n                    failAssertion(this, \"expected \" + expected + \" to be \" +\n                                \"called in order but were called as \" + actual);\n                } else {\n                    assert.pass(\"callOrder\");\n                }\n            },\n\n            callCount: function assertCallCount(method, count) {\n                verifyIsStub(method);\n\n                if (method.callCount !== count) {\n                    var msg = \"expected %n to be called \" + sinon.timesInWords(count) +\n                        \" but was called %c%C\";\n                    failAssertion(this, method.printf(msg));\n                } else {\n                    assert.pass(\"callCount\");\n                }\n            },\n\n            expose: function expose(target, options) {\n                if (!target) {\n                    throw new TypeError(\"target is null or undefined\");\n                }\n\n                var o = options || {};\n                var prefix = typeof o.prefix === \"undefined\" && \"assert\" || o.prefix;\n                var includeFail = typeof o.includeFail === \"undefined\" || !!o.includeFail;\n\n                for (var method in this) {\n                    if (method !== \"expose\" && (includeFail || !/^(fail)/.test(method))) {\n                        target[exposedName(prefix, method)] = this[method];\n                    }\n                }\n\n                return target;\n            },\n\n            match: function match(actual, expectation) {\n                var matcher = sinon.match(expectation);\n                if (matcher.test(actual)) {\n                    assert.pass(\"match\");\n                } else {\n                    var formatted = [\n                        \"expected value to match\",\n                        \"    expected = \" + sinon.format(expectation),\n                        \"    actual = \" + sinon.format(actual)\n                    ];\n\n                    failAssertion(this, formatted.join(\"\\n\"));\n                }\n            }\n        };\n\n        mirrorPropAsAssertion(\"called\", \"expected %n to have been called at least once but was never called\");\n        mirrorPropAsAssertion(\"notCalled\", function (spy) {\n            return !spy.called;\n        }, \"expected %n to not have been called but was called %c%C\");\n        mirrorPropAsAssertion(\"calledOnce\", \"expected %n to be called once but was called %c%C\");\n        mirrorPropAsAssertion(\"calledTwice\", \"expected %n to be called twice but was called %c%C\");\n        mirrorPropAsAssertion(\"calledThrice\", \"expected %n to be called thrice but was called %c%C\");\n        mirrorPropAsAssertion(\"calledOn\", \"expected %n to be called with %1 as this but was called with %t\");\n        mirrorPropAsAssertion(\n            \"alwaysCalledOn\",\n            \"expected %n to always be called with %1 as this but was called with %t\"\n        );\n        mirrorPropAsAssertion(\"calledWithNew\", \"expected %n to be called with new\");\n        mirrorPropAsAssertion(\"alwaysCalledWithNew\", \"expected %n to always be called with new\");\n        mirrorPropAsAssertion(\"calledWith\", \"expected %n to be called with arguments %*%C\");\n        mirrorPropAsAssertion(\"calledWithMatch\", \"expected %n to be called with match %*%C\");\n        mirrorPropAsAssertion(\"alwaysCalledWith\", \"expected %n to always be called with arguments %*%C\");\n        mirrorPropAsAssertion(\"alwaysCalledWithMatch\", \"expected %n to always be called with match %*%C\");\n        mirrorPropAsAssertion(\"calledWithExactly\", \"expected %n to be called with exact arguments %*%C\");\n        mirrorPropAsAssertion(\"alwaysCalledWithExactly\", \"expected %n to always be called with exact arguments %*%C\");\n        mirrorPropAsAssertion(\"neverCalledWith\", \"expected %n to never be called with arguments %*%C\");\n        mirrorPropAsAssertion(\"neverCalledWithMatch\", \"expected %n to never be called with match %*%C\");\n        mirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\n        mirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\n\n        sinon.assert = assert;\n        return assert;\n    }\n\n    var isNode = typeof module !== \"undefined\" && module.exports && typeof require === \"function\";\n    var isAMD = typeof define === \"function\" && typeof define.amd === \"object\" && define.amd;\n\n    function loadDependencies(require, exports, module) {\n        var sinon = require(\"./util/core\");\n        require(\"./match\");\n        require(\"./format\");\n        module.exports = makeApi(sinon);\n    }\n\n    if (isAMD) {\n        define(loadDependencies);\n        return;\n    }\n\n    if (isNode) {\n        loadDependencies(require, module.exports, module);\n        return;\n    }\n\n    if (sinonGlobal) {\n        makeApi(sinonGlobal);\n    }\n}(\n    typeof sinon === \"object\" && sinon, // eslint-disable-line no-undef\n    typeof global !== \"undefined\" ? global : self\n));\n\n  return sinon;\n}));\n","/* globals define, sinon */\n\ndefine('sinon', [], function() {\n  \"use strict\";\n\n  return {\n    'default': sinon\n  };\n});\n","define('ember-cli-test-loader/test-support/index', ['exports'], function (exports) {\n  /* globals requirejs, require */\n  \"use strict\";\n\n  exports.addModuleIncludeMatcher = addModuleIncludeMatcher;\n  exports.addModuleExcludeMatcher = addModuleExcludeMatcher;\n  exports['default'] = TestLoader;\n  var moduleIncludeMatchers = [];\n  var moduleExcludeMatchers = [];\n\n  function addModuleIncludeMatcher(fn) {\n    moduleIncludeMatchers.push(fn);\n  }\n\n  ;\n\n  function addModuleExcludeMatcher(fn) {\n    moduleExcludeMatchers.push(fn);\n  }\n\n  ;\n\n  function checkMatchers(matchers, moduleName) {\n    var matcher;\n\n    for (var i = 0, l = matchers.length; i < l; i++) {\n      matcher = matchers[i];\n\n      if (matcher(moduleName)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function TestLoader() {\n    this._didLogMissingUnsee = false;\n  }\n\n  ;\n\n  TestLoader.prototype = {\n    shouldLoadModule: function shouldLoadModule(moduleName) {\n      return moduleName.match(/[-_]test$/);\n    },\n\n    listModules: function listModules() {\n      return Object.keys(requirejs.entries);\n    },\n\n    listTestModules: function listTestModules() {\n      var moduleNames = this.listModules();\n      var testModules = [];\n      var moduleName;\n\n      for (var i = 0; i < moduleNames.length; i++) {\n        moduleName = moduleNames[i];\n\n        if (checkMatchers(moduleExcludeMatchers, moduleName)) {\n          continue;\n        }\n\n        if (checkMatchers(moduleIncludeMatchers, moduleName) || this.shouldLoadModule(moduleName)) {\n          testModules.push(moduleName);\n        }\n      }\n\n      return testModules;\n    },\n\n    loadModules: function loadModules() {\n      var testModules = this.listTestModules();\n      var testModule;\n\n      for (var i = 0; i < testModules.length; i++) {\n        testModule = testModules[i];\n        this.require(testModule);\n        this.unsee(testModule);\n      }\n    }\n  };\n\n  TestLoader.prototype.require = function (moduleName) {\n    try {\n      require(moduleName);\n    } catch (e) {\n      this.moduleLoadFailure(moduleName, e);\n    }\n  };\n\n  TestLoader.prototype.unsee = function (moduleName) {\n    if (typeof require.unsee === 'function') {\n      require.unsee(moduleName);\n    } else if (!this._didLogMissingUnsee) {\n      this._didLogMissingUnsee = true;\n      if (typeof console !== 'undefined') {\n        console.warn('unable to require.unsee, please upgrade loader.js to >= v3.3.0');\n      }\n    }\n  };\n\n  TestLoader.prototype.moduleLoadFailure = function (moduleName, error) {\n    console.error('Error loading: ' + moduleName, error.stack);\n  };\n\n  TestLoader.load = function () {\n    new TestLoader().loadModules();\n  };\n});","define('ember-qunit', ['exports', 'ember-qunit/module-for', 'ember-qunit/module-for-component', 'ember-qunit/module-for-model', 'ember-qunit/adapter', 'ember-test-helpers', 'qunit'], function (exports, _emberQunitModuleFor, _emberQunitModuleForComponent, _emberQunitModuleForModel, _emberQunitAdapter, _emberTestHelpers, _qunit) {\n  'use strict';\n\n  Object.defineProperty(exports, 'test', {\n    enumerable: true,\n    get: function get() {\n      return _qunit.test;\n    }\n  });\n  Object.defineProperty(exports, 'skip', {\n    enumerable: true,\n    get: function get() {\n      return _qunit.skip;\n    }\n  });\n  Object.defineProperty(exports, 'only', {\n    enumerable: true,\n    get: function get() {\n      return _qunit.only;\n    }\n  });\n  exports.moduleFor = _emberQunitModuleFor['default'];\n  exports.moduleForComponent = _emberQunitModuleForComponent['default'];\n  exports.moduleForModel = _emberQunitModuleForModel['default'];\n  exports.setResolver = _emberTestHelpers.setResolver;\n  exports.QUnitAdapter = _emberQunitAdapter['default'];\n});","define('ember-qunit/adapter', ['exports', 'ember', 'qunit'], function (exports, _ember, _qunit) {\n  'use strict';\n\n  exports['default'] = _ember['default'].Test.Adapter.extend({\n    init: function init() {\n      this.doneCallbacks = [];\n    },\n\n    asyncStart: function asyncStart() {\n      this.doneCallbacks.push(_qunit['default'].config.current.assert.async());\n    },\n\n    asyncEnd: function asyncEnd() {\n      this.doneCallbacks.pop()();\n    },\n\n    exception: function exception(error) {\n      _qunit['default'].config.current.assert.ok(false, _ember['default'].inspect(error));\n    }\n  });\n});","define('ember-qunit/module-for-component', ['exports', 'ember-qunit/qunit-module', 'ember-test-helpers'], function (exports, _emberQunitQunitModule, _emberTestHelpers) {\n  'use strict';\n\n  exports['default'] = moduleForComponent;\n\n  function moduleForComponent(name, description, callbacks) {\n    (0, _emberQunitQunitModule.createModule)(_emberTestHelpers.TestModuleForComponent, name, description, callbacks);\n  }\n});","define('ember-qunit/module-for-model', ['exports', 'ember-qunit/qunit-module', 'ember-test-helpers'], function (exports, _emberQunitQunitModule, _emberTestHelpers) {\n  'use strict';\n\n  exports['default'] = moduleForModel;\n\n  function moduleForModel(name, description, callbacks) {\n    (0, _emberQunitQunitModule.createModule)(_emberTestHelpers.TestModuleForModel, name, description, callbacks);\n  }\n});","define('ember-qunit/module-for', ['exports', 'ember-qunit/qunit-module', 'ember-test-helpers'], function (exports, _emberQunitQunitModule, _emberTestHelpers) {\n  'use strict';\n\n  exports['default'] = moduleFor;\n\n  function moduleFor(name, description, callbacks) {\n    (0, _emberQunitQunitModule.createModule)(_emberTestHelpers.TestModule, name, description, callbacks);\n  }\n});","define('ember-qunit/qunit-module', ['exports', 'ember', 'qunit'], function (exports, _ember, _qunit) {\n  'use strict';\n\n  exports.createModule = createModule;\n\n  function beforeEachCallback(callbacks) {\n    if (typeof callbacks !== 'object') {\n      return;\n    }\n    if (!callbacks) {\n      return;\n    }\n\n    var beforeEach;\n\n    if (callbacks.beforeEach) {\n      beforeEach = callbacks.beforeEach;\n      delete callbacks.beforeEach;\n    }\n\n    return beforeEach;\n  }\n\n  function afterEachCallback(callbacks) {\n    if (typeof callbacks !== 'object') {\n      return;\n    }\n    if (!callbacks) {\n      return;\n    }\n\n    var afterEach;\n\n    if (callbacks.afterEach) {\n      afterEach = callbacks.afterEach;\n      delete callbacks.afterEach;\n    }\n\n    return afterEach;\n  }\n\n  function createModule(Constructor, name, description, callbacks) {\n    var _beforeEach = beforeEachCallback(callbacks || description);\n    var _afterEach = afterEachCallback(callbacks || description);\n\n    var module = new Constructor(name, description, callbacks);\n\n    (0, _qunit.module)(module.name, {\n      beforeEach: function beforeEach() {\n        var _this = this,\n            _arguments = arguments;\n\n        // provide the test context to the underlying module\n        module.setContext(this);\n\n        return module.setup.apply(module, arguments).then(function () {\n          if (_beforeEach) {\n            return _beforeEach.apply(_this, _arguments);\n          }\n        });\n      },\n\n      afterEach: function afterEach() {\n        var _arguments2 = arguments;\n\n        var result = undefined;\n\n        if (_afterEach) {\n          result = _afterEach.apply(this, arguments);\n        }\n\n        return _ember['default'].RSVP.resolve(result).then(function () {\n          return module.teardown.apply(module, _arguments2);\n        });\n      }\n    });\n  }\n});","define('ember-test-helpers', ['exports', 'ember', 'ember-test-helpers/test-module', 'ember-test-helpers/test-module-for-acceptance', 'ember-test-helpers/test-module-for-integration', 'ember-test-helpers/test-module-for-component', 'ember-test-helpers/test-module-for-model', 'ember-test-helpers/test-context', 'ember-test-helpers/test-resolver'], function (exports, _ember, _emberTestHelpersTestModule, _emberTestHelpersTestModuleForAcceptance, _emberTestHelpersTestModuleForIntegration, _emberTestHelpersTestModuleForComponent, _emberTestHelpersTestModuleForModel, _emberTestHelpersTestContext, _emberTestHelpersTestResolver) {\n  'use strict';\n\n  _ember['default'].testing = true;\n\n  exports.TestModule = _emberTestHelpersTestModule['default'];\n  exports.TestModuleForAcceptance = _emberTestHelpersTestModuleForAcceptance['default'];\n  exports.TestModuleForIntegration = _emberTestHelpersTestModuleForIntegration['default'];\n  exports.TestModuleForComponent = _emberTestHelpersTestModuleForComponent['default'];\n  exports.TestModuleForModel = _emberTestHelpersTestModuleForModel['default'];\n  exports.getContext = _emberTestHelpersTestContext.getContext;\n  exports.setContext = _emberTestHelpersTestContext.setContext;\n  exports.unsetContext = _emberTestHelpersTestContext.unsetContext;\n  exports.setResolver = _emberTestHelpersTestResolver.setResolver;\n});","define('ember-test-helpers/-legacy-overrides', ['exports', 'ember', 'ember-test-helpers/has-ember-version'], function (exports, _ember, _emberTestHelpersHasEmberVersion) {\n  'use strict';\n\n  exports.preGlimmerSetupIntegrationForComponent = preGlimmerSetupIntegrationForComponent;\n\n  function preGlimmerSetupIntegrationForComponent() {\n    var module = this;\n    var context = this.context;\n\n    this.actionHooks = {};\n\n    context.dispatcher = this.container.lookup('event_dispatcher:main') || _ember['default'].EventDispatcher.create();\n    context.dispatcher.setup({}, '#ember-testing');\n    context.actions = module.actionHooks;\n\n    (this.registry || this.container).register('component:-test-holder', _ember['default'].Component.extend());\n\n    context.render = function (template) {\n      // in case `this.render` is called twice, make sure to teardown the first invocation\n      module.teardownComponent();\n\n      if (!template) {\n        throw new Error(\"in a component integration test you must pass a template to `render()`\");\n      }\n      if (_ember['default'].isArray(template)) {\n        template = template.join('');\n      }\n      if (typeof template === 'string') {\n        template = _ember['default'].Handlebars.compile(template);\n      }\n      module.component = module.container.lookupFactory('component:-test-holder').create({\n        layout: template\n      });\n\n      module.component.set('context', context);\n      module.component.set('controller', context);\n\n      _ember['default'].run(function () {\n        module.component.appendTo('#ember-testing');\n      });\n\n      context._element = module.component.element;\n    };\n\n    context.$ = function () {\n      return module.component.$.apply(module.component, arguments);\n    };\n\n    context.set = function (key, value) {\n      var ret = _ember['default'].run(function () {\n        return _ember['default'].set(context, key, value);\n      });\n\n      if ((0, _emberTestHelpersHasEmberVersion['default'])(2, 0)) {\n        return ret;\n      }\n    };\n\n    context.setProperties = function (hash) {\n      var ret = _ember['default'].run(function () {\n        return _ember['default'].setProperties(context, hash);\n      });\n\n      if ((0, _emberTestHelpersHasEmberVersion['default'])(2, 0)) {\n        return ret;\n      }\n    };\n\n    context.get = function (key) {\n      return _ember['default'].get(context, key);\n    };\n\n    context.getProperties = function () {\n      var args = Array.prototype.slice.call(arguments);\n      return _ember['default'].getProperties(context, args);\n    };\n\n    context.on = function (actionName, handler) {\n      module.actionHooks[actionName] = handler;\n    };\n\n    context.send = function (actionName) {\n      var hook = module.actionHooks[actionName];\n      if (!hook) {\n        throw new Error(\"integration testing template received unexpected action \" + actionName);\n      }\n      hook.apply(module, Array.prototype.slice.call(arguments, 1));\n    };\n\n    context.clearRender = function () {\n      module.teardownComponent();\n    };\n  }\n});","define('ember-test-helpers/abstract-test-module', ['exports', 'klassy', 'ember-test-helpers/wait', 'ember-test-helpers/test-context', 'ember'], function (exports, _klassy, _emberTestHelpersWait, _emberTestHelpersTestContext, _ember) {\n  'use strict';\n\n  // calling this `merge` here because we cannot\n  // actually assume it is like `Object.assign`\n  // with > 2 args\n  var merge = _ember['default'].assign || _ember['default'].merge;\n\n  exports['default'] = _klassy.Klass.extend({\n    init: function init(name, options) {\n      this.context = undefined;\n      this.name = name;\n      this.callbacks = options || {};\n\n      this.initSetupSteps();\n      this.initTeardownSteps();\n    },\n\n    setup: function setup(assert) {\n      var _this = this;\n\n      return this.invokeSteps(this.setupSteps, this, assert).then(function () {\n        _this.contextualizeCallbacks();\n        return _this.invokeSteps(_this.contextualizedSetupSteps, _this.context, assert);\n      });\n    },\n\n    teardown: function teardown(assert) {\n      var _this2 = this;\n\n      return this.invokeSteps(this.contextualizedTeardownSteps, this.context, assert).then(function () {\n        return _this2.invokeSteps(_this2.teardownSteps, _this2, assert);\n      }).then(function () {\n        _this2.cache = null;\n        _this2.cachedCalls = null;\n      });\n    },\n\n    initSetupSteps: function initSetupSteps() {\n      this.setupSteps = [];\n      this.contextualizedSetupSteps = [];\n\n      if (this.callbacks.beforeSetup) {\n        this.setupSteps.push(this.callbacks.beforeSetup);\n        delete this.callbacks.beforeSetup;\n      }\n\n      this.setupSteps.push(this.setupContext);\n      this.setupSteps.push(this.setupTestElements);\n      this.setupSteps.push(this.setupAJAXListeners);\n\n      if (this.callbacks.setup) {\n        this.contextualizedSetupSteps.push(this.callbacks.setup);\n        delete this.callbacks.setup;\n      }\n    },\n\n    invokeSteps: function invokeSteps(steps, context, assert) {\n      steps = steps.slice();\n\n      function nextStep() {\n        var step = steps.shift();\n        if (step) {\n          // guard against exceptions, for example missing components referenced from needs.\n          return new _ember['default'].RSVP.Promise(function (resolve) {\n            resolve(step.call(context, assert));\n          }).then(nextStep);\n        } else {\n          return _ember['default'].RSVP.resolve();\n        }\n      }\n      return nextStep();\n    },\n\n    contextualizeCallbacks: function contextualizeCallbacks() {},\n\n    initTeardownSteps: function initTeardownSteps() {\n      this.teardownSteps = [];\n      this.contextualizedTeardownSteps = [];\n\n      if (this.callbacks.teardown) {\n        this.contextualizedTeardownSteps.push(this.callbacks.teardown);\n        delete this.callbacks.teardown;\n      }\n\n      this.teardownSteps.push(this.teardownContext);\n      this.teardownSteps.push(this.teardownTestElements);\n      this.teardownSteps.push(this.teardownAJAXListeners);\n\n      if (this.callbacks.afterTeardown) {\n        this.teardownSteps.push(this.callbacks.afterTeardown);\n        delete this.callbacks.afterTeardown;\n      }\n    },\n\n    setupTestElements: function setupTestElements() {\n      if (!document.querySelector('#ember-testing')) {\n        var element = document.createElement('div');\n        element.setAttribute('id', 'ember-testing');\n\n        document.body.appendChild(element);\n      }\n    },\n\n    setupContext: function setupContext(options) {\n      var context = this.getContext();\n\n      merge(context, {\n        dispatcher: null,\n        inject: {}\n      });\n      merge(context, options);\n\n      (0, _emberTestHelpersTestContext.setContext)(context);\n      this.context = context;\n    },\n\n    setContext: function setContext(context) {\n      this.context = context;\n    },\n\n    getContext: function getContext() {\n      if (this.context) {\n        return this.context;\n      }\n\n      return this.context = (0, _emberTestHelpersTestContext.getContext)() || {};\n    },\n\n    setupAJAXListeners: function setupAJAXListeners() {\n      (0, _emberTestHelpersWait._setupAJAXHooks)();\n    },\n\n    teardownAJAXListeners: function teardownAJAXListeners() {\n      (0, _emberTestHelpersWait._teardownAJAXHooks)();\n    },\n\n    teardownTestElements: function teardownTestElements() {\n      document.getElementById('ember-testing').innerHTML = '';\n\n      // Ember 2.0.0 removed Ember.View as public API, so only do this when\n      // Ember.View is present\n      if (_ember['default'].View && _ember['default'].View.views) {\n        _ember['default'].View.views = {};\n      }\n    },\n\n    teardownContext: function teardownContext() {\n      var context = this.context;\n      this.context = undefined;\n      (0, _emberTestHelpersTestContext.unsetContext)();\n\n      if (context && context.dispatcher && !context.dispatcher.isDestroyed) {\n        _ember['default'].run(function () {\n          context.dispatcher.destroy();\n        });\n      }\n    }\n  });\n});","define('ember-test-helpers/build-registry', ['exports', 'ember'], function (exports, _ember) {\n  /* globals global, self, requirejs, require */\n\n  'use strict';\n\n  function exposeRegistryMethodsWithoutDeprecations(container) {\n    var methods = ['register', 'unregister', 'resolve', 'normalize', 'typeInjection', 'injection', 'factoryInjection', 'factoryTypeInjection', 'has', 'options', 'optionsForType'];\n\n    function exposeRegistryMethod(container, method) {\n      if (method in container) {\n        container[method] = function () {\n          return container._registry[method].apply(container._registry, arguments);\n        };\n      }\n    }\n\n    for (var i = 0, l = methods.length; i < l; i++) {\n      exposeRegistryMethod(container, methods[i]);\n    }\n  }\n\n  var Owner = (function () {\n    if (_ember['default']._RegistryProxyMixin && _ember['default']._ContainerProxyMixin) {\n      return _ember['default'].Object.extend(_ember['default']._RegistryProxyMixin, _ember['default']._ContainerProxyMixin);\n    }\n\n    return _ember['default'].Object.extend();\n  })();\n\n  exports['default'] = function (resolver) {\n    var fallbackRegistry, registry, container;\n    var namespace = _ember['default'].Object.create({\n      Resolver: { create: function create() {\n          return resolver;\n        } }\n    });\n\n    function register(name, factory) {\n      var thingToRegisterWith = registry || container;\n\n      if (!container.lookupFactory(name)) {\n        thingToRegisterWith.register(name, factory);\n      }\n    }\n\n    if (_ember['default'].Application.buildRegistry) {\n      fallbackRegistry = _ember['default'].Application.buildRegistry(namespace);\n      fallbackRegistry.register('component-lookup:main', _ember['default'].ComponentLookup);\n\n      registry = new _ember['default'].Registry({\n        fallback: fallbackRegistry\n      });\n\n      if (_ember['default'].ApplicationInstance && _ember['default'].ApplicationInstance.setupRegistry) {\n        _ember['default'].ApplicationInstance.setupRegistry(registry);\n      }\n\n      // these properties are set on the fallback registry by `buildRegistry`\n      // and on the primary registry within the ApplicationInstance constructor\n      // but we need to manually recreate them since ApplicationInstance's are not\n      // exposed externally\n      registry.normalizeFullName = fallbackRegistry.normalizeFullName;\n      registry.makeToString = fallbackRegistry.makeToString;\n      registry.describe = fallbackRegistry.describe;\n\n      var owner = Owner.create({\n        __registry__: registry,\n        __container__: null\n      });\n\n      container = registry.container({ owner: owner });\n      owner.__container__ = container;\n\n      exposeRegistryMethodsWithoutDeprecations(container);\n    } else {\n      container = _ember['default'].Application.buildContainer(namespace);\n      container.register('component-lookup:main', _ember['default'].ComponentLookup);\n    }\n\n    // Ember 1.10.0 did not properly add `view:toplevel` or `view:default`\n    // to the registry in Ember.Application.buildRegistry :(\n    //\n    // Ember 2.0.0 removed Ember.View as public API, so only do this when\n    // Ember.View is present\n    if (_ember['default'].View) {\n      register('view:toplevel', _ember['default'].View.extend());\n    }\n\n    // Ember 2.0.0 removed Ember._MetamorphView from the Ember global, so only\n    // do this when present\n    if (_ember['default']._MetamorphView) {\n      register('view:default', _ember['default']._MetamorphView);\n    }\n\n    var globalContext = typeof global === 'object' && global || self;\n    if (requirejs.entries['ember-data/setup-container']) {\n      // ember-data is a proper ember-cli addon since 2.3; if no 'import\n      // 'ember-data'' is present somewhere in the tests, there is also no `DS`\n      // available on the globalContext and hence ember-data wouldn't be setup\n      // correctly for the tests; that's why we import and call setupContainer\n      // here; also see https://github.com/emberjs/data/issues/4071 for context\n      var setupContainer = require('ember-data/setup-container')['default'];\n      setupContainer(registry || container);\n    } else if (globalContext.DS) {\n      var DS = globalContext.DS;\n      if (DS._setupContainer) {\n        DS._setupContainer(registry || container);\n      } else {\n        register('transform:boolean', DS.BooleanTransform);\n        register('transform:date', DS.DateTransform);\n        register('transform:number', DS.NumberTransform);\n        register('transform:string', DS.StringTransform);\n        register('serializer:-default', DS.JSONSerializer);\n        register('serializer:-rest', DS.RESTSerializer);\n        register('adapter:-rest', DS.RESTAdapter);\n      }\n    }\n\n    return {\n      registry: registry,\n      container: container\n    };\n  };\n});","define('ember-test-helpers/has-ember-version', ['exports', 'ember'], function (exports, _ember) {\n  'use strict';\n\n  exports['default'] = hasEmberVersion;\n\n  function hasEmberVersion(major, minor) {\n    var numbers = _ember['default'].VERSION.split('-')[0].split('.');\n    var actualMajor = parseInt(numbers[0], 10);\n    var actualMinor = parseInt(numbers[1], 10);\n    return actualMajor > major || actualMajor === major && actualMinor >= minor;\n  }\n});","define(\"ember-test-helpers/test-context\", [\"exports\"], function (exports) {\n  \"use strict\";\n\n  exports.setContext = setContext;\n  exports.getContext = getContext;\n  exports.unsetContext = unsetContext;\n  var __test_context__;\n\n  function setContext(context) {\n    __test_context__ = context;\n  }\n\n  function getContext() {\n    return __test_context__;\n  }\n\n  function unsetContext() {\n    __test_context__ = undefined;\n  }\n});","define('ember-test-helpers/test-module-for-acceptance', ['exports', 'ember-test-helpers/abstract-test-module', 'ember', 'ember-test-helpers/test-context'], function (exports, _emberTestHelpersAbstractTestModule, _ember, _emberTestHelpersTestContext) {\n  'use strict';\n\n  exports['default'] = _emberTestHelpersAbstractTestModule['default'].extend({\n    setupContext: function setupContext() {\n      this._super({ application: this.createApplication() });\n    },\n\n    teardownContext: function teardownContext() {\n      _ember['default'].run(function () {\n        (0, _emberTestHelpersTestContext.getContext)().application.destroy();\n      });\n\n      this._super();\n    },\n\n    createApplication: function createApplication() {\n      var _callbacks = this.callbacks;\n      var Application = _callbacks.Application;\n      var config = _callbacks.config;\n\n      var application = undefined;\n\n      _ember['default'].run(function () {\n        application = Application.create(config);\n        application.setupForTesting();\n        application.injectTestHelpers();\n      });\n\n      return application;\n    }\n  });\n});","define('ember-test-helpers/test-module-for-component', ['exports', 'ember-test-helpers/test-module', 'ember', 'ember-test-helpers/has-ember-version', 'ember-test-helpers/-legacy-overrides'], function (exports, _emberTestHelpersTestModule, _ember, _emberTestHelpersHasEmberVersion, _emberTestHelpersLegacyOverrides) {\n  'use strict';\n\n  exports.setupComponentIntegrationTest = setupComponentIntegrationTest;\n\n  var ACTION_KEY = undefined;\n  if ((0, _emberTestHelpersHasEmberVersion['default'])(2, 0)) {\n    ACTION_KEY = 'actions';\n  } else {\n    ACTION_KEY = '_actions';\n  }\n\n  var getOwner = _ember['default'].getOwner;\n  exports['default'] = _emberTestHelpersTestModule['default'].extend({\n    isComponentTestModule: true,\n\n    init: function init(componentName, description, callbacks) {\n      // Allow `description` to be omitted\n      if (!callbacks && typeof description === 'object') {\n        callbacks = description;\n        description = null;\n      } else if (!callbacks) {\n        callbacks = {};\n      }\n\n      this.componentName = componentName;\n\n      if (callbacks.needs || callbacks.unit || callbacks.integration === false) {\n        this.isUnitTest = true;\n      } else if (callbacks.integration) {\n        this.isUnitTest = false;\n      } else {\n        _ember['default'].deprecate(\"the component:\" + componentName + \" test module is implicitly running in unit test mode, \" + \"which will change to integration test mode by default in an upcoming version of \" + \"ember-test-helpers. Add `unit: true` or a `needs:[]` list to explicitly opt in to unit \" + \"test mode.\", false, { id: 'ember-test-helpers.test-module-for-component.test-type', until: '0.6.0' });\n        this.isUnitTest = true;\n      }\n\n      if (description) {\n        this._super.call(this, 'component:' + componentName, description, callbacks);\n      } else {\n        this._super.call(this, 'component:' + componentName, callbacks);\n      }\n\n      if (!this.isUnitTest && !this.isLegacy) {\n        callbacks.integration = true;\n      }\n\n      if (this.isUnitTest || this.isLegacy) {\n        this.setupSteps.push(this.setupComponentUnitTest);\n      } else {\n        this.callbacks.subject = function () {\n          throw new Error(\"component integration tests do not support `subject()`. Instead, render the component as if it were HTML: `this.render('<my-component foo=true>');`. For more information, read: http://guides.emberjs.com/v2.2.0/testing/testing-components/\");\n        };\n        this.setupSteps.push(this.setupComponentIntegrationTest);\n        this.teardownSteps.unshift(this.teardownComponent);\n      }\n\n      if (_ember['default'].View && _ember['default'].View.views) {\n        this.setupSteps.push(this._aliasViewRegistry);\n        this.teardownSteps.unshift(this._resetViewRegistry);\n      }\n    },\n\n    _aliasViewRegistry: function _aliasViewRegistry() {\n      this._originalGlobalViewRegistry = _ember['default'].View.views;\n      var viewRegistry = this.container.lookup('-view-registry:main');\n\n      if (viewRegistry) {\n        _ember['default'].View.views = viewRegistry;\n      }\n    },\n\n    _resetViewRegistry: function _resetViewRegistry() {\n      _ember['default'].View.views = this._originalGlobalViewRegistry;\n    },\n\n    setupComponentUnitTest: function setupComponentUnitTest() {\n      var _this = this;\n      var resolver = this.resolver;\n      var context = this.context;\n\n      var layoutName = 'template:components/' + this.componentName;\n\n      var layout = resolver.resolve(layoutName);\n\n      var thingToRegisterWith = this.registry || this.container;\n      if (layout) {\n        thingToRegisterWith.register(layoutName, layout);\n        thingToRegisterWith.injection(this.subjectName, 'layout', layoutName);\n      }\n\n      context.dispatcher = this.container.lookup('event_dispatcher:main') || _ember['default'].EventDispatcher.create();\n      context.dispatcher.setup({}, '#ember-testing');\n\n      context._element = null;\n\n      this.callbacks.render = function () {\n        var subject;\n\n        _ember['default'].run(function () {\n          subject = context.subject();\n          subject.appendTo('#ember-testing');\n        });\n\n        context._element = subject.element;\n\n        _this.teardownSteps.unshift(function () {\n          _ember['default'].run(function () {\n            _ember['default'].tryInvoke(subject, 'destroy');\n          });\n        });\n      };\n\n      this.callbacks.append = function () {\n        _ember['default'].deprecate('this.append() is deprecated. Please use this.render() or this.$() instead.', false, { id: 'ember-test-helpers.test-module-for-component.append', until: '0.6.0' });\n        return context.$();\n      };\n\n      context.$ = function () {\n        this.render();\n        var subject = this.subject();\n\n        return subject.$.apply(subject, arguments);\n      };\n    },\n\n    setupComponentIntegrationTest: (function () {\n      if (!(0, _emberTestHelpersHasEmberVersion['default'])(1, 13)) {\n        return _emberTestHelpersLegacyOverrides.preGlimmerSetupIntegrationForComponent;\n      } else {\n        return setupComponentIntegrationTest;\n      }\n    })(),\n\n    setupContext: function setupContext() {\n      this._super.call(this);\n\n      // only setup the injection if we are running against a version\n      // of Ember that has `-view-registry:main` (Ember >= 1.12)\n      if (this.container.lookupFactory('-view-registry:main')) {\n        (this.registry || this.container).injection('component', '_viewRegistry', '-view-registry:main');\n      }\n\n      if (!this.isUnitTest && !this.isLegacy) {\n        this.context.factory = function () {};\n      }\n    },\n\n    teardownComponent: function teardownComponent() {\n      var component = this.component;\n      if (component) {\n        _ember['default'].run(component, 'destroy');\n        this.component = null;\n      }\n    }\n  });\n\n  function setupComponentIntegrationTest() {\n    var module = this;\n    var context = this.context;\n\n    this.actionHooks = context[ACTION_KEY] = {};\n    context.dispatcher = this.container.lookup('event_dispatcher:main') || _ember['default'].EventDispatcher.create();\n    context.dispatcher.setup({}, '#ember-testing');\n\n    var hasRendered = false;\n    var OutletView = module.container.lookupFactory('view:-outlet');\n    var OutletTemplate = module.container.lookup('template:-outlet');\n    var toplevelView = module.component = OutletView.create();\n    var hasOutletTemplate = !!OutletTemplate;\n    var outletState = {\n      render: {\n        owner: getOwner ? getOwner(module.container) : undefined,\n        into: undefined,\n        outlet: 'main',\n        name: 'application',\n        controller: module.context,\n        ViewClass: undefined,\n        template: OutletTemplate\n      },\n\n      outlets: {}\n    };\n\n    var element = document.getElementById('ember-testing');\n    var templateId = 0;\n\n    if (hasOutletTemplate) {\n      _ember['default'].run(function () {\n        toplevelView.setOutletState(outletState);\n      });\n    }\n\n    context.render = function (template) {\n      if (!template) {\n        throw new Error(\"in a component integration test you must pass a template to `render()`\");\n      }\n      if (_ember['default'].isArray(template)) {\n        template = template.join('');\n      }\n      if (typeof template === 'string') {\n        template = _ember['default'].Handlebars.compile(template);\n      }\n\n      var templateFullName = 'template:-undertest-' + ++templateId;\n      this.registry.register(templateFullName, template);\n      var stateToRender = {\n        owner: getOwner ? getOwner(module.container) : undefined,\n        into: undefined,\n        outlet: 'main',\n        name: 'index',\n        controller: module.context,\n        ViewClass: undefined,\n        template: module.container.lookup(templateFullName),\n        outlets: {}\n      };\n\n      if (hasOutletTemplate) {\n        stateToRender.name = 'index';\n        outletState.outlets.main = { render: stateToRender, outlets: {} };\n      } else {\n        stateToRender.name = 'application';\n        outletState = { render: stateToRender, outlets: {} };\n      }\n\n      _ember['default'].run(function () {\n        toplevelView.setOutletState(outletState);\n      });\n\n      if (!hasRendered) {\n        _ember['default'].run(module.component, 'appendTo', '#ember-testing');\n        hasRendered = true;\n      }\n\n      // ensure the element is based on the wrapping toplevel view\n      // Ember still wraps the main application template with a\n      // normal tagged view\n      context._element = element = document.querySelector('#ember-testing > .ember-view');\n    };\n\n    context.$ = function (selector) {\n      // emulates Ember internal behavor of `this.$` in a component\n      // https://github.com/emberjs/ember.js/blob/v2.5.1/packages/ember-views/lib/views/states/has_element.js#L18\n      return selector ? _ember['default'].$(selector, element) : _ember['default'].$(element);\n    };\n\n    context.set = function (key, value) {\n      var ret = _ember['default'].run(function () {\n        return _ember['default'].set(context, key, value);\n      });\n\n      if ((0, _emberTestHelpersHasEmberVersion['default'])(2, 0)) {\n        return ret;\n      }\n    };\n\n    context.setProperties = function (hash) {\n      var ret = _ember['default'].run(function () {\n        return _ember['default'].setProperties(context, hash);\n      });\n\n      if ((0, _emberTestHelpersHasEmberVersion['default'])(2, 0)) {\n        return ret;\n      }\n    };\n\n    context.get = function (key) {\n      return _ember['default'].get(context, key);\n    };\n\n    context.getProperties = function () {\n      var args = Array.prototype.slice.call(arguments);\n      return _ember['default'].getProperties(context, args);\n    };\n\n    context.on = function (actionName, handler) {\n      module.actionHooks[actionName] = handler;\n    };\n\n    context.send = function (actionName) {\n      var hook = module.actionHooks[actionName];\n      if (!hook) {\n        throw new Error(\"integration testing template received unexpected action \" + actionName);\n      }\n      hook.apply(module.context, Array.prototype.slice.call(arguments, 1));\n    };\n\n    context.clearRender = function () {\n      _ember['default'].run(function () {\n        toplevelView.setOutletState({\n          render: {\n            owner: module.container,\n            into: undefined,\n            outlet: 'main',\n            name: 'application',\n            controller: module.context,\n            ViewClass: undefined,\n            template: undefined\n          },\n          outlets: {}\n        });\n      });\n    };\n  }\n});","define('ember-test-helpers/test-module-for-integration', ['exports', 'ember', 'ember-test-helpers/abstract-test-module', 'ember-test-helpers/test-resolver', 'ember-test-helpers/build-registry', 'ember-test-helpers/has-ember-version', 'ember-test-helpers/-legacy-overrides', 'ember-test-helpers/test-module-for-component'], function (exports, _ember, _emberTestHelpersAbstractTestModule, _emberTestHelpersTestResolver, _emberTestHelpersBuildRegistry, _emberTestHelpersHasEmberVersion, _emberTestHelpersLegacyOverrides, _emberTestHelpersTestModuleForComponent) {\n  'use strict';\n\n  var ACTION_KEY = undefined;\n  if ((0, _emberTestHelpersHasEmberVersion['default'])(2, 0)) {\n    ACTION_KEY = 'actions';\n  } else {\n    ACTION_KEY = '_actions';\n  }\n\n  exports['default'] = _emberTestHelpersAbstractTestModule['default'].extend({\n    init: function init() {\n      this._super.apply(this, arguments);\n      this.resolver = this.callbacks.resolver || (0, _emberTestHelpersTestResolver.getResolver)();\n    },\n\n    initSetupSteps: function initSetupSteps() {\n      this.setupSteps = [];\n      this.contextualizedSetupSteps = [];\n\n      if (this.callbacks.beforeSetup) {\n        this.setupSteps.push(this.callbacks.beforeSetup);\n        delete this.callbacks.beforeSetup;\n      }\n\n      this.setupSteps.push(this.setupContainer);\n      this.setupSteps.push(this.setupContext);\n      this.setupSteps.push(this.setupTestElements);\n      this.setupSteps.push(this.setupAJAXListeners);\n      this.setupSteps.push(this.setupComponentIntegrationTest);\n\n      if (_ember['default'].View && _ember['default'].View.views) {\n        this.setupSteps.push(this._aliasViewRegistry);\n      }\n\n      if (this.callbacks.setup) {\n        this.contextualizedSetupSteps.push(this.callbacks.setup);\n        delete this.callbacks.setup;\n      }\n    },\n\n    initTeardownSteps: function initTeardownSteps() {\n      this.teardownSteps = [];\n      this.contextualizedTeardownSteps = [];\n\n      if (this.callbacks.teardown) {\n        this.contextualizedTeardownSteps.push(this.callbacks.teardown);\n        delete this.callbacks.teardown;\n      }\n\n      this.teardownSteps.push(this.teardownContainer);\n      this.teardownSteps.push(this.teardownContext);\n      this.teardownSteps.push(this.teardownAJAXListeners);\n      this.teardownSteps.push(this.teardownComponent);\n\n      if (_ember['default'].View && _ember['default'].View.views) {\n        this.teardownSteps.push(this._resetViewRegistry);\n      }\n\n      this.teardownSteps.push(this.teardownTestElements);\n\n      if (this.callbacks.afterTeardown) {\n        this.teardownSteps.push(this.callbacks.afterTeardown);\n        delete this.callbacks.afterTeardown;\n      }\n    },\n\n    setupContainer: function setupContainer() {\n      var resolver = this.resolver;\n      var items = (0, _emberTestHelpersBuildRegistry['default'])(resolver);\n\n      this.container = items.container;\n      this.registry = items.registry;\n\n      if ((0, _emberTestHelpersHasEmberVersion['default'])(1, 13)) {\n        var thingToRegisterWith = this.registry || this.container;\n        var router = resolver.resolve('router:main');\n        router = router || _ember['default'].Router.extend();\n        thingToRegisterWith.register('router:main', router);\n      }\n    },\n\n    setupContext: function setupContext() {\n      var subjectName = this.subjectName;\n      var container = this.container;\n\n      var factory = function factory() {\n        return container.lookupFactory(subjectName);\n      };\n\n      this._super({\n        container: this.container,\n        registry: this.registry,\n        factory: factory,\n        register: function register() {\n          var target = this.registry || this.container;\n          return target.register.apply(target, arguments);\n        }\n      });\n\n      var context = this.context;\n\n      if (_ember['default'].setOwner) {\n        _ember['default'].setOwner(context, this.container.owner);\n      }\n\n      if (_ember['default'].inject) {\n        var keys = (Object.keys || _ember['default'].keys)(_ember['default'].inject);\n        keys.forEach(function (typeName) {\n          context.inject[typeName] = function (name, opts) {\n            var alias = opts && opts.as || name;\n            _ember['default'].run(function () {\n              _ember['default'].set(context, alias, context.container.lookup(typeName + ':' + name));\n            });\n          };\n        });\n      }\n\n      // only setup the injection if we are running against a version\n      // of Ember that has `-view-registry:main` (Ember >= 1.12)\n      if (this.container.lookupFactory('-view-registry:main')) {\n        (this.registry || this.container).injection('component', '_viewRegistry', '-view-registry:main');\n      }\n    },\n\n    setupComponentIntegrationTest: (function () {\n      if (!(0, _emberTestHelpersHasEmberVersion['default'])(1, 13)) {\n        return _emberTestHelpersLegacyOverrides.preGlimmerSetupIntegrationForComponent;\n      } else {\n        return _emberTestHelpersTestModuleForComponent.setupComponentIntegrationTest;\n      }\n    })(),\n\n    teardownComponent: function teardownComponent() {\n      var component = this.component;\n      if (component) {\n        _ember['default'].run(function () {\n          component.destroy();\n        });\n      }\n    },\n\n    teardownContainer: function teardownContainer() {\n      var container = this.container;\n      _ember['default'].run(function () {\n        container.destroy();\n      });\n    },\n\n    // allow arbitrary named factories, like rspec let\n    contextualizeCallbacks: function contextualizeCallbacks() {\n      var callbacks = this.callbacks;\n      var context = this.context;\n\n      this.cache = this.cache || {};\n      this.cachedCalls = this.cachedCalls || {};\n\n      var keys = (Object.keys || _ember['default'].keys)(callbacks);\n      var keysLength = keys.length;\n\n      if (keysLength) {\n        for (var i = 0; i < keysLength; i++) {\n          this._contextualizeCallback(context, keys[i], context);\n        }\n      }\n    },\n\n    _contextualizeCallback: function _contextualizeCallback(context, key, callbackContext) {\n      var _this = this;\n      var callbacks = this.callbacks;\n      var factory = context.factory;\n\n      context[key] = function (options) {\n        if (_this.cachedCalls[key]) {\n          return _this.cache[key];\n        }\n\n        var result = callbacks[key].call(callbackContext, options, factory());\n\n        _this.cache[key] = result;\n        _this.cachedCalls[key] = true;\n\n        return result;\n      };\n    },\n\n    _aliasViewRegistry: function _aliasViewRegistry() {\n      this._originalGlobalViewRegistry = _ember['default'].View.views;\n      var viewRegistry = this.container.lookup('-view-registry:main');\n\n      if (viewRegistry) {\n        _ember['default'].View.views = viewRegistry;\n      }\n    },\n\n    _resetViewRegistry: function _resetViewRegistry() {\n      _ember['default'].View.views = this._originalGlobalViewRegistry;\n    }\n  });\n});","define('ember-test-helpers/test-module-for-model', ['exports', 'ember-test-helpers/test-module', 'ember'], function (exports, _emberTestHelpersTestModule, _ember) {\n  /* global DS, require, requirejs */ // added here to prevent an import from erroring when ED is not present\n\n  'use strict';\n\n  exports['default'] = _emberTestHelpersTestModule['default'].extend({\n    init: function init(modelName, description, callbacks) {\n      this.modelName = modelName;\n\n      this._super.call(this, 'model:' + modelName, description, callbacks);\n\n      this.setupSteps.push(this.setupModel);\n    },\n\n    setupModel: function setupModel() {\n      var container = this.container;\n      var defaultSubject = this.defaultSubject;\n      var callbacks = this.callbacks;\n      var modelName = this.modelName;\n\n      var adapterFactory = container.lookupFactory('adapter:application');\n      if (!adapterFactory) {\n        if (requirejs.entries['ember-data/adapters/json-api']) {\n          adapterFactory = require('ember-data/adapters/json-api')['default'];\n        }\n\n        // when ember-data/adapters/json-api is provided via ember-cli shims\n        // using Ember Data 1.x the actual JSONAPIAdapter isn't found, but the\n        // above require statement returns a bizzaro object with only a `default`\n        // property (circular reference actually)\n        if (!adapterFactory || !adapterFactory.create) {\n          adapterFactory = DS.JSONAPIAdapter || DS.FixtureAdapter;\n        }\n\n        var thingToRegisterWith = this.registry || this.container;\n        thingToRegisterWith.register('adapter:application', adapterFactory);\n      }\n\n      callbacks.store = function () {\n        var container = this.container;\n        var store = container.lookup('service:store') || container.lookup('store:main');\n        return store;\n      };\n\n      if (callbacks.subject === defaultSubject) {\n        callbacks.subject = function (options) {\n          var container = this.container;\n\n          return _ember['default'].run(function () {\n            var store = container.lookup('service:store') || container.lookup('store:main');\n            return store.createRecord(modelName, options);\n          });\n        };\n      }\n    }\n  });\n});","define('ember-test-helpers/test-module', ['exports', 'ember', 'ember-test-helpers/abstract-test-module', 'ember-test-helpers/test-resolver', 'ember-test-helpers/build-registry', 'ember-test-helpers/has-ember-version'], function (exports, _ember, _emberTestHelpersAbstractTestModule, _emberTestHelpersTestResolver, _emberTestHelpersBuildRegistry, _emberTestHelpersHasEmberVersion) {\n  'use strict';\n\n  exports['default'] = _emberTestHelpersAbstractTestModule['default'].extend({\n    init: function init(subjectName, description, callbacks) {\n      // Allow `description` to be omitted, in which case it should\n      // default to `subjectName`\n      if (!callbacks && typeof description === 'object') {\n        callbacks = description;\n        description = subjectName;\n      }\n\n      this.subjectName = subjectName;\n      this.description = description || subjectName;\n      this.name = description || subjectName;\n      this.callbacks = callbacks || {};\n      this.resolver = this.callbacks.resolver || (0, _emberTestHelpersTestResolver.getResolver)();\n\n      if (this.callbacks.integration && this.callbacks.needs) {\n        throw new Error(\"cannot declare 'integration: true' and 'needs' in the same module\");\n      }\n\n      if (this.callbacks.integration) {\n        if (this.isComponentTestModule) {\n          this.isLegacy = callbacks.integration === 'legacy';\n          this.isIntegration = callbacks.integration !== 'legacy';\n        } else {\n          if (callbacks.integration === 'legacy') {\n            throw new Error('`integration: \\'legacy\\'` is only valid for component tests.');\n          }\n          this.isIntegration = true;\n        }\n\n        delete callbacks.integration;\n      }\n\n      this.initSubject();\n      this.initNeeds();\n      this.initSetupSteps();\n      this.initTeardownSteps();\n    },\n\n    initSubject: function initSubject() {\n      this.callbacks.subject = this.callbacks.subject || this.defaultSubject;\n    },\n\n    initNeeds: function initNeeds() {\n      this.needs = [this.subjectName];\n      if (this.callbacks.needs) {\n        this.needs = this.needs.concat(this.callbacks.needs);\n        delete this.callbacks.needs;\n      }\n    },\n\n    initSetupSteps: function initSetupSteps() {\n      this.setupSteps = [];\n      this.contextualizedSetupSteps = [];\n\n      if (this.callbacks.beforeSetup) {\n        this.setupSteps.push(this.callbacks.beforeSetup);\n        delete this.callbacks.beforeSetup;\n      }\n\n      this.setupSteps.push(this.setupContainer);\n      this.setupSteps.push(this.setupContext);\n      this.setupSteps.push(this.setupTestElements);\n      this.setupSteps.push(this.setupAJAXListeners);\n\n      if (this.callbacks.setup) {\n        this.contextualizedSetupSteps.push(this.callbacks.setup);\n        delete this.callbacks.setup;\n      }\n    },\n\n    initTeardownSteps: function initTeardownSteps() {\n      this.teardownSteps = [];\n      this.contextualizedTeardownSteps = [];\n\n      if (this.callbacks.teardown) {\n        this.contextualizedTeardownSteps.push(this.callbacks.teardown);\n        delete this.callbacks.teardown;\n      }\n\n      this.teardownSteps.push(this.teardownSubject);\n      this.teardownSteps.push(this.teardownContainer);\n      this.teardownSteps.push(this.teardownContext);\n      this.teardownSteps.push(this.teardownTestElements);\n      this.teardownSteps.push(this.teardownAJAXListeners);\n\n      if (this.callbacks.afterTeardown) {\n        this.teardownSteps.push(this.callbacks.afterTeardown);\n        delete this.callbacks.afterTeardown;\n      }\n    },\n\n    setupContainer: function setupContainer() {\n      if (this.isIntegration || this.isLegacy) {\n        this._setupIntegratedContainer();\n      } else {\n        this._setupIsolatedContainer();\n      }\n    },\n\n    setupContext: function setupContext() {\n      var subjectName = this.subjectName;\n      var container = this.container;\n\n      var factory = function factory() {\n        return container.lookupFactory(subjectName);\n      };\n\n      this._super({\n        container: this.container,\n        registry: this.registry,\n        factory: factory,\n        register: function register() {\n          var target = this.registry || this.container;\n          return target.register.apply(target, arguments);\n        }\n      });\n\n      if (_ember['default'].setOwner) {\n        _ember['default'].setOwner(this.context, this.container.owner);\n      }\n\n      this.setupInject();\n    },\n\n    setupInject: function setupInject() {\n      var module = this;\n      var context = this.context;\n\n      if (_ember['default'].inject) {\n        var keys = (Object.keys || _ember['default'].keys)(_ember['default'].inject);\n\n        keys.forEach(function (typeName) {\n          context.inject[typeName] = function (name, opts) {\n            var alias = opts && opts.as || name;\n            _ember['default'].run(function () {\n              _ember['default'].set(context, alias, module.container.lookup(typeName + ':' + name));\n            });\n          };\n        });\n      }\n    },\n\n    teardownSubject: function teardownSubject() {\n      var subject = this.cache.subject;\n\n      if (subject) {\n        _ember['default'].run(function () {\n          _ember['default'].tryInvoke(subject, 'destroy');\n        });\n      }\n    },\n\n    teardownContainer: function teardownContainer() {\n      var container = this.container;\n      _ember['default'].run(function () {\n        container.destroy();\n      });\n    },\n\n    defaultSubject: function defaultSubject(options, factory) {\n      return factory.create(options);\n    },\n\n    // allow arbitrary named factories, like rspec let\n    contextualizeCallbacks: function contextualizeCallbacks() {\n      var callbacks = this.callbacks;\n      var context = this.context;\n\n      this.cache = this.cache || {};\n      this.cachedCalls = this.cachedCalls || {};\n\n      var keys = (Object.keys || _ember['default'].keys)(callbacks);\n      var keysLength = keys.length;\n\n      if (keysLength) {\n        var deprecatedContext = this._buildDeprecatedContext(this, context);\n        for (var i = 0; i < keysLength; i++) {\n          this._contextualizeCallback(context, keys[i], deprecatedContext);\n        }\n      }\n    },\n\n    _contextualizeCallback: function _contextualizeCallback(context, key, callbackContext) {\n      var _this = this;\n      var callbacks = this.callbacks;\n      var factory = context.factory;\n\n      context[key] = function (options) {\n        if (_this.cachedCalls[key]) {\n          return _this.cache[key];\n        }\n\n        var result = callbacks[key].call(callbackContext, options, factory());\n\n        _this.cache[key] = result;\n        _this.cachedCalls[key] = true;\n\n        return result;\n      };\n    },\n\n    /*\n      Builds a version of the passed in context that contains deprecation warnings\n      for accessing properties that exist on the module.\n    */\n    _buildDeprecatedContext: function _buildDeprecatedContext(module, context) {\n      var deprecatedContext = Object.create(context);\n\n      var keysForDeprecation = Object.keys(module);\n\n      for (var i = 0, l = keysForDeprecation.length; i < l; i++) {\n        this._proxyDeprecation(module, deprecatedContext, keysForDeprecation[i]);\n      }\n\n      return deprecatedContext;\n    },\n\n    /*\n      Defines a key on an object to act as a proxy for deprecating the original.\n    */\n    _proxyDeprecation: function _proxyDeprecation(obj, proxy, key) {\n      if (typeof proxy[key] === 'undefined') {\n        Object.defineProperty(proxy, key, {\n          get: function get() {\n            _ember['default'].deprecate('Accessing the test module property \"' + key + '\" from a callback is deprecated.', false, { id: 'ember-test-helpers.test-module.callback-context', until: '0.6.0' });\n            return obj[key];\n          }\n        });\n      }\n    },\n\n    _setupContainer: function _setupContainer(isolated) {\n      var resolver = this.resolver;\n\n      var items = (0, _emberTestHelpersBuildRegistry['default'])(!isolated ? resolver : Object.create(resolver, {\n        resolve: {\n          value: function value() {}\n        }\n      }));\n\n      this.container = items.container;\n      this.registry = items.registry;\n\n      if ((0, _emberTestHelpersHasEmberVersion['default'])(1, 13)) {\n        var thingToRegisterWith = this.registry || this.container;\n        var router = resolver.resolve('router:main');\n        router = router || _ember['default'].Router.extend();\n        thingToRegisterWith.register('router:main', router);\n      }\n    },\n\n    _setupIsolatedContainer: function _setupIsolatedContainer() {\n      var resolver = this.resolver;\n      this._setupContainer(true);\n\n      var thingToRegisterWith = this.registry || this.container;\n\n      for (var i = this.needs.length; i > 0; i--) {\n        var fullName = this.needs[i - 1];\n        var normalizedFullName = resolver.normalize(fullName);\n        thingToRegisterWith.register(fullName, resolver.resolve(normalizedFullName));\n      }\n\n      if (!this.registry) {\n        this.container.resolver = function () {};\n      }\n    },\n\n    _setupIntegratedContainer: function _setupIntegratedContainer() {\n      this._setupContainer();\n    }\n\n  });\n});","define('ember-test-helpers/test-resolver', ['exports'], function (exports) {\n  'use strict';\n\n  exports.setResolver = setResolver;\n  exports.getResolver = getResolver;\n  var __resolver__;\n\n  function setResolver(resolver) {\n    __resolver__ = resolver;\n  }\n\n  function getResolver() {\n    if (__resolver__ == null) {\n      throw new Error('you must set a resolver with `testResolver.set(resolver)`');\n    }\n\n    return __resolver__;\n  }\n});","define('ember-test-helpers/wait', ['exports', 'ember'], function (exports, _ember) {\n  /* globals self */\n\n  'use strict';\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  exports._teardownAJAXHooks = _teardownAJAXHooks;\n  exports._setupAJAXHooks = _setupAJAXHooks;\n  exports['default'] = wait;\n\n  var jQuery = _ember['default'].$;\n\n  var requests;\n  function incrementAjaxPendingRequests(_, xhr) {\n    requests.push(xhr);\n  }\n\n  function decrementAjaxPendingRequests(_, xhr) {\n    for (var i = 0; i < requests.length; i++) {\n      if (xhr === requests[i]) {\n        requests.splice(i, 1);\n      }\n    }\n  }\n\n  function _teardownAJAXHooks() {\n    if (!jQuery) {\n      return;\n    }\n\n    jQuery(document).off('ajaxSend', incrementAjaxPendingRequests);\n    jQuery(document).off('ajaxComplete', decrementAjaxPendingRequests);\n  }\n\n  function _setupAJAXHooks() {\n    requests = [];\n\n    if (!jQuery) {\n      return;\n    }\n\n    jQuery(document).on('ajaxSend', incrementAjaxPendingRequests);\n    jQuery(document).on('ajaxComplete', decrementAjaxPendingRequests);\n  }\n\n  var _internalCheckWaiters;\n  if (_ember['default'].__loader.registry['ember-testing/test/waiters']) {\n    _internalCheckWaiters = _ember['default'].__loader.require('ember-testing/test/waiters').checkWaiters;\n  }\n\n  function checkWaiters() {\n    if (_internalCheckWaiters) {\n      return _internalCheckWaiters();\n    } else if (_ember['default'].Test.waiters) {\n      if (_ember['default'].Test.waiters.any(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var context = _ref2[0];\n        var callback = _ref2[1];\n        return !callback.call(context);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function wait(_options) {\n    var options = _options || {};\n    var waitForTimers = options.hasOwnProperty('waitForTimers') ? options.waitForTimers : true;\n    var waitForAJAX = options.hasOwnProperty('waitForAJAX') ? options.waitForAJAX : true;\n    var waitForWaiters = options.hasOwnProperty('waitForWaiters') ? options.waitForWaiters : true;\n\n    return new _ember['default'].RSVP.Promise(function (resolve) {\n      var watcher = self.setInterval(function () {\n        if (waitForTimers && (_ember['default'].run.hasScheduledTimers() || _ember['default'].run.currentRunLoop)) {\n          return;\n        }\n\n        if (waitForAJAX && requests && requests.length > 0) {\n          return;\n        }\n\n        if (waitForWaiters && checkWaiters()) {\n          return;\n        }\n\n        // Stop polling\n        self.clearInterval(watcher);\n\n        // Synchronously resolve the promise\n        _ember['default'].run(null, resolve);\n      }, 10);\n    });\n  }\n});","define('klassy', ['exports'], function (exports) {\n  /**\n   Extend a class with the properties and methods of one or more other classes.\n  \n   When a method is replaced with another method, it will be wrapped in a\n   function that makes the replaced method accessible via `this._super`.\n  \n   @method extendClass\n   @param {Object} destination The class to merge into\n   @param {Object} source One or more source classes\n   */\n  'use strict';\n\n  var extendClass = function extendClass(destination) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    var source;\n\n    for (var i = 0, l = sources.length; i < l; i++) {\n      source = sources[i];\n\n      for (var p in source) {\n        if (source.hasOwnProperty(p) && destination[p] && typeof destination[p] === 'function' && typeof source[p] === 'function') {\n\n          /* jshint loopfunc:true */\n          destination[p] = (function (destinationFn, sourceFn) {\n            var wrapper = function wrapper() {\n              var prevSuper = this._super;\n              this._super = destinationFn;\n\n              var ret = sourceFn.apply(this, arguments);\n\n              this._super = prevSuper;\n\n              return ret;\n            };\n            wrapper.wrappedFunction = sourceFn;\n            return wrapper;\n          })(destination[p], source[p]);\n        } else {\n          destination[p] = source[p];\n        }\n      }\n    }\n  };\n\n  // `subclassing` is a state flag used by `defineClass` to track when a class is\n  // being subclassed. It allows constructors to avoid calling `init`, which can\n  // be expensive and cause undesirable side effects.\n  var subclassing = false;\n\n  /**\n   Define a new class with the properties and methods of one or more other classes.\n  \n   The new class can be based on a `SuperClass`, which will be inserted into its\n   prototype chain.\n  \n   Furthermore, one or more mixins (object that contain properties and/or methods)\n   may be specified, which will be applied in order. When a method is replaced\n   with another method, it will be wrapped in a function that makes the previous\n   method accessible via `this._super`.\n  \n   @method defineClass\n   @param {Object} SuperClass A base class to extend. If `mixins` are to be included\n   without a `SuperClass`, pass `null` for SuperClass.\n   @param {Object} mixins One or more objects that contain properties and methods\n   to apply to the new class.\n   */\n  var defineClass = function defineClass(SuperClass) {\n    var Klass = function Klass() {\n      if (!subclassing && this.init) {\n        this.init.apply(this, arguments);\n      }\n    };\n\n    if (SuperClass) {\n      subclassing = true;\n      Klass.prototype = new SuperClass();\n      subclassing = false;\n    }\n\n    if (arguments.length > 1) {\n      var extendArgs = Array.prototype.slice.call(arguments, 1);\n      extendArgs.unshift(Klass.prototype);\n      extendClass.apply(Klass.prototype, extendArgs);\n    }\n\n    Klass.constructor = Klass;\n\n    Klass.extend = function () {\n      var args = Array.prototype.slice.call(arguments, 0);\n      args.unshift(Klass);\n      return defineClass.apply(Klass, args);\n    };\n\n    return Klass;\n  };\n\n  /**\n   A base class that can be extended.\n  \n   @example\n  \n   ```javascript\n   var CelestialObject = Klass.extend({\n     init: function(name) {\n       this._super();\n       this.name = name;\n       this.isCelestialObject = true;\n     },\n     greeting: function() {\n       return 'Hello from ' + this.name;\n     }\n   });\n  \n   var Planet = CelestialObject.extend({\n     init: function(name) {\n       this._super.apply(this, arguments);\n       this.isPlanet = true;\n     },\n     greeting: function() {\n       return this._super() + '!';\n     },\n   });\n  \n   var earth = new Planet('Earth');\n  \n   console.log(earth instanceof Klass);           // true\n   console.log(earth instanceof CelestialObject); // true\n   console.log(earth instanceof Planet);          // true\n  \n   console.log(earth.isCelestialObject);          // true\n   console.log(earth.isPlanet);                   // true\n  \n   console.log(earth.greeting());                 // 'Hello from Earth!'\n   ```\n  \n   @class Klass\n   */\n  var Klass = defineClass(null, {\n    init: function init() {}\n  });\n\n  exports.Klass = Klass;\n  exports.defineClass = defineClass;\n  exports.extendClass = extendClass;\n});","define(\"qunit\", [\"exports\"], function (exports) {\n  /* globals QUnit */\n\n  \"use strict\";\n\n  var _module = QUnit.module;\n  exports.module = _module;\n  var test = QUnit.test;\n  exports.test = test;\n  var skip = QUnit.skip;\n  exports.skip = skip;\n  var only = QUnit.only;\n\n  exports.only = only;\n  exports[\"default\"] = QUnit;\n});","/* jshint ignore:start */\n\nrunningTests = true;\n\nif (window.Testem) {\n  window.Testem.hookIntoTestFramework();\n}\n\n\n\n/* jshint ignore:end */\n"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/oDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACp1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7yMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"test-support.js"}